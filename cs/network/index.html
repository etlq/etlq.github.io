
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- google adsense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9538560944966473"
     crossorigin="anonymous"></script>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-W3N6GZK3FP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-W3N6GZK3FP');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta content="Computer Networks LAN/WAN/TCP/IP Fundamentals" name='description'/>
  <title>Computer Networks LAN/WAN/TCP/IP Fundamentals</title>
  <meta property="og:url" content="https://etlq.github.io/" />
  <meta property="og:site_name" content="My Review of Everything" />
  <meta name="google-adsense-account" content="ca-pub-9538560944966473">
  <!-- this "/style.css" specifies the root of the domain -->
  <link rel="stylesheet" href="/style.css" />   
</head>
<body>

  <!-- Sticky Header -->
  <header class="header">
    <div class="header-inner">
    <!--  <a href="#" class="back">‚Üê</a> -->

      <span class="header-title"><a href="https://etlq.github.io/">My review of everything</a></span>

      <nav class="menu">
    <!-- 
        <a href="#admission">Admission</a> 
        <a href="#courses">Courses</a> 
        <a href="#thoughts">Thoughts</a> 
    -->
      <button id="themeToggle" class="theme-toggle">
        üåô Dark
      </button>
      </nav>
    </div>
  </header>

  <main class="container">
    <section class="card" id="courses">
<h1>Computer Network LAN/WAN/TCP/IP Fundamentals</h1><hr><div style="font-family:'Andale Mono', AndaleMono, 'Roboto Mono', Monaco, Consolas, monospace; line-height: 1.4; font-size: 0.95em ">&nbsp;<br>###########################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;computer network &nbsp;&#45; &nbsp;overview &nbsp;&nbsp;&nbsp;###&nbsp;<br>###########################################&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;OSI reference model &#58; 7 layers&nbsp;<br>###&nbsp;<br>&nbsp;<br>1&#46; physical &#58;&nbsp;<br>&nbsp;&nbsp;&#45; voltage, cable, light/electrical signal, connector, etc (transmission methods like simplex, half&#45;duplex, duplex)&nbsp;<br>&nbsp;<br>2&#46; data link &#58; transmit &quot;frame&quot; between physical addresses of the NIC interfaces (of devices)&#46; tries to be error&#45;free&#46; frame encapsulates higher layers&#46;&nbsp;<br>&nbsp;&nbsp;&#45; it&#039;s a point&#45;to&#45;point protocol&#46; i&#46;e&#46; your local post office delivers a package directly to your house&#46; in contrast, international package delivery may hop across many intermediate post offices, which is not point&#45;to&#45;point&#46;&nbsp;<br>&nbsp;&nbsp;&#45; ARP, RARP protocols&nbsp;<br>&nbsp;&nbsp;there are two sub layers&#58;&nbsp;<br>&nbsp;&nbsp;&#45; MAC (media access control)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; data transmission medium can be coax, fiber optic, infrared, radio, etc&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; to standardize the way each medium can be accessed, there are common MAC layer protocols e&#46;g &nbsp;ethernet (IEEE 802&#46;3 for 10Mbps ethernet), token ring (IEEE 802&#46;5), FDDI&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; suppose you have a LAN using ethernet, and another LAN using token ring&#46; to connect the two LANs, you need &quot;bridge&quot; device which basically works as &#039;translator&#039; of the two protocols&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; MAC addr is immutable uuid assigned to every hardware device, usually NIC interface&#46;&nbsp;<br>&nbsp;&nbsp;&#45; LLC (logical link control)&#58; IEEE 802&#46;2&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; defines how to initiate, maintain, terminate connections, how to detect error, how to share &quot;turns&quot; among participants, in what bits pattern, etc&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; encapsulates upper layers&#46;&nbsp;<br>&nbsp;<br>====&gt; IEEE specifies 802&#46;x for L1 & L2&nbsp;<br>&nbsp;<br>&nbsp;<br>3&#46; network &#58;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; facilitates end&#45;to&#45;end communication&#46; e&#46;g&#46; you just specify an address in manhattan, and ship it from a local mail box in australia, and still it gets delivered thru various middle men&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;e&#46;g&#46; IP addr / DNS&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; note the &#039;network&#039; layer address is &quot;logical&quot; in nature, as opposed to physical&#46; physical address of your house can be latitude/longitude, but logical addr might be apt no&#46; street number, zip code, etc&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; commom L3 protocols are IPX (comes with SPX), IP (comes with TCP), ICMP (internet control msg protocl, used by ping), IGMP (internet group mgmt protocol)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; &quot;router&quot; is an L3 device&nbsp;<br>&nbsp;<br>4&#46; transport&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; flow control (notifies the receiver, tries to re&#45;transmit if no ack, checks the message/packet sequence/order etc)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; common L4 protocols are SPX, TCP&nbsp;<br>&nbsp;<br>5&#46; session&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; further abstracts/virtualizes coeections of lower layers&#46; e&#46;g&#46; we call &quot;putty ssh session&quot; which keeps one &quot;session&quot; once you login until you logout, but if you are idle, your session may be kept alive, but the lower layer network status may be changing/rebooting/disconnecting/refreshing etc&#46;&nbsp;<br>&nbsp;<br>6&#46; presentation&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; presentation of byte streams (little/big endian?ASCII or UTF8 or Shift&#45;JIS ? how to represent numeric ? IEEE float ?)&nbsp;<br>&nbsp;<br>7&#46; application (i&#46;e&#46; service)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&#45; &quot;service&quot; for users, like email, FTP app, browsers, network directory, &quot;putty&quot; for ssh terminals/sessions&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;LAN MAN WAN&nbsp;<br>###&nbsp;<br>&nbsp;<br>LAN &#45; end node computers&#46; relatively fast high bandwidth&#46; (fast used to mean 1MBps, but now easily 1000MBps)&nbsp;<br>MAN &#45; interconnects LANs&#46; usually the fastest bandwidth&#46; but sometimes covers the functionality of LAN/WAN&#46;&nbsp;<br>WAN &#45; interconnects MANs / various telecom facilities&#46; usually the slowest bandwidth&#46;&nbsp;<br>&nbsp;<br>==&gt; nowadays, the distinction can get blurry as we more often think in terms of a holistic perspective&#46; access control may not be LAN/WAN based, but rather just other mechanism of more peer&#45;to&#45;peer authentication between user(client) and service(server/resource)&#46; this leads to a decline of traditional NOS&#46;&nbsp;<br>&nbsp;<br>common usages of LAN&#58;&nbsp;<br>&#45; sharing resources over network across multiple nodes (like desktop computers)&nbsp;<br>&#45;&#45; printer&nbsp;<br>&#45;&#45; netapp filers / storage&nbsp;<br>&#45;&#45; email / file transfer&nbsp;<br>&#45;&#45; DB&nbsp;<br>&#45;&#45; remote access&nbsp;<br>&nbsp;<br>==&gt; obviously access control mechanism becomes important, e&#46;g&#46; somebody decides to print 1000 page document, then might block everybody else trying to use a printer&#46; NOS (network OS) needs to control LAN in a robust way that can accommodate failover&#46;&nbsp;<br>&nbsp;<br>LAN consists of&#58;&nbsp;<br>&#45; computers (like desktop, laptop, servers)&nbsp;<br>&#45; shared services/resources (aka peripherals) like disk, printer&#46;&nbsp;<br>&#45; NIC&nbsp;<br>&#45; cables&nbsp;<br>&#45; NOS / NRS (network routing software)&nbsp;<br>&nbsp;<br>LAN mechanism&#58;&nbsp;<br>&#45; NIC&nbsp;<br>&#45; topology &#58; ring, bus, star (most common)&nbsp;<br>&#45; access control &#58; implemented in MAC layer, like random/centralized/distributed&nbsp;<br>&#45; transmission medium&#58; fiber optic, coax wire, radio, etc&nbsp;<br>&#45; signal/data encoding&#58; baseband (digital pulse), broadband (analog wave), etc as regulated by MAC layer&nbsp;<br>&nbsp;<br>===&gt; obviously LAN has physical (L1,L2) & logical (L3,L4) aspects, but due to the trend of LAN/WAN all becoming one cohesive unit, the notion of LAN as a distinct logical network unit is becoming obsolete, but LAN is still very much tied to a certain geographical unit, like a building floor, etc&#46; (generally speaking)&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;SLIP, CSLIP, PPP &nbsp;&nbsp;&#58; L2 protocols&nbsp;<br>###&nbsp;<br>&nbsp;<br>LAN with ethernet is one common way to connect to the internet&#46; another is to connect your computer to a modem&#46;&nbsp;<br>an old modem connects to a serial port (aka RS232) over SLIP (serial port internet protocl)&#46;&nbsp;<br>SLIP packet encapsulates IP datagram&#46; SLIP header is 40 bytes, considered too big, hence CSLIP (compressed SLIP), which eliminates dupe info&#46;&nbsp;<br>then PPP (point&#45;to&#45;point) protocols took over, with many advantages&#58;&nbsp;<br>&#45; eliminates dupe info to reduce header/overhead size&nbsp;<br>&#45; supports more protocols than just IP (whereas SLIP only does IP)&nbsp;<br>&#45; dynamically negotiates IP addrs (whereas SLIP requires hard&#45;code src/dst IP addrs)&nbsp;<br>&#45; implements LLC protocols (essentially)&nbsp;<br>&#45; supports CRC (cyclic redundancy check) on every frame (whereas SLIP does none)&nbsp;<br>&nbsp;<br>MTU (max transfer unit) &#58; single frame max size&#46; &nbsp;&nbsp;e&#46;g&#46; ethernet v2 MTU = 1500 bytes&#46; &nbsp;PPPoE MTU is 1492 (cos 8bytes are used as PPPoE header)&nbsp;<br>&nbsp;<br>(ref) https&#58;//en&#46;wikipedia&#46;org/wiki/Maximum_transmission_unit&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;generic vocab&nbsp;<br>###&nbsp;<br>&nbsp;<br>protocl VS interface&#58; generally protocl is each layer, and interface is how diff layers interface/connects/interacts&#46;&nbsp;<br>service access point&#58; available at each layer where a request is made/serviced&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##########################&nbsp;<br>### &nbsp;&nbsp;physical layer &nbsp;&nbsp;###&nbsp;<br>##########################&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;L1 services&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45; circuit establishment/release (only used in circuit switched networks)&nbsp;<br>&#45; bit sync&nbsp;<br>&#45; data processing&nbsp;<br>&nbsp;&nbsp;&#45; how to receive from / send to upper layers&nbsp;<br>&nbsp;&nbsp;&#45; manager receive/send bit sequence&nbsp;<br>&nbsp;&nbsp;&#45; corrupt/lost data notification&nbsp;<br>&#45; network mgmt (loopback transmission/reception)&nbsp;<br>&#45; collision detection, beaconing, carrier sense (some of L2/MAC layer feature)&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;the medium&nbsp;<br>###&nbsp;<br>&nbsp;<br>e&#46;g&#46;&nbsp;<br>&#45; (un)shielded twisted pair (copper wire)&nbsp;<br>&nbsp;&nbsp;&#45; two insulated copper wires twisted on each other to reduce elecromagnetic induction (cross talk)&#46; each signal requires both wires&#46;&nbsp;<br>&nbsp;&nbsp;&#45; shielded means &#039;grounded&#039; (the shield absorbs/disperse electromagnetic waves to the ground before they touch the wires)&nbsp;<br>&nbsp;&nbsp;&#45; common user level cable is UTP &nbsp;(see CAT standards by ANSI/EIA)&nbsp;<br>&nbsp;<br>&#45; coax cable&nbsp;<br>&nbsp;&nbsp;&#45; commonly used by TV companies to connect home/office and community antenna&#46;&nbsp;<br>&nbsp;&nbsp;&#45; used to be used for LAN/ethernet in business&#46;&nbsp;<br>&nbsp;&nbsp;&#45; shielded, designed to transmit long distance (kind of), invented by AT&T&nbsp;<br>&nbsp;&nbsp;&#45; read more about the physics https&#58;//en&#46;wikipedia&#46;org/wiki/Coaxial_cable&nbsp;<br>&nbsp;<br>&#45; fiber optic (aka optical fiber)&nbsp;<br>&nbsp;&nbsp;&#45; transmit light pulse thru a glass/plastic wire(fiber)&nbsp;<br>&nbsp;&nbsp;&#45; generally carries more data than conventional copper wire, and more robust against electromagnetic interference&#46;&nbsp;<br>&nbsp;&nbsp;&#45; sensitive material and thus expensive to install/maintain&#46;&nbsp;<br>&nbsp;&nbsp;&#45; commonly used for important long distance transmission&#46; (phone lines, high end switches)&nbsp;<br>&nbsp;&nbsp;&#45; single mode optic fiber&#58; used for long distance&#46; single ray(mode) of light&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiber core is smaller (light travels close to straight) than multi&#45;mode optic fiber&#46;&nbsp;<br>&nbsp;&nbsp;&#45; multi mode optic fiber &#58; transmit multi light rays simultaneously (each going thru a diff reflection angle),&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hence a larger fiber core than single mode&#46; (i&#46;e&#46; light reflects a lot within the cable)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only used for short distance (because they disperse over distance, aka &quot;modal dispersion&quot;)&nbsp;<br>&nbsp;<br>(ref) https&#58;//en&#46;wikipedia&#46;org/wiki/Single&#45;mode_optical_fiber &nbsp;&nbsp;(see how the core is thinner)&nbsp;<br>(ref) https&#58;//en&#46;wikipedia&#46;org/wiki/Multi&#45;mode_optical_fiber &nbsp;&nbsp;&nbsp;(see how the core is thicker)&nbsp;<br>&nbsp;<br>&nbsp;<br>&#45; radio frequency&nbsp;<br>&#45; infrared&nbsp;<br>&nbsp;&nbsp;&#45; both RF and infrared have specs well defined (signal strength, distance, etc)&nbsp;<br>&nbsp;<br>====&gt; L1 spec specifies the voltage, how to generate signal, signal strength, cable structure (material, pin layout, connectors, topology), transmission techniques like simplex, half&#45;duplex, duplex&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;signaling methods&nbsp;<br>###&nbsp;<br>&nbsp;<br>there are two&#46;&nbsp;<br>&nbsp;<br>(1) baseband&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; bi&#45;directional, signal can travel both directions&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; digital pulse &#58; cannot use modulate analog wave by amplitude/frequency/phase&#46; only TDMA among devices to coordinate the timing to transmit (i&#46;e&#46; channel utilization method)&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; full&#45;channel &#58; the whole bandwidth of a channel is used for a single signal,&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; signal boost &#58; only repeater (regen) of digital pulse&#46; canot use amplifier&nbsp;<br>&nbsp;<br>(2) broadband&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; uni&#45;directional&#58; needs a mechanism to facilitate both directions (send & receive)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&#46;g&#46; dual&#45;physical&#45;cable, or FDMA (2 channels within one cable)&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; analog wave&#58; continous non&#45;discrete electromagnetic wave with 3 properties by which you can modulate&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; amplitude (of voltage) &#58; AM&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; frequency &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#58; FM&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; phase &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#58; PM&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; multiplexing &#58; multi&#45;channel multi&#45;signal transmission on a carrier channel/signal&nbsp;<br>&nbsp;&nbsp;&nbsp;&#45; signal boost &#58; amplifier of analog transmission (but amplifies both signal and noise)&nbsp;<br>&nbsp;<br>&nbsp;<br>==&gt; which one is better for long distance comm ? &nbsp;digital is easy to regenerate&#46; but many techniques in broadband facilitate reliable long distance communication&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;common UTP cable standard &nbsp;(by ANSI/EIA)&nbsp;<br>###&nbsp;<br>&nbsp;<br>defines cable materials, connectors, etc for UTP (ushielded twisted pair) copper cable&#46; &nbsp;usually 100 meter max length&#46;&nbsp;<br>&nbsp;<br>&#45; CAT 1 &#58; &nbsp;&nbsp;1Mbps &nbsp;(old phone cable)&nbsp;<br>&#45; CAT 2 &#58; &nbsp;&nbsp;4Mbps &nbsp;(token ring network)&nbsp;<br>&#45; CAT 3 &#58; &nbsp;10Mbps &nbsp;(10base&#45;t ethernet)&nbsp;<br>&#45; CAT 4 &#58; &nbsp;16Mbps &nbsp;(token ring network)&nbsp;<br>&#45; CAT 5 &#58; 100Mbps &nbsp;(100base&#45;t, fast ethernet, token ring)&nbsp;<br>&#45; CAT 5e&#58; &nbsp;&nbsp;1Gbps &nbsp;(10G ethernet, gigabit ethernet) &#45; only 55 meters&nbsp;<br>&#45; CAT 6 &#58; &nbsp;10Gbps &nbsp;(10G ethernet, gigabit ethernet) &#45; only 55 meters&nbsp;<br>&#45; CAT 6a&#58; &nbsp;same as CAT6 but more robust against electromagnetic interference&nbsp;<br>&#45; CAT 7 &#58; &nbsp;same as CAT6 but 100 meters&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;signal encoding&nbsp;<br>###&nbsp;<br>&nbsp;<br>e&#46;g&#46; you transition from negative voltage to positive voltage to encode &quot;1&quot; and vice versa to encode &quot;0&quot;&nbsp;<br>&#45; manchester encoding&nbsp;<br>&#45; NRTZ (non return to zero inverted)&nbsp;<br>&#45; more&nbsp;<br>&nbsp;<br>&quot;bit time&quot; &#58; aka bit duration &#45; a length of time in which you transmit a bit&nbsp;<br>&quot;bit clock&quot;&#58; aka bit synch &#45; a mechanism for all devices in the network to synch (share) bit time&nbsp;<br>&quot;start/stop bit&quot; &#58; how to encode start & end of transmission&nbsp;<br>&quot;delimiter bit&quot; &#58; how to encode delimiter&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;network (physical) topology&nbsp;<br>###&nbsp;<br>&nbsp;<br>(1) bus&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;o &nbsp;&nbsp;o &nbsp;&nbsp;o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;every node is connected to a common line&#46;&nbsp;<br>&nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;used for baseband where everybody gets every message by any node&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;no loop, every node can freely join/leave without impact to topology&nbsp;<br>| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;easily gets congested&#46; so usually gets split into segments connected by bridge/switch/router&nbsp;<br>o &nbsp;&nbsp;o &nbsp;&nbsp;o&nbsp;<br>&nbsp;<br>&nbsp;<br>(2) ring&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;o &#45; o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# closed loop toplogy, i&#46;e&#46; joining/leaving a node can disrupt&nbsp;<br>&nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# each node is a repeater&nbsp;<br>o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# data travels to a single direction&nbsp;<br>&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# sometimes we see dual ring, i&#46;e&#46; two physical lines instead of one, which allows data travel both direction&#46;&nbsp;<br>&nbsp;&nbsp;o &#45; o&nbsp;<br>&nbsp;<br>&nbsp;<br>(3) star&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# a &quot;hub&quot; device (usually a switch)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the hub can be a single point of failure,&nbsp;<br>o &#45; o &#45; o &nbsp;&nbsp;&nbsp;# but if it&#039;s intelligent, it can manager/control the traffic/network very efficiently&nbsp;<br>&nbsp;&nbsp;&nbsp;/ \&nbsp;<br>&nbsp;&nbsp;o &nbsp;&nbsp;o&nbsp;<br>&nbsp;<br>&nbsp;<br>(4) tree&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# topologically, this is an interconnection of of multiple buses (i&#46;e&#46; no closed loop)&nbsp;<br>&nbsp;&nbsp;&nbsp;/ \ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# you can branch off of an existing network, also routing can be efficient, if done in binary search way&#46;&nbsp;<br>&nbsp;&nbsp;o &nbsp;&nbsp;o&nbsp;<br>&nbsp;/ \ &nbsp;&nbsp;\&nbsp;<br>o &nbsp;&nbsp;o &nbsp;&nbsp;o&nbsp;<br>&nbsp;<br>&nbsp;<br>(5) snowflake&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;o &nbsp;&nbsp;&nbsp;&nbsp;o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# a star of stars where hubs are interconnected&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<br>o &#45; o &#45;&#45;&#45; o &#45; o&nbsp;<br>&nbsp;&nbsp;&nbsp;/ \ &nbsp;&nbsp;/ \&nbsp;<br>&nbsp;&nbsp;o &nbsp;&nbsp;o o &nbsp;&nbsp;o&nbsp;<br>&nbsp;<br>&nbsp;<br>(6) mesh&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;o &#45;&#45; o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# every node is connected directly to every other node in the network&nbsp;<br>&nbsp;&nbsp;| \/ | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# resiliant, performant&nbsp;<br>&nbsp;&nbsp;| /\ | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# can be expensive/complex to manage&nbsp;<br>&nbsp;&nbsp;o &#45;&#45; o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# e&#46;g even adding a node can be expensive if the network is already big&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# only makes sense when reliability is crucial, and not too many nodes (backend server cluster, WAN)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# usually not used in LAN&nbsp;<br>&nbsp;<br>&nbsp;<br>NOTE&#58; the above is physical topology&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logical topology includes&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&#46; ethernet (uses bus topology)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&#46; token ring (uses single ring topology)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&#46; FDDI (uses dual ring topology)&nbsp;<br>&nbsp;<br>(ref) https&#58;//ccnabasics&#46;wordpress&#46;com/2012/08/01/network&#45;topologies/&nbsp;<br>&nbsp;<br>&nbsp;<br>#################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;Data Link Layer (L2) &nbsp;&nbsp;###&nbsp;<br>#################################&nbsp;<br>&nbsp;<br>recall L2 consists of two sub layers&#58;&nbsp;<br>&#45; MAC&nbsp;<br>&#45; LLC&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;MAC (media access control)&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall transmission &quot;media&quot; refers to copper wire, coaxial cable, optical fiber, RF/infrared, etc&nbsp;<br>as the media are shared, users need to operatoe on the same access control mechanism&#46;&nbsp;<br>&nbsp;<br>MAC functionality&nbsp;<br>&#45; how to determine media availability&nbsp;<br>&#45; how to initiate/end access/connection&nbsp;<br>&#45; how to transmit/listen for what interval,&nbsp;<br>&#45; (dis)assemble headers/preemble/delimiters, bit pattern,&nbsp;<br>&#45; flow control (buffering, etc)&nbsp;<br>&#45; error detection&nbsp;<br>&#45;&#45; transmission error (dest not reachable, etc)&nbsp;<br>&#45;&#45; frame format error (CRC error, etc)&nbsp;<br>&#45;&#45; processing error (persistent frames, etc)&nbsp;<br>&#45; interface with L1/L3&nbsp;<br>&nbsp;<br>Common MAC layer protocols&nbsp;<br>&#45; ethernet (IEEE 802&#46;3) &#58; based on CSMA/CD&nbsp;<br>&#45; token passing&nbsp;<br>&nbsp;<br>if you try connec to two LANs, one based on ethernet, the other based on token passing, then you need a bridge (translator) device&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;MAC &#45; methods for access control&nbsp;<br>###&nbsp;<br>&nbsp;<br>lets look at 3 access control methods&#46;&nbsp;<br>&nbsp;<br>(1) random access control&nbsp;<br>(2) distributed access control&nbsp;<br>(3) central access control&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;(1) random access control&nbsp;<br>##&nbsp;<br>&nbsp;<br>any node can transmit without permission&#46;&nbsp;<br>&nbsp;<br>(1&#46;1) CSMA/CD &#58; carrier sense multiple access / collision detection&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; used in Ethernet&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; most common method for bus access control&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(recall buss topology, where everything is brainlessly broadcast, so each node discards if the frame dst MAC addr is not himself)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; carrier sense == listen to the medium&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45;&#45; if the medium free, then transmit&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; collision detection &#58; keep listening while transmitting, then detect collision&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; obviously the more devices in the bus, the more collision, in general&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; &#039;switch&#039; device can manage traffic more intelligently to reduce collision&nbsp;<br>&nbsp;<br>(1&#46;2) slotted ring&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; recall a ring topology&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; every node sends a fixed lendgth slot (N&#45;byte&#45;length) of frame, with a bit in the header indicating &quot;empty&quot; or &quot;used&quot;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; if empty, the node can insert data into the payload, and fwd the frame to the next node&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; either dst frame marks it empty upon receipt, or fwd it along until it reaches the sender node itself who can release it (i&#46;e&#46; mark it empty)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; in theory, everybody has a fair equal random chance&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; note the distinction from Token Ring method which distributes token, instead of up for grab slots&#46;&nbsp;<br>&nbsp;<br>(1&#46;3) register insertion&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; kind of like more laborate slotted ring&#46; each frame has register space where user can put dest addr and data&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;(2) distributed access control&nbsp;<br>##&nbsp;<br>&nbsp;<br>access control is distributed (think of everybody taking turns) based on token or some mechanism of wait period assignment&#46;&nbsp;<br>&nbsp;<br>(2&#46;1) token passing&nbsp;<br>&nbsp;<br>empty frame &quot;aka token&quot; is distributed among nodes, and if a node receives a token, then can write the dest addr and insert datagram&#46;&nbsp;<br>specs define rules, like how long a node can keep the token, how can issue a new token under what conditions, etc&nbsp;<br>there is usually a monitor node that monitors tokens&#46; (e&#46;g&#46; removes corrupt tokens)&nbsp;<br>&nbsp;<br>example of token passing method&#58;&nbsp;<br>&#45; token ring&nbsp;<br>&#45; ARCNET&nbsp;<br>&#45; FDDI&nbsp;<br>&nbsp;<br>(2&#46;2) CSMA/CA &nbsp;&#58; &nbsp;carrier sense multiple access / collision avoidance&nbsp;<br>&nbsp;<br>each node listens to see if any ongoing transmission (carrier sense), then once any existing transmission ends (or after certain idle period is observed), each node waits for a unique, predetermined length of time, then if no others started transmittion then the node can start transmitting&#46;&nbsp;<br>how to determine unique wait period for each node? &#45; based on MAC addr or some kind of math&#46;&nbsp;<br>&nbsp;<br>there is usually an associated collision detection/correction mechanism&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;(3) central access control&nbsp;<br>##&nbsp;<br>&nbsp;<br>a central/master/primary node governing access control for the rest&#46;&nbsp;<br>&nbsp;<br>(3&#46;1) polling&nbsp;<br>&nbsp;<br>a master node polls on each node who responds yes or no (to transmit), then the master node grants individually the right to transmit&#46;&nbsp;<br>this method is used when nodes are not intelligent&#46; (not a bad thing, it may help to bring down manufacture cost of each node)&nbsp;<br>&nbsp;<br>(3&#46;2) circuit switching&nbsp;<br>&nbsp;<br>each node sends a request to the master node &quot;my addr is XYZ, and i want to transmit to node ABC&quot;&nbsp;<br>then the master node called &quot;switch&quot; will (reject or) establish the connection called &quot;curcuit&quot; between the sender node and receiver node&#46;&nbsp;<br>a switch can handle multiple connections concurrently&#46;&nbsp;<br>&nbsp;<br>commonly used in telephone network&#46; you dial (request) and gets connected or rejected (busy line)&nbsp;<br>&nbsp;<br>(3&#46;3) TDMA &nbsp;(time division multiple access)&nbsp;<br>&nbsp;<br>pretty much like CSMA/CA, except transmission time was determined by a central/master node in TDMA&#46; in CSMA/CA, it was decided by distributed network nodes&#46;&nbsp;<br>in case the master dies, TDMA lets you implement an backup master&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;L2 addressing&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall two sub layers of L2, each has its own addressing scheme&nbsp;<br>&nbsp;<br>(1) LLC &#45; SAP addr &nbsp;&nbsp;&nbsp;&nbsp;# SAP (service access point)&nbsp;<br>(2) MAC &#45; MAC addr&nbsp;<br>&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;(1) &nbsp;SAP addr&nbsp;<br>#&nbsp;<br>&nbsp;<br>see the next LLC section notes&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;(2) &nbsp;MAC addr&nbsp;<br>#&nbsp;<br>&nbsp;<br>48 bits&#58; as specified IEEE&nbsp;<br>&#45; first 24 bits for manfacture&nbsp;<br>&#45; last 24 bits for individual device (usually a NIC interface card)&nbsp;<br>&nbsp;<br>just like NAT global &#45;&gt; private IP addr translation, some LAN protocols manage/admin a 16&#45;bit local MAC addr (not globally unique) but unlike NAT, usually if you use this local 16bit MAC addr, that device doesnt need to extend to external/public network&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;LLC &nbsp;&nbsp;(logical link control)&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall L2 layer consists of two sub layers 1&#46; MAC, &nbsp;2&#46; LLC&nbsp;<br>&nbsp;<br>lets look at LLC &nbsp;aka &nbsp;IEEE 802&#46;2&nbsp;<br>&nbsp;<br>LLC does two things&#58;&nbsp;<br>&#45; acts as an interface (called &quot;device driver&quot;) that binds physical (i&#46;e&#46; MAC layer, your NIC) to logical (L3 protocol software)&nbsp;<br>&#45; facilitates concurrent multiple&#45;device multiple&#45;protocol communication / service links&#46; e&#46;g&#46; your computer may concurrently query DB, print stuff, send email, etc&#46;&nbsp;<br>&nbsp;<br>on the L2 MAC side, you have &quot;device driver&quot; firmware installed on / run by your specific hardware (like your printer, mouse, etc)&#46;&nbsp;<br>on the L3 NW layer side (usually IP but can be other protocol), you have some software that speaks IP installed on your workstation that uses CPU to run it&#46;&nbsp;<br>&nbsp;<br>===&gt; fortunately, IEEE 802&#46;2 standardized LLC&#46; so any LAN technologies (ethernet, token ring, roken bus, FDDI, etc) can follow the same LLC spec&#46;&nbsp;<br>&nbsp;<br>LLC properties&nbsp;<br>&#45; bi&#45;directional&#58; e&#46;g&#46; (L2 &#45;&gt; L3) &nbsp;ethernet NIC card may send frames up to L3 layer&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(L3 &#45;&gt; L2) &nbsp;L3 layer software may send packets down to MAC layer for printing paper&nbsp;<br>&#45; multiplex&#58; able to bind multiple L2/MAC devices (NICs) to multiple L3/NW layer protocols&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&#46;g&#46; your laptop can connect to wired/wireless LANs, over IP or non&#45;IP protocols&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&#46;g&#46; your one NIC may connect to multiple other devices over LAN&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;SAP (service access point) address&nbsp;<br>###&nbsp;<br>&nbsp;<br>suppose you have a laptop connecting to a network, you ssh into some server to run some code&#46; also you may separately have other program on your laptop querying a DB on the same server&#46; i&#46;e&#46; physically you have a single connection (laptop NIC to server NIC) but you have multiple active channels of comm ongoing&#46;&nbsp;<br>&nbsp;<br>&#45;&#45;&gt; so an incoming frame needs to know which application it needs to reach&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;this is facilitated by SAP which is essentially an extention of MAC addr, as in you append service ID to MAC addr&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>an L2 frame contains two SAPs&nbsp;<br>&#45; SSAP &#58; source SAP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# just like src IP addr &nbsp;(this is always singular)&nbsp;<br>&#45; DSAP &#58; destination SAP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# just like dst IP addr &nbsp;(this can be plural if you are, for example, broadcasting)&nbsp;<br>&nbsp;<br>note&#58; frame is aka PDU (protocol data unit) in LLC context&nbsp;<br>&nbsp;<br>if the first bit of SSAP is 0 = &quot;command&quot; LLC PDU&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 = &quot;response&quot; LLC PDU&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;SNAP (sub network access protocol)&nbsp;<br>###&nbsp;<br>&nbsp;<br>it&#039;s a mechanism for LLN to identify L3 protocols (IP, IPX, etc) to send PDU (frame) to upper layer&#46;&nbsp;<br>e&#46;g&#46;&nbsp;<br>suppose a MAC frame arrives at a NIC card (based on MAC addr), then the NIC sends IO interrupt signal to CPU who then calls the LLC device driver&#46;&nbsp;<br>LLC then takes the MAC frame and processes it as PDU to send to the right DSAP / upper layer&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;types of LLC&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall LLC does 2 things&#58;&nbsp;<br>&#45; acts as device driver interface btwn MAC layer and L3 protocol software&#46;&nbsp;<br>&#45; facilitates multi&#45;protocol service links/connections over a single physical connection&#46; &#45;&#45;&gt; there are 3 types&#46;&nbsp;<br>&nbsp;<br>type 1&#58; connectionless &nbsp;(aka &quot;datagram&quot; service)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; most common&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; least protocol overhead, no synchronization/sequencing of PDUs ==&gt; we tend to leave this to TCP/L4 layer&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; can use any of group/broadcast/individual SAPs&nbsp;<br>&nbsp;<br>type 2&#58; connection oriented&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; most robust&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; establishes a one&#45;to&#45;one connectioin using ONLY individual SAP, to guarantee all PDUs are sent, and maintains PDU sequence&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45;&#45; each PDU receives ACK, otherwise resent&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45;&#45; sequence checking (suppose PDU sequence 1&#45;9, if 4 is missing, then the receiving side discards PDU 4&gt; and requests resend&#46; TCP is smarter and buffers PDU&gt;4 already received, so LLC takes longer to correct out of sequence error)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; most protocol overhead&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; note you can have multiple connections (based on SAPs) over a single physical connection&#46; (the whole point of LLC)&nbsp;<br>&nbsp;<br>type 3&#58; connectionless with ack &nbsp;(aka ack&#039;ed connectionless)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; this is just connectionless where each PDU reception is acked&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; no connection established, no retransmission, no sequence checking&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;PDU types &nbsp;(as specified in IEEE 802&#46;2)&nbsp;<br>###&nbsp;<br>&nbsp;<br>there are 3 types&#58;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDU type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| description&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>Information (I&#45;Format) | carry user data&#46; may additionally carry LLC control info&nbsp;<br>Supervisory (S&#45;Format) | carry information to control LLC protocol operations&nbsp;<br>Unencumbered(U&#45;Format) | carry data or other special functions like initialization procedures and diagnostic sequences&nbsp;<br>&nbsp;<br>a PDU fram contains&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field &nbsp;&nbsp;&nbsp;| size&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>DSAP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 octet&nbsp;<br>SSAP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 octet&nbsp;<br>control &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 for U&#45;format, 2 for I/S formats&nbsp;<br>info/data &nbsp;&nbsp;&nbsp;&nbsp;| 0~N octets&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&#45;format PDU&nbsp;<br>&nbsp;<br>bits &nbsp;&nbsp;&nbsp;value&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// always 0&nbsp;<br>2&#45;8 &nbsp;&nbsp;&nbsp;&nbsp;send count N &nbsp;&nbsp;&nbsp;&nbsp;// only used for sequence checking for connection oriented (type 2 LLC)&nbsp;<br>9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poll/final &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// poll aka intermediary&#46; 0=poll, 1=final for PDU&#46; if this bit is 1, then type 2 & 3 must reply ack&nbsp;<br>10&#45;16 &nbsp;&nbsp;receive count N &nbsp;// only used for sequence checking for connection oriented (type 2 LLC)&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;S&#45;format PDU&nbsp;<br>&nbsp;<br>bits &nbsp;&nbsp;&nbsp;value&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>1&#45;2 &nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;<br>3&#45;4 &nbsp;&nbsp;&nbsp;&nbsp;funtion &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 00=received ready, 01=reject, 10=received not ready&nbsp;<br>5&#45;8 &nbsp;&nbsp;&nbsp;&nbsp;reserved&nbsp;<br>9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poll/final&nbsp;<br>10&#45;16 &nbsp;&nbsp;receive count N&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;U&#45;format PDU&nbsp;<br>&nbsp;<br>bits &nbsp;&nbsp;&nbsp;value&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>1&#45;2 &nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;<br>3&#45;4 &nbsp;&nbsp;&nbsp;&nbsp;function 1&nbsp;<br>5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poll/final&nbsp;<br>6&#45;8 &nbsp;&nbsp;&nbsp;&nbsp;function 2&nbsp;<br>&nbsp;<br>func 1 & func 2 encode 5 bit length function&#46; lets look at the description below&nbsp;<br>&nbsp;<br>f1 f2&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>00 000 &nbsp;| &nbsp;UI&#58; unencumbered info&nbsp;<br>00 110 &nbsp;| &nbsp;UA&#58; unencumbered ack&nbsp;<br>11 101 &nbsp;| &nbsp;XID&#58; exchange info&nbsp;<br>00 111 &nbsp;| &nbsp;test&nbsp;<br>11 110 &nbsp;| &nbsp;SABME&#58; set async balance mode extended&nbsp;<br>11 010 &nbsp;| &nbsp;DM&#58; disconnect mode&nbsp;<br>00 010 &nbsp;| &nbsp;DISC&#58; disconnect&nbsp;<br>10 001 &nbsp;| &nbsp;FRMR&#58; frame reject&nbsp;<br>10 110 &nbsp;| &nbsp;AC0&#58; ack connectionless seq 0&nbsp;<br>10 111 &nbsp;| &nbsp;AC1&#58; ack connectionless seq 1&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IEEE 802&#46;x &nbsp;standards&nbsp;<br>###&nbsp;<br>&nbsp;<br>IEEE standards for L1/L2&nbsp;<br>&nbsp;<br>e&#46;g&#46;&nbsp;<br>&nbsp;<br>802&#46;2 &nbsp;&#58; LLC&nbsp;<br>802&#46;3 &nbsp;&#58; ethernet &#45; CSMA/CD spec for random control LAN&nbsp;<br>802&#46;5 &nbsp;&#58; token ring &#45; distributed token passing LAN based on ring topology&nbsp;<br>802&#46;11 &#58; wireless LAN &#45; RF based&#46; many derivatives&#46; (a/b/g/n)&nbsp;<br>802&#46;15 &#58; wireless PAN &#45; personal area network&#46; many derivatives&#46; 802&#46;15&#46;1 = bluetooth, &nbsp;802&#46;15&#46;4 = used for zigbee, mifi, etc&nbsp;<br>&nbsp;<br>see the full list &nbsp;https&#58;//en&#46;wikipedia&#46;org/wiki/IEEE_802&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;10Mbps ethernet &nbsp;&#45; &nbsp;CSMA/CD&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45; defined by IEEE 802&#46;3&nbsp;<br>&#45; random access control method&nbsp;<br>&#45; shared bus topology&nbsp;<br>&nbsp;<br>recall out discussion from prev section&#58;&nbsp;<br>&nbsp;<br>(1&#46;1) CSMA/CD &#58; carrier sense multiple access / collision detection&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; most common method for bus access control&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(recall bus topology, where everything is brainlessly broadcast, so each node discards if the frame dst MAC addr is not himself)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; carrier sense == listen to the medium&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45;&#45; if the medium free, then transmit&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; multiple access &#58; simply means multiple devices access the same medium&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; collision detection &#58; keep listening while transmitting, then detect collision&#46; (to be distinguished from collision avoidance)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; obviously the more devices in the bus, the more collision, in general&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; &#039;switch&#039; device can manage traffic more intelligently to reduce collision&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;CSMA/CD frame format&nbsp;<br>##&nbsp;<br>&nbsp;<br>preamble&#58; &#45; a 7&#45;byte (56&#45;bit) field consisting of alternating 0s and 1s, used for synchronization (timing of bits)&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; each node listens to he medium to determine where each bit transmission begins and ends&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; to keep the implementation cost low, no internal clocking mechanism in NIC&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; instead, the devices use the actual (preamble) transmission to synchronize to the bit cycle&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; by having a predictable/recognizable pattern of 0s and 1s for a relatively long duration, each node can adjust its starting and ending listening points to the exact cycle of the encoding scheme&#46;&nbsp;<br>&nbsp;<br>start frame delimiter &#58; identifies the beginning of a frame&#46; value is 10101011&nbsp;<br>&nbsp;<br>addressing &#58; CSMA/CD can be implemented with either local (16 bit) or global (48 bit) addressing&#46;&nbsp;<br>&nbsp;<br>length count &#58; size of the info field, i&#46;e&#46; where the info field ends and the pad field begins&#46;&nbsp;<br>&nbsp;<br>pad field &#58; additional bits if necessary to ensure that the transmission time interval is long enough for all nodes to detect a collision&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this is related to the maximum physical length of a segment of the network&#46;&nbsp;<br>&nbsp;<br>frame check sequence &#58; CRC (cyclical redundancy check) value appended to end of frame&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CRC determines frame corruption during transmission&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;collision detection &nbsp;& &nbsp;frame padding&nbsp;<br>##&nbsp;<br>&nbsp;<br>each node needs to detect when a collision occurs&#46; if the duration of time that the collision occurs is too short for nodes far away from the collision to detect it, then those nodes will not invoke the recovery procedure&#46;&nbsp;<br>&nbsp;<br>a collision is when two or more nodes simultaneously attempt transmitting bits on the medium&#46; the electrical current on the line will be twice as high when two nodes add power to the medium&#46; if the increase is only there for a short time it will be undetectable by nodes far away&#46; thus, creating frame lengths that guarantee transmissions that will transverse the entire medium before they are completed ensures that all nodes will hear a collision&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;frame propagation &nbsp;& collision window&nbsp;<br>##&nbsp;<br>&nbsp;<br>the longest distance a frame can travel is between the two farthest nodes at each end of the medium&#46; the time it takes a frame to travel the entire length of the network is called the &quot;propagation time&quot;&#46; this is directly related to the maximum length specified for the cables in a segment of the network&#46;&nbsp;<br>&nbsp;<br>since a frame initiated at one end of the medium could incur a collision at the other end, the longest time it takes a node to detect a possible collision is twice the propagation time (because the collision must travel all the way back to the node at the other end of the medium)&#46; this is called the &quot;collision window&quot;&nbsp;<br>&nbsp;<br>the &quot;slot time&quot; is the worst case time interval that a node must wait to reliably know that a collision has not occurred&#46; the slot time is twice the propagation time plus a small incremental safety margin&#46;&nbsp;<br>&nbsp;<br>CSMA/CD specifies a total medium distance of 2500 meters for each CSMA/CD sub&#45;network (or segment)&#46; at 10Mbps transmission speed, by the time the 512th bit is transmitted, the first bit would have traveled 2500 meters&#46; thus, any frame that does not contain 512 bits is padded with additional bits to ensure that the frame is at least 512 bits&#46; the extra bits are placed in the pad field&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;signal regeneration&nbsp;<br>##&nbsp;<br>&nbsp;<br>recall CSMA/CD specifies a maximum segment length of 2500 meters&#46; the standard also requires any transmission to be regenerated over 500 meters&#46; repeaters are added every 500 meters to ensure the signal strength up to the maximum 2500 meters&#46;&nbsp;<br>&nbsp;<br>an CSMA/CD Segment is one physical sub&#45;network&#46; i&#46;e&#46; all the nodes on the segment hear the transmissions of all the other nodes on the segment and must contend for access to the medium&#46; segments are managed at MAC layer, therefore repeaters, which function at the physical and MAC layer for frame generation only, do not create new segments or sub&#45;networks; they simply extend them&#46; to create new segments or split existing ones, you need a node that operates L2 or above&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;ethernet&nbsp;<br>##&nbsp;<br>&nbsp;<br>originally invented by Xerox as LAN specification, later adopted by IEEE 802&#46;3&nbsp;<br>&nbsp;<br>xerox original ethernet goals&#58;&nbsp;<br>&#45; simplicity&nbsp;<br>&#45; low cost&nbsp;<br>&#45; compatibility (at L2 layer)&nbsp;<br>&#45; address flexibility (allow for single/group/broadcast addr capability)&nbsp;<br>&#45; high speed (10Mbps)&nbsp;<br>&#45; low delay (of frame transmission, at network level, as well as protocol overhead)&nbsp;<br>&#45; maintainability&nbsp;<br>&#45; layered architecture (distinction of L1 & L2)&nbsp;<br>&nbsp;<br>[ethernet implementation]&nbsp;<br>&#45; multi&#45;access, packet&#45;switched network using a passive broadcast medium with no central or distributed control&#46; It has error detection but no error correction&#46; A frame check sequence CRC value is used to identify corrupt frames but no retransmit request is generated&#46;&nbsp;<br>&#45; ethernet frames are broadcast across the entire network rather than regenerate at each station like a token ring&#46; Therefore the signal can weaken and become unintelligible if it travels over 500 meters&#46;&nbsp;<br>&#45; repeaters are used to regenerate the signal when it must travel more than 500 meters&#46; The standard specifies max distance 2500 meters, i&#46;e&#46; you need at least 5 repeaters&#46;&nbsp;<br>&#45; repeaters will regenerate the signals received on both sides connected to it&#46;&nbsp;<br>&#45; hubs can provide the same segment extensibility as repeaters by providing &quot;multi&#45;port&quot; repeating capability&#46; Instead of having an extensively elongated Ethernet segment throughout the facility interconnected with repeaters, Smaller sections of the medium can be extended from a central hub&#46;&nbsp;<br>&nbsp;<br>[frame reception process]&nbsp;<br>&#45; incoming signal detected&nbsp;<br>&#45; set carrier sense on (stops the node from initiating its own transmission and passes the carrier signal to the collision detection device)&nbsp;<br>&#45; obtain bit synchronization (align signal detection device with the beginning of each bit transmission)&nbsp;<br>&#45; wait for start frame delimiter&nbsp;<br>&#45; begin frame reception (disregard all previously received bits and store remaining bits in NIC buffer)&nbsp;<br>&#45; perform FCS&nbsp;<br>&#45; discard frame if invalid and return to Receive Ready state&nbsp;<br>&#45; if valid, check destination address&#46; Pass to LLC if address is recognized&#46; Clear buffer and discard frame if not recognized&#46;&nbsp;<br>&nbsp;<br>NOTE&#58; if a collision is detected at any point during the reception process, the device immediately stops processing the frame and initiates the collision recovery process&#46;&nbsp;<br>&nbsp;<br>[collision recovery]&nbsp;<br>&#45; the probability of collisions in random access method is relatively high due to the fact that two devices at the far extremes of the topology could complete their transmission initialization process at the same time and each begins transmitting before the others signal is detected&#46; When a collision occurs, every device on the network (every device hears all transmissions including collisions) initiates its collision back&#45;off process&#46; Each device randomly selects the number of slot times that it waits before initiating (or re&#45;initiating) a transmission&#46; If a collision occurs again, the random number range slot times to wait is increased thereby decreasing the probability of another collision&#46;&nbsp;<br>&nbsp;<br>this algorithm is called &quot;binary exponential back&#45;off&quot;&#46; It is designed to dynamically adapt to increases in the number of stations attempting to transmit&#46;&nbsp;<br>&nbsp;<br>if 16 consecutive collisions are detected, all frames waiting to be sent at all stations are rejected (NACK returned as response to the SDU) and all NIC devices return to their idle state (waiting for frame from higher level or carrier sense signal detected)&nbsp;<br>&nbsp;<br>collision was prolific in the early ethernet networks&#46; but less so today, as ethernet switch device improved&#46; (more on this later)&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;100base&#45;t &nbsp;(fast ethernet &#45; 100Mbps)&nbsp;<br>###&nbsp;<br>&nbsp;<br>ethernet has enjoyed tremendous success&#46; While cost and simplicity were key drivers in its design and initial acceptance by the market, it was continuous performance improvements in the technology that has fueled its growth to dominance&#46; While technology enhancements in segmentation and switching significantly improved the robustness, scalability, and performance of Ethernet, it was recognized that a gain in transmission rate would geometrically leverage all the improvements that were achieved at 10Mbps&#46;&nbsp;<br>&nbsp;<br>the objective of the Fast Ethernet technology was to remain as compatible with 10BaseT as possible&#46; This was accomplished by keeping all the functionality identical with the exception of the bit generation process&#46; Advances in signal detection circuitry along with the lower attenuation characteristics of Cat5 twisted pair cabling allowed bit generation using a lower current&#46; Using a lower current means the voltage transition of the signal takes less time&#46; Less time means more bits can be generated in the same amount of time&#46;&nbsp;<br>&nbsp;<br>[implementation]&nbsp;<br>&#45; Fast Ethernet reduced the bit time to one&#45;tenth the bit time of 10base&#45;t Ethernet&#46; This allowed ten bits to be generated in the time it takes 10base to generate just 1 bit resulting in a tenfold increase in speed&#46;&nbsp;<br>&#45; since all the other characteristics and functions (carrier sense, collision detection, etc) of the 10base MAC are the same (bit transmission is a physical layer function not a MAC layer one) both 10base and Fast Ethernet frames can be generated on the same shared segment&#46; Devices that are only 10base will recognize &quot;noise&quot; on the network through their carrier sense mechanisms but will not be able to recognize the signal&#46; It is however sufficient enough noise for these stations to recognize that the network is busy and will not attempt a transmission&#46;&nbsp;<br>&#45; Fast Ethernet devices also recognize and support 10base transmissions (cards are identified as &quot;10/100 Ethernet&quot;)&nbsp;<br>&nbsp;<br>[benefits]&nbsp;<br>&#45; Fast Ethernet allowed for a gradual transition to 100Mbps speed rather than requiring a wholesale swap out of all devices on the network&#46; Some or all of the hubs and servers in the network, along with high bandwidth requirement workstations, could be upgraded to 10/100 devices while other devices requiring less bandwidth can continue at the older 10Mbps speed&#46;&nbsp;<br>&#45; that made Fast Ethernet the most popular for LAN requirements&#46; Its popularity has also resulted in significant cost reduction in Fast Ethernet components to the point where the incremental cost over 10base became insignificant&#46;&nbsp;<br>&#45; another advantage is that advancements that were made in 10Mbps intermediary devices were applied at the 100Mbps speed&#46; Hence 10/100 EtherSwitch hubs provide a tenfold increase in bandwidth management and utilization over 10Mbps EtherSwitches&#46; 100Mbps port switched Fast Ethernet also offered an alternative to (the more expensive) FDDI as a 100MBPS backbone or back&#45;end solution, driving the adoption of Fast Ethernet deployments for most core networks, until the advent of Gigabit Ethernet&#46;&nbsp;<br>&#45; 10Base has effectively disappeared in networks over the years, and 100Base is now fading, especially in new deployments, as Gigabit Ethernet has become cheap&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;gigabit ethernet&nbsp;<br>###&nbsp;<br>&nbsp;<br>Gigabit Ethernet represents the next wave in tenfold increase Ethernet speed&#46; Unlike Fast Ethernet however its intended purpose was mostly for backbone and backend usage, but because the costs have reduced significantly, most new NIC cards provided in laptops and desktops are now Gigabit, and even home networks are increasingly becoming Gigabit&#46;&nbsp;<br>&nbsp;<br>Earlier the core networks for businesses would often be FDDI if there was a need for high reliability and fault tolerance&#46; The cost, however, has encouraged the deployment of Fast Ethernet and now Gigabit Ethernet in the core network&#46; Advances in redundant network configurations and reliability of devices has mitigated the need for high&#45;fault&#45;tolerant systems in most core networks&#46;&nbsp;<br>&nbsp;<br>Since Gigabit Ethernet significantly leverages on Ethernet, companies are able to leverage their existing knowledge base to manage and maintain Gigabit networks&#46; The modern network interface cards and devices that support Gigabit Ethernet also are compatible and interoperate with the Fast Ethernet equipment seamlessly, providing a simple migration path for IT managers and administrators&#46;&nbsp;<br>&nbsp;<br>Recent advances and reduction in costs have introduced 10Gigabit Ethernet into the field as well&#46; This is typically fiber&#45;based and used for backbone connections and Gigabit switch to Gigabit switch connections, allowing for higher bandwidth between switches as more and more we see core switches using VLANs to overlay multiple distinct logical networks over a common core switch network&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [gigabit ethernet protocol architecture]&nbsp;<br>#&nbsp;<br>In order to accelerate speeds from 100 Mbps Fast Ethernet up to 1 Gbps, several changes need to be made to the physical interface&#46; It was decided that Gigabit Ethernet would look identical to Ethernet from the data link layer upward&#46; The challenges involved in accelerating to 1 Gbps have been resolved by merging two technologies together&#58;&nbsp;<br>&nbsp;<br>&#45; IEEE 802&#46;3 Ethernet&nbsp;<br>&#45; ANSI X3T11 FiberChannel&nbsp;<br>&nbsp;<br>Leveraging these two technologies means that the standard can take advantage of the existing high&#45;speed physical interface technology of FibreChannel while maintaining the IEEE 802&#46;3 Ethernet frame format, backward compatibility for installed media, and use of full&#45; or half&#45;duplex carrier sense multiple access collision detection (CSMA/CD)&#46; This scenario helps minimize the technology complexity, resulting in a stable technology that can be quickly developed&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Gigabit Ethernet Interface Carrier]&nbsp;<br>#&nbsp;<br>The Gigabit interface converter (GBIC) allows network managers to configure each gigabit port on a port&#45;by&#45;port basis for short&#45;wave (SX), long&#45;wave (LX), long&#45;haul (LH), and copper physical interfaces (CX)&#46; LH GBICs extended the single&#45;mode fiber distance from the standard 5 km to 10 km&#46; As stated earlier, Gigabit Ethernet initially supports three key media&#58; short&#45;wave laser, long&#45;wave laser, and short copper&#46; In addition, fiber&#45;optic cable comes in three types&#58; multimode (62&#46;5 um), multimode (50 um), and single mode&#46; An example of an GBIC is shown in diagram 4&#46;&nbsp;<br>&nbsp;<br>The FiberChannel physical medium dependent (PMD) specification currently allows for 1&#46;062&#45;gigabaud signaling in full duplex&#46; Gigabit Ethernet increases this signaling rate to 1&#46;25 Gbps&#46; The 8B/10B encoding (to be discussed later) allows a data transmission rate of 1000 Mbps&#46; The current connector type for FibreChannel, and therefore for Gigabit Ethernet, is the SC connector for both single&#45;mode and multimode fiber&#46; The Gigabit Ethernet specification calls for media support for multimode fiber&#45;optic cable, single&#45;mode fiber&#45;optic cable, and a special balanced shielded 150&#45;ohm copper cable&#46;&nbsp;<br>&nbsp;<br>In contrast, Gigabit Ethernet switches without GBICs either cannot support other lasers or need to be ordered customized to the laser types required&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Long&#45;Wave and Short&#45;Wave Lasers over Fiber&#45;Optic Media]&nbsp;<br>#&nbsp;<br>Two laser standards are supported over fiber&#58; 1000BaseSX (short&#45;wave laser) and 1000BaseLX (long&#45;wave laser)&#46; Short&#45; and long&#45;wave lasers are supported over multimode fiber&#46; Two types of multimode fiber are available&#58; 62&#46;5 and 50 micron&#45;diameter fibers&#46; Long&#45;wave lasers are used for single&#45;mode fiber, because this fiber is optimized for long&#45;wave laser transmission&#46; There is no support for short&#45;wave laser over single&#45;mode fiber&#46;&nbsp;<br>&nbsp;<br>The key differences between the use of long&#45; and short&#45;wave laser technologies are cost and distance&#46; Short&#45;wave lasers cost less, but they transverse a shorter distance&#46; In contrast, long&#45;wave lasers are more expensive but they transverse longer distances&#46;&nbsp;<br>&nbsp;<br>Single&#45;mode fiber has been traditionally used in the networking cable plants to achieve long distance&#46; In Ethernet, for example, single&#45;mode cable ranges reach up to 10 km&#46; Single&#45;mode fiber, using a 9&#45;micron core and 1300&#45;nanometer laser, demonstrate the highest&#45;distance technology&#46; The small core and lower&#45;energy laser elongate the wavelength of the laser and allow it to transverse greater distances&#46; This setup enables single&#45;mode fiber to reach the greatest distances of all media with the least reduction in noise&#46;&nbsp;<br>&nbsp;<br>Gigabit Ethernet is supported over two types of multimode fiber&#58; 62&#46;5 and 50 micron&#45;diameter fibers&#46; The 62&#46;5&#45;micron fiber is typically seen in vertical campus and building cable plants and has been used for Ethernet, Fast Ethernet, and FDDI backbone traffic&#46; This type of fiber, however, has a lower modal bandwidth (the ability of the cable to transmit light), especially with short&#45;wave lasers&#46; In other words, short&#45;wave lasers over 62&#46;5&#45;micron fiber are able to transverse shorter distances than long&#45;wave lasers&#46; Relative to 62&#46;5&#45;micron fiber, the 50&#45;micron fiber has significantly better model bandwidth characteristics and is able to transverse longer distances with short wave lasers&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Gigabit Ethernet over Copper]&nbsp;<br>#&nbsp;<br>Gigabit Ethernet connections were originally designed to support copper connections using special balanced cables &#45; however, with advances in cable technology and designs, the Cat&#45;6 cables allow for fairly simple installations of Gigabit Ethernet using patch cables much as network adminstrators had used with the other Ethernet varieties&#46; Due to the more stringent requirements of Gigabit Ethernet, all of the wiring components must be rated to handle the higher speed or you will introduce issues with performance &#45; this includes not only the Cat&#45;6 cabling itself, but also the connectors used on the cable, and the connectors used on the network interfaces&#46;&nbsp;<br>&nbsp;<br>There are also now Cat&#45;6a (augmented) cables available that provide even better isolation and reduced crosstalk, allowing for longer distance runs between devices&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Serializer/Deserializer]&nbsp;<br>#&nbsp;<br>The physical media attachment (PMA) sublayer for Gigabit Ethernet is identical to the PMA for FibreChannel&#46; The serializer/deserializer is responsible for supporting multiple encoding schemes and allowing presentation of those encoding schemes to the upper layers&#46; Data entering the physical sublayer (PHY) will enter through the PMD and will need to support the encoding scheme appropriate to that media&#46; The encoding scheme for FiberChannel is 8B/10B, designed specifically for fiber&#45;optic cable transmission&#46; Gigabit Ethernet uses a similar encoding scheme&#46; The difference between FiberChannel and Gigabit Ethernet, however, is that FiberChannel utilizes 1&#46;062&#45;gigabaud signaling whereas Gigabit Ethernet utilizes 1&#46;25&#45;gigabaud signaling&#46; A different encoding scheme is required for transmission over UTP&#46; This encoding is performed by the UTP or 1000BaseT PHY&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [8B/10B Encoding]&nbsp;<br>#&nbsp;<br>&nbsp;<br>The FiberChannel FC&#45;1 layer describes the synchronization and the 8B/10B encoding scheme&#46; FC&#45;1 defines the transmission protocol, including serial encoding and decoding to and from the physical layer, special characters, and error control&#46; Gigabit Ethernet utilizes the same encoding/decoding as specified in the FC&#45;1 layer of FiberChannel&#46; The scheme utilized is the 8B/10B encoding&#46; This scheme is similar to the 4B/5B encoding used in FDDI; however, 4B/5B encoding was rejected for FibreChannel because of its lack of DC balance&#46; The lack of DC balance can potentially result in data&#45;dependent heating of lasers because a transmitter sends more 1s than 0s, resulting in higher error rates&#46;&nbsp;<br>&nbsp;<br>Encoding data transmitted at high speeds provides some advantages&#58;&nbsp;<br>&nbsp;<br>Encoding limits the effective transmission characteristics, such as ratio of 1s to 0s, on the error rate&nbsp;<br>Bit&#45;level clock recovery of the receiver can be greatly improved by using data encoding&nbsp;<br>Encoding increases the possibility that the receiving station can detect and correct transmission or reception errors&nbsp;<br>Encoding can help distinguish data bits from control bits&nbsp;<br>All these features have been incorporated into the FibreChannel FC&#45;1 specification&#46;&nbsp;<br>&nbsp;<br>In Gigabit Ethernet, the FC&#45;1 layer takes decoded data from the FC&#45;2 layer 8 bits at a time from the reconciliation sublayer (RS), which &quot;bridges&quot; the FibreChannel physical interface to the IEEE 802&#46;3 Ethernet upper layers&#46; Encoding takes place via an 8&#45; to 10&#45;bit character mapping&#46; Decoded data comprises 8 bits with a control variable&#46; This information is, in turn, encoded into a 10&#45;bit transmission character&#46;&nbsp;<br>&nbsp;<br>Encoding is accomplished by providing each transmission character with a name, denoted as Zxx&#46;y&#46; Z is the control variable that can have two values&#58; D for Data and K for Special Character&#46; The xx designation is the decimal value of the binary number composed of a subset of the decoded bits&#46; The y designation is the decimal value of the binary number of remaining decoded bits&#46; This scenario implies that there are 256 possibilities for Data (D designation) and 256 possibilities for Special Characters (K designation)&#46; However, only 12 Kxx&#46;y values are valid transmission characters in FibreChannel&#46; When data is received, the transmission character is decoded into one of the 256 8&#45;bit combinations&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IEEE 802&#46;11 &nbsp;(aka Wireless ethernet LANs)&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45; recall &quot;wired&quot; ethernet (802&#46;3) uses CSMA/CD&nbsp;<br>&#45; 802&#46;11 uses CSMA/CA &nbsp;(collision avoidance, instead of collision detection) because in wireless LAN, the medium is air, so there is no real topology, and hard to control traffic the same way as wired network&#46; CA in this case refers to a mechanism where all devices listen to the channel for a predetermined duration of time before transmitting, to avoid collision&#46; but once the number of devices increase, collision still occurs&#46;&nbsp;<br>&nbsp;<br>802&#46;11 &nbsp;&nbsp;&nbsp;# original version, only max 1~2MBps, now obsolete, and been replaced by the subsequent derivatives&nbsp;<br>802&#46;11a &nbsp;&nbsp;# 5GHz, max 54MBps, uses OFDM (orthogonal frequency division multiplexing) modulation&nbsp;<br>802&#46;11b &nbsp;&nbsp;# 2&#46;4GHz, max 11MBps, uses DSSS (direct sequence spread spectrum) modulation&nbsp;<br>802&#46;11g &nbsp;&nbsp;# interoperable with 802&#46;11b (2&#46;4GHz) but uses OFDM (theoretical max 54MBps),&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# but to implement this backward compatible with 802&#46;11b, the actual thruput is only approx 22MBps&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# note&#58; this means, 11a & 11b can coexist, but 11b & 11g will interfere, bandwidth wise&nbsp;<br>802&#46;11n &nbsp;&nbsp;# MIMO (multiple in multiple out) actually uses multiple transmission physical devices (antennas, transmitters, receivers) to use multi channels&#46; uses both 2&#46;4GHz & 5GHz&#46; thruput increases, but can interfere with 11&#46;a/b/g&nbsp;<br>&nbsp;<br>&nbsp;<br>&quot;channels&quot; &#45; 14 channels in 2&#46;4GHz (used by b/g/n)&#46; but there can be local/country regulation&#46; e&#46;g&#46; in the US, you can only use channel 1~11&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; adjacent channels still intefere, so it is common to deplay using 1,6,11 for adjacent devices&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>#################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;Token Ring &nbsp;& &nbsp;FDDI &nbsp;&nbsp;&nbsp;###&nbsp;<br>#################################&nbsp;<br>&nbsp;<br>both are MAC layer LAN technology, just like ethernet&#46; but recall ethernet is bus topology with random access (CSMA/CD) method, while TR & FDDI are distributed access (token&#45;based) method with ring topology&#46;&nbsp;<br>&nbsp;<br>note&#58; both TR and FDDI are obsolete&#46; but they inspired SONET protocol which is actively used for high&#45;availability networks for the ring topology and fault tolerance (at least one of the specific modes)&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Token Ring&nbsp;<br>###&nbsp;<br>&nbsp;<br>https&#58;//en&#46;wikipedia&#46;org/wiki/Token_ring&nbsp;<br>&nbsp;<br>originally implemented by IBM, then later IEEE 802&#46;5&nbsp;<br>at the time, it was considered distributed media access control was the way to go, more deterministic and reliable than ethernet&#039;s random access control method, but ethernet won prominence as a result of improved switching technology & data rates&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR signaling&nbsp;<br>##&nbsp;<br>&nbsp;<br>Since media access control needed to be distributed to all devices, it was recognized that a fair amount of overhead traffic associated with maintenance and control of the network would be generated&#46; One way to minimize this overhead was to allow for the generation of two additional signals that could be interpreted as something other than a Zero or a One&#46; Using these additional signals, a distinct control signal could be generated using significantly fewer bits than would be necessary if they were generated using the same two bits used for everything else including data&#46;&nbsp;<br>&nbsp;<br>Token Ring takes advantage of &quot;Differential Manchester Encoding&quot; to allow for transmission of two additional control bits for a total of 4 distinct transmission values&#46; The four bit values are 0(zero),1(one),J, and K&#46;&nbsp;<br>&nbsp;<br>==&gt; google more for details&#46;&nbsp;<br>&nbsp;<br>A &quot;J&quot; bit is when the same polarity of the preceding bit is generated for the entire bit time&#46;&nbsp;<br>A &quot;K&quot; bit is when the opposite polarity of the preceding bit is generated for the entire bit time&#46;&nbsp;<br>&nbsp;<br>This is simply one type of encoding &#45; it was the one chosen for Token Ring, but there are some common things about encoding choice that can help us understand why encodings are chosen in different protocols &#45; this same logic applies to the current protocols in use today&#58;&nbsp;<br>&nbsp;<br>&#45; Presence/absence of DC values&#46; Different encoding schemes result in either no DC component, or generate a varying DC component, or further &#45; some can be layered on top of a DC component without issue&#46; The reasons for this are important &#45; DC values can be added to signals that do not introduce a net DC change &#45; this is useful for providing power along with a data signal&#46; This can also be important for the situations where a DC value would be harmful for the application&#46;&nbsp;<br>&nbsp;<br>&#45; Encoding more than one &quot;bit&quot; per clock cycle&#46; The most simple encodings result in simply one bit per &quot;data unit&quot; or &quot;clock unit&quot;&#46; This means that if you need to send control data along with application data, you would need to serialize it, provide preambles/id sequences to separate data and control, etc&#46; Encodings like DME above allow for the data itself (1/0) but also allow control signals J and K to be applied in a single clock cycle &#45; allowing that to be interleaved with data efficiently&#46; Whenever these features are added, you are trading off something, whether that be clock speed, bandwidth, complexity, etc &#45; and all of this needs to be weighed against the application and the overhead needed by a particular protocol&#46; Some protocols need a lot more control information due to complexities in the transmission &#45; these are the kinds of aspects that drive the ultimate decisions&#46;&nbsp;<br>&nbsp;<br>&#45; Reliability&#46; Some encoding schemes trade off speed or bandwidth in exchange for susceptibility to noise and signal strength&#46; The key with different encodings is typically the application &#45; how long are the distances that are to be supported? What are the levels of noise or interference that might be present on the transmission lines? These kind of questions drive the decision for what kind of encoding would be present on any given technology&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR topology&nbsp;<br>##&nbsp;<br>&nbsp;<br>Token Ring is not a broadcast medium&#46; It is a series of point to point links in a closed loop circle&#46;&nbsp;<br>&nbsp;<br>The ring has to have sufficient enough delay (be long enough) to contain a complete Token capable of circulating the ring when all stations are idle&#46; Each station on the ring adds a 1&#45;bit delay to the ring&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR interface&nbsp;<br>##&nbsp;<br>&nbsp;<br>Each Token Ring NIC has a switch that remains in the closed position (connecting the inbound and outbound connections) when powered off&#46; When the NIC is powered on the switch opens allowing incoming bit to be passed to the internal NIC buffer&#46; Each bit passed to the buffer is subsequently regenerated on the outbound connection by the NIC&#46; This is where the 1 bit delay is introduced&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;token format&nbsp;<br>##&nbsp;<br>&nbsp;<br>The Token is a 3 byte frame&#58;&nbsp;<br>&nbsp;<br>Byte 1 = Starting Delimiter (SD)&nbsp;<br>Byte 2 = Access Control (AC)&nbsp;<br>Byte 3 = Ending Delimiter(ED)&nbsp;<br>&nbsp;<br>SD Value = JK0JK000&nbsp;<br>ED Value = JK1JK1IE&nbsp;<br>&nbsp;<br>The ED &quot;I&quot; bit (Second bit from right) is the &quot;Intermediate&quot; bit&#46; This bit is set to 1 for first and intermediate frames transmitted and set to 0 for last frame (always a zero when it is a token)&#46;&nbsp;<br>&nbsp;<br>The ED &quot;E&quot; bit (first bit from the right) is the &quot;Error&quot; bit&#46; This bit is set to 0 by the station sending the frame&#46; It is changed to a 1 by any subsequent station that detects an error in the frame&#46; The intended receiving station (destination address is the station&#039;s address) will reject any frame with the E bit set to 1&#46; The sending station will know an error occurred when the frame returns (again, always set to zero when it is a token)&#46;&nbsp;<br>&nbsp;<br>It is the responsibility of the station generating a frame to remove it from the ring when it returns&#46; The receiving station processes the frame but does not remove it&#46; It regenerates the frame on the ring to be returned to the sending station&#46;&nbsp;<br>&nbsp;<br>AC Field = PPPTMRRR&nbsp;<br>PPP = 3 bit priority designation of the token&#46; Valid priorities are 0,2,4,or 6&#46;&nbsp;<br>T = Token Bit&#46; Identifies a token if set to 0; a frame if set to 1&#46;&nbsp;<br>M = Monitor bit&#46; Set to zero by sending station; changed to 1 by monitoring station&#46;&nbsp;<br>RRR = 3 bit priority request&#46; Used by a station to request token of a lower priority&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR frame format&nbsp;<br>##&nbsp;<br>&nbsp;<br>see http&#58;//docwiki&#46;cisco&#46;com/wiki/Token_Ring/IEEE_802&#46;5#Frame_Format&nbsp;<br>&nbsp;<br>&#45; start delimeter&nbsp;<br>&#45; acess control&nbsp;<br>&#45; Frame control&nbsp;<br>&#45; dest addr&nbsp;<br>&#45; src addr&nbsp;<br>&#45; data&nbsp;<br>&#45; FCS (frame check sequence)&nbsp;<br>&#45; end delimieter&nbsp;<br>&#45; frame status&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR optional priority control mechanism&nbsp;<br>##&nbsp;<br>&nbsp;<br>Token Ring uses the &quot;PPP&quot; and &quot;RRR&quot; bits in Access Control (AC) field to set and adjust frame priorities allowed to be transmitted&#46; When a station receives a token it can only transmit frames that are the same or higher priority than the PPP value in the token&#46; If that station does not have any frame &gt; PPP but does have frames &gt; RRR the station can change the RRR on the token to a higher level&#46;&nbsp;<br>&nbsp;<br>Each Token Ring NIC maintains two sets of value registers at the MAC level to manage priorities&#46;&nbsp;<br>&nbsp;<br>&#45; Value Set 1&nbsp;<br>&#45;&#45; Pm Highest priority of frame at the station waiting to be transmitted&nbsp;<br>&#45;&#45; Pr Priority value of most recent repeated token or frame&nbsp;<br>&#45;&#45; Rr Reserve value of most recent repeated token or frame&nbsp;<br>&nbsp;<br>&#45; Value set 2&nbsp;<br>&#45;&#45; Sr Old ring service priority&nbsp;<br>&#45;&#45; Sx New ring service priority&nbsp;<br>&nbsp;<br>The old ring service priority is kept by a station whenever it changes the ring priority&#46; After it has been serviced it changes the priority value of the ring back to the old ring priority level, unless the requested priority value of the most recent repeated frame or token (Rr) is higher than the old ring service priority (Sr), in which case the priority of the new token will be set to Rr&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR frame transmission process&nbsp;<br>##&nbsp;<br>&nbsp;<br>&#45; Receive Token&nbsp;<br>&#45; Stop clock on TRT timer&nbsp;<br>&#45; Store Token PPP and RRR in Pr and Rr registers&#46;&nbsp;<br>&#45; Compare TRT to TTRT&#46;&nbsp;<br>&#45;&#45; If TRT &lt; TTRT&#58;&nbsp;<br>&#45;&#45;&#45; Compare Pm register (highest priority of frames awaiting transmission) to Token PPP&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; If Pm &gt; PPP&nbsp;<br>&#45;&#45;&#45; transmit frame in ascending priority order until each priority timer expires, TTRT expires or, all frames are processed whichever comes first&#46;&nbsp;<br>&#45;&#45;&#45; Go to regenerate token&nbsp;<br>&nbsp;<br>&#45;&#45; If TTRT or priority timer expires&nbsp;<br>&#45;&#45;&#45; continue to transmit all priority 6 frames until HPTHT (high priority token hold timer) expires&nbsp;<br>&#45;&#45;&#45; regenerate token&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; If TRT &gt; TTRT&#58;&nbsp;<br>&#45;&#45;&#45; transmit priority 6 frames until HPTHT (high priority token hold timer) expires&nbsp;<br>&#45;&#45;&#45; regenerate token&#46;&nbsp;<br>&nbsp;<br>Re&#45;generate Token&#58;&nbsp;<br>&nbsp;<br>&#45; If Pm &lt; PPP compare Pm to Token RRR&nbsp;<br>&#45;&#45; If Token RRR &gt; Pm release token with same RRR&nbsp;<br>&#45;&#45; If Token RRR &lt; Pm, Store token RRR in Sr&#46; Change RRR to Pm, Store Pm in Sx&#46;&nbsp;<br>&#45;&#45; Release Token&nbsp;<br>&nbsp;<br>&#45; If Pm &gt; PPP (HPTHT expired)&nbsp;<br>&#45;&#45; set RRR to PPP of current Token&nbsp;<br>&#45;&#45; release token&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR maintenance&nbsp;<br>##&nbsp;<br>&nbsp;<br>[Add Station]&nbsp;<br>&nbsp;<br>Since Token Ring is a physical ring consisting of a series of point to point connections, the add station process is much different than the one required for Token Bus&#46; Once a station is activated (Switch on the NIC is Opened) it automatically begins receiving and transmitting the bits on the ring&#46; The station does however have to validate that a duplicate address (in the case of local addressing) does not exist&#46;&nbsp;<br>&nbsp;<br>[Ring Monitoring]&nbsp;<br>&nbsp;<br>Two error conditions requiring resolution can occur on the ring&#58;&nbsp;<br>&nbsp;<br>&#45; Lost token&nbsp;<br>&#45; Persistently busy token or frame&nbsp;<br>&nbsp;<br>A device functioning as the &quot;Active Monitor&quot; takes on the responsibility for resolving these errors&#46;&nbsp;<br>&nbsp;<br>Usually the first station to come on line functions as the active monitor&#46; All other stations function as &quot;Passive Monitors&quot; determining a replacement if the current active monitor is removed&#46;&nbsp;<br>&nbsp;<br>The active monitor periodically generates an &quot;Active Monitor Present&quot; control frame to inform the other stations that it is still on the ring&#46;&nbsp;<br>&nbsp;<br>The role of the active monitor is to&#58;&nbsp;<br>&nbsp;<br>&#45; generate new or replacement tokens&nbsp;<br>&#45; remove persistent tokens or frames&nbsp;<br>&nbsp;<br>The active monitor constantly monitors the ring&#46; If no token or frame is detected within the Token Rotation Window a new token is generated&#46;&nbsp;<br>&nbsp;<br>If a corrupt token circulates the ring such that no station recognizes the DU as a token (persistent token) the active monitor will replace it with a valid token&#46;&nbsp;<br>&nbsp;<br>When a data frame (LLC Frame) is generated by a sending station, it sets the monitor bit in the AC field to 0&#46; When the frame is regenerate by the Active Monitor it changes the monitor bit to 1&#46; If frame is subsequently received again by the Active Monitor with the M bit changed to 1 it knows that it has already seen the frame The implication is that the sending station is no longer available to remove it from the ring&#46; At this time the frame is removed by the Active Monitor and a new token is generated in its place&#46;&nbsp;<br>&nbsp;<br>[Token to frame transition]&nbsp;<br>&nbsp;<br>Reviewing the format of the token frame and data frame presented earlier, you will notice that they are identical up to the AC field (which includes the T and M bits)&#46; Thus the regenerated bits up to this point are valid for a token as well as frame&#46; Since frames as well as tokens are regenerated onto the ring every bit up the the M bit in the AC field is identical and can be regenerated on the ring&#46;&nbsp;<br>&nbsp;<br>When the T bit is received, its value triggers either the token or frame handling process at the station&#46; If it is labeled a token the station checks to see if it has any frames to send&#46;&#46; If yes, the frame transmission process described above is initiated&#46; If the station does not wish to transmit it continues to place the remaining bits of the token on the ring allowing it to pass to the next station&#46;&nbsp;<br>&nbsp;<br>If the T bit identifies the transmission as a frame the frame reception process is initiated&#46; The entire frame is copied into buffer memory&#46;&nbsp;<br>&nbsp;<br>If the destination address of the frame is the station&#039;s address&#58;&nbsp;<br>&nbsp;<br>&#45; CRC is checked&nbsp;<br>&#45; If invalid&#58;&nbsp;<br>&#45;&#45; the &quot;E&quot; bit of the Ending Delimiter field is set to 1 (denoting an error detected)&nbsp;<br>&#45;&#45; the &quot;A&quot; bit of the Frame Status field is changed to 1 indicating the address was recognized&nbsp;<br>&#45;&#45; the frame is re&#45;generated on the ring to be returned to the sending station&#46;&nbsp;<br>&#45; If the CRC is valid&nbsp;<br>&#45;&#45; the LLC portion of the frame is passed to the higher layer&#46;&nbsp;<br>&#45;&#45; the entire frame is regenerated on the ring with the &quot;A&quot; and &quot;C&quot; bits changed to 1&#039;s&#46;&nbsp;<br>&nbsp;<br>If the destination address is not recognized by the station the source address is compared to the stations address&#46;&nbsp;<br>&nbsp;<br>If the source address is recognized and the stations transmit timers have not expired&#58;&nbsp;<br>&#45; Determine next frame to be transmitted subject to priority and &quot;A and C&quot; recognition policies&nbsp;<br>&#45; Generate a new frame onto the ring&nbsp;<br>&nbsp;<br>If Address is recognized and transmit timers are expired&#58;&nbsp;<br>&#45; retain or delete frame from buffer based on &quot;A and C&quot; bit recognition policies&nbsp;<br>&#45; regenerate token (same regenerate token process as described in transmission process above)&nbsp;<br>&nbsp;<br>If the source address is not the stations address&#58;&nbsp;<br>&#45; Perform the CRC check on the frame&nbsp;<br>&#45; regenerate the frame on the ring with the &quot;E&quot; &quot;bit set to 1 if the CRC was invalid&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># Beaconing&nbsp;<br>#&nbsp;<br>&nbsp;<br>Beaconing is a process used to detect and isolate breaks or faults in the ring&#46;&nbsp;<br>&nbsp;<br>If a break in the ring occurs no token or frame will circulate and all stations timers will expire&#46; Each station will begin to transmit a special frame called a beacon&#46; The station places its address in the beacon frame&#46; Any station receiving a beacon from another station will stop transmitting its own beacon and repeat the beacon frame (and address) from the upstream system&#46; Eventually the station immediately following the break or fault in the network will be the only beacon message being transmitted (since it never receives a beacon from n upstream system&#46; A LAN analyzer placed anywhere on the ring will identify the address in the beacon frame of the station immediately downstream from the fault&#46; The engineer will know where to investigate the failure on the ring&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TR summary&nbsp;<br>##&nbsp;<br>&nbsp;<br>Token Ring is a technology based on distributed medium access control&#46; This distributed management requires additional functionality and processing power to be incorporated on the NIC&#46; This added complexity of the distributed control mechanism along with the additional processing and storage requirements of the priority mechanism adds significant cost to a Token Ring NIC&#46;&nbsp;<br>&nbsp;<br>On the plus side, the elimination of medium contention and collisions results in the ability to get higher throughput (better usage of available bandwidth) Hence token ring LANs can perform effectively closer to their capacity than shared mediums where contention occurs&#46;&nbsp;<br>&nbsp;<br>So if it is more performant than a shared medium, like Ethernet, why is Ethernet so much more common? The answer is simple &#45; the costs and benefits, coupled with the advances in switching technology for Ethernet and proper network design make Ethernet provide more than sufficient performance and much less cost and complexity of deployment&#46; As a result, Token Ring has all but disappeared from the landscape&#46; It does, however, provide us with a foundation for how high&#45;availability, fault&#45;tolerance networks can be designed and implemented&#46; This is extended by looking at how FDDI took the Token Ring concepts, and made them more effective for a backbone network to add some of these same features&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>####&nbsp;<br>#### &nbsp;FDDI &nbsp;(fiber distributed data interface)&nbsp;<br>####&nbsp;<br>&nbsp;<br>FDDI is a technology that was designed to meet the requirements of high performance LANs and high&#45;speed connections between LANs&#46; Although we still see a number of installations of FDDI in the field, much of this has been replaced by newer technologies, primarily Ethernet and now Gigabit Ethernet&#46; It does provide a good basis for aspects of the technologies, especially aligning with many of the telecommunications technologies that are still actively and widely used, like the ring behavior for SONET telco rings&#46;&nbsp;<br>&nbsp;<br>Unlike IEEE 802&#46;3 and 802&#46;5 which were standards heavily based on existing Ethernet and Token Ring technologies, FDDI was created as a standard before implementation by vendors occurred&#46;&nbsp;<br>&nbsp;<br>FDDI also had the benefit of knowing the shortcomings and undesirable attributes of the existing 802&#46;X LAN technologies and was able to adopt and improve upon the good features of these technologies and eliminate or minimize the impact of the bad features&#46;&nbsp;<br>&nbsp;<br>FDDI was developed by the Accredited Standards Committee (ASC) of the American National Standards Institute (ANSI)&#46; ANSI assigned the project (labeled X3T9&#46;5) to this committee rather than the 802 committee because of its prior work and experience with high&#45;speed I/O interface standards&#46;&nbsp;<br>&nbsp;<br>FDDI was designed to support three types of networks&#58;&nbsp;<br>&nbsp;(1) As a backend &quot;System to System&quot; or &quot;System to Sub&#45;System&quot; interconnection network&#46;&nbsp;<br>&nbsp;(2) As a backbone to LANs&nbsp;<br>&nbsp;(3) As a high speed LAN&nbsp;<br>&nbsp;<br>FDDI played a dominant role in the backend and Backbone network space and a minimal role in the high speed LAN market space prior to extensive adoption of Ethernet due to switching advances&#46; FDDI provides a robust, fault tolerant mechanism for interconnecting back end systems like Disk Array subsystems and System Clusters&#46; It also has provided an excellent backbone mechanism for interconnection of lower speed LANs and &quot;glass housed&quot; server farms&#46;&nbsp;<br>&nbsp;<br>FDDI was very seldom cost justified as a high speed LAN solution therefore widespread implementation in this space never occurred&#46; The cost of rebuilding a fiber optic cabling plant to replace the copper infrastructure as well as the cost of FDDI componentry (costing 5 to 10 times the mount of existing 10base componentry) made FDDI&#039;s implementation at the desktop too expensive&#46;&nbsp;<br>&nbsp;<br>The development and proliferation of Fast Ethernet and more recently Gigabit Ethernet has for all practical purposes eliminated FDDI as an alternative in the 100MBPS/1000MBS LAN network environments&#46;&nbsp;<br>&nbsp;<br>To understand the evolution of the protocols that we see today, the design of FDDI does offer the benefit of proving an extremely robust, fault tolerant solution&#46; One of the key features incorporated into FDDI was the ability to detect and correct network faults&#46; Its dual ring token passing configuration was an improvement over Token Ring&#039;s single ring configuration&#46; Stations can switch to the secondary ring if the primary ring fails&#46; This attribute also allows for devices to be physically added or removed from the network without bringing the network down; a feature not present in 802&#46;5 Token Ring&#46;&nbsp;<br>&nbsp;<br>FDDI also included a priority mechanism like token ring but improved upon the Token Ring implementation by streamlining the priorities into high and normal priority frames providing synchronous or asynchronous bandwidth allocation on demand&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;FDDI architecture&nbsp;<br>##&nbsp;<br>&nbsp;<br>The IEEE 802&#46;2 LLC used in all other major LAN standards was adopted by FDDI as well&#46; The common LLC allows FDDI to easily serve as a backbone for other (802&#46;2 compatible) lower speed LANs&#46;&nbsp;<br>&nbsp;<br>The MAC is a distributed access control technology responsible for the standard MAC functions&#58;&nbsp;<br>&nbsp;<br>&#45; Frame formatting&nbsp;<br>&#45; Error Checking&nbsp;<br>&#45; Token Handling&nbsp;<br>&#45; Addressing&nbsp;<br>&nbsp;<br>The PHY layer handles the 4B/5B encoding and decoding of packet data into symbol streams for the wire&#46; It also handles clock synchronization on the FDDI ring by establishing the bit sampling time&#46;&nbsp;<br>&nbsp;<br>The PMD layer handles the NRZI baseband or MLT&#45;3 transmission between nodes on the physical media&#46; The PMD is the media dependent layer therefore the PMD standards include TP&#45;PMD for twisted&#45;pair copper wires and Fiber&#45;PMD for fiber optic cable&#46;&nbsp;<br>&nbsp;<br>TP&#45;PMD, an ANSI standard, replaced the proprietary (or &quot;prestandard&quot;) approaches previously used for running FDDI traffic over copper wires&#46; The TP&#45;PMD standard is based on an MLT&#45;3 encoding scheme; prestandard implementations used the less reliable (over copper) NRZ encoding scheme&#46; TP&#45;PMD interfaces are compliant with U&#46;S&#46; and international emission standards and provide reliable transmission on Cat 5 certified cabling over distances up to 100 meters&#46;&nbsp;<br>&nbsp;<br>With TP&#45;PMD in place, network managers had a standard means to implement FDDI over inexpensive UTP cable, cutting cabling costs by about a third compared with fiber optic cabling&#46; While this reduced the cabling costs it did not reduce the cost of the network interface cards&#46; Thus FDDI even over copper was still significantly more expensive than 100BaseT, leading to its demise&#46;&nbsp;<br>&nbsp;<br>SMT is an independent set of functions that handles the management of the FDDI ring&#46; Functions handled by SMT include neighbor identification, fault detection and ring reconfiguration (fault correction), insertion and de&#45;insertion from the ring, and traffic statistics monitoring&#46;&nbsp;<br>&nbsp;<br>The functions associated with ring maintenance in Token Ring are embedded in the physical and DLL layers of the standard&#46; The designers of FDDI recognized that these functions should be separate and independent of the core layer functions of the implementation&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;FDDI signal and encoding&nbsp;<br>##&nbsp;<br>&nbsp;<br>(1) fiber implementation&nbsp;<br>(2) copper implementation&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;(1) fiber implementation&nbsp;<br>#&nbsp;<br>&nbsp;<br>FDDI uses a Non Return to Zero Inverted (NRZI) 4bit/5bit encoding scheme&#46; Each encoded bit is generated on the medium through baseband light signals where the presence of light indicates a &quot;1&quot; and the absence of light indicates a &quot;0&quot;&#46;&nbsp;<br>&nbsp;<br>Unlike electrical based signaling which uses positive and negative voltage for signaling FDDI can only use the presence or absence of light for signaling since there is no such thing as negative light&#46; The concept of &quot;returning to zero&quot; in signaling is an electrical one where the point of signaling where neither positive or negative voltage exists is &quot;zero&quot;, i&#46;e&#46;, No current flowing&#46; Since light has no positive or negative it is inherently a non&#45;return to zero signaling mechanism&#46; Since there is no benefit to stopping the signal between two bits when two consecutive ones are generated the light signal continues into the next bit time&#46;&nbsp;<br>&nbsp;<br>FDDI uses symbols to represent values in its encoding scheme&#46; Each symbol is comprised of a 4&#45;bit value&#46; Two symbols equal an octet&#46;&nbsp;<br>&nbsp;<br>Since there is no positive to negative and vice versa transition of signals, there is no mechanism for stations to synchronize their signal reception from the transmission itself (as is the case with Token ring and its frame preamble)&#46; Therefore each station must maintain its own internal clocking mechanism&#46; Stations periodically broadcast control timing frames so all stations can synchronize their clocks&#46; This was sufficient for FDDI due to the lower speeds compared to modern telecommunications networks &#45; for high&#45;speed networks that span large distances, typically it is required to have an external clock source, that is synchronized between large distances &#45; usually through the use of satellites in space that transmit clock information, specifically for this purpose&#46;&nbsp;<br>&nbsp;<br>The problem with a light based signaling technique where the absence of light during the bit time equals a zero data bit is that absence of light also represents an idle or non&#45;functioning network&#46; Therefore, the generation of too many consecutive zero bits can have two detrimental impacts on other stations on the network&#46; One is that the stations may erroneously assume the network is idle&#46; The second potential problem is the station may lose its bit synchronization (timing)&#46; Thus it was determined that any symbol used should not contain three or more consecutive zeros&#46; Since this would eliminate too many of the available symbols in a 4 bit encoding scheme the actual encoding symbols transmitted are 5 bit symbols&#46; Only those 5 bit symbols that avoid the three consecutive zeros are used&#46; Each of these 5 bit symbols used is associated back to one of the 16 4 bit symbols used by the higher layers&#46; the remaining 5 bit symbols that have less than three consecutive zeros are used as control symbols by the MAC layer&#46;&nbsp;<br>&nbsp;<br>Hence every 4 bits received from the higher layer gets translated to an equivalent 5 bit symbol for transmission (4 bit / 5 bit encoding)&#46; This five bit encoding provides 16 data symbols (0&#45;F), 8 control symbols (Q, H, I, J, K, T, R, S), and 8 violation symbols (V)&#46; The coding of these symbols results in never having 4 consecutive zeros in a row during normal transmission&#46; This ensures that each station&#039;s clock remains in sync with all the other stations as long as there is traffic flowing &#45; idle frames or data frames&#46; The violation symbols (V) are the symbols which may allow the reception of 4 or more zero bits in a row&#46; They are not used by FDDI&#46; The same fundamental method is used for modern fiber&#45;based telecommunications networks &#45; the encoding requires that the bit patterns used to encode all data and control sequences must maintain a specific duty&#45;cycle &#45; a constant transition between 1s and 0s at a rate that would not allow a system to misinterpret real data as idle and vice versa&#46;&nbsp;<br>&nbsp;<br>[FDDI coding symbols]&nbsp;<br>&nbsp;<br>Symbol &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bit stream&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>0 (binary 0000) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11110&nbsp;<br>1 (binary 0001) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01001&nbsp;<br>2 (binary 0010) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10100&nbsp;<br>3 (binary 0011) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10101&nbsp;<br>4 (binary 0100) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01010&nbsp;<br>5 (binary 0101) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01011&nbsp;<br>6 (binary 0110) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01110&nbsp;<br>7 (binary 0111) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01111&nbsp;<br>8 (binary 1000) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10010&nbsp;<br>9 (binary 1001) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10011&nbsp;<br>A (binary 1010) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10110&nbsp;<br>B (binary 1011) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10111&nbsp;<br>C (binary 1100) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11010&nbsp;<br>D (binary 1101) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11011&nbsp;<br>E (binary 1110) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11100&nbsp;<br>F (binary 1111) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11101&nbsp;<br>Q (Quiet) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000&nbsp;<br>I (Idle) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11111&nbsp;<br>H (Halt) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00100&nbsp;<br>J (Starting Delimiter)	11000&nbsp;<br>K (Starting Delimiter)	10001&nbsp;<br>T (Ending Delimiter)	01101&nbsp;<br>R (Reset) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00111&nbsp;<br>S (Set) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11001&nbsp;<br>V or H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00100 (some V symbols may also be taken as H)&nbsp;<br>V or H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00010&nbsp;<br>V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00011&nbsp;<br>V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00101&nbsp;<br>V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00110&nbsp;<br>V or H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01000&nbsp;<br>V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01100&nbsp;<br>V or H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10000&nbsp;<br>&nbsp;<br>Each FDDI NIC contains a 125mhz clock which clocks the bits out onto the network at 125MBPS&#46; Since only 4 out of every 5 bits transmitted are data (one being overhead of the 4 to 5 bit conversion) only 100 of the 125MBPS transmitted are data&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;(2) copper implementations&nbsp;<br>#&nbsp;<br>&nbsp;<br>[Multiple Level Transition &#45; 3 levels (MLT&#45;3) encoding]&nbsp;<br>&nbsp;<br>MLT&#45;3 encodes a bit as presence or lack of transition, exactly as in NRZI&#46; What makes MLT&#45;3 different is that the base waveform is a 3&#45;state alternating wave&#46; Rather than alternating between 0 and 1 as in Manchester encoding and NRZI, MLT&#45;3 alternates from &#45;1 to 0 to +1, back to 0, then back to &#45;1, repeating indefinitely&#46; A zero is encoded as a halt in the back&#45;and&#45;forth progression&#46; With MLT&#45;3, it is possible to represent four or more bits with every complete waveform, at 0, +1, 0, and &#45;1&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;FDDI topology&nbsp;<br>###&nbsp;<br>&nbsp;<br>FDDI uses a dual ring topology comprised of two &quot;counter&#45;rotating&quot; rings&#46; While FDDI may not be deployed extensively, a significant portion of the high&#45;speed, public telco network uses SONET, which leverages a dual, counter&#45;rotating ring structure very similar to FDDI, and in one of the fault&#45;tolerant modes that is an option, behaves very similar to FDDI&#039;s fault recovery mechanism, making the basics of this important to understand&#46;&nbsp;<br>&nbsp;<br>As with Token Ring, FDDI&#039;s rings are a series of point to point connections between adjacent devices forming a closed loop&#46; FDDI however has two rings as opposed to Token Ring&#039;s one&#46; Transmissions generated on the inner ring are sent out in the opposite direction of transmissions sent on the outer ring resulting in the counter rotation capability&#46;&nbsp;<br>&nbsp;<br>Normal transmission occurs on the Primary (outer) ring&#46; The Secondary (inner) ring is dormant and provides an alternate data path in the event a fault occurs on the primary ring&#46; All FDDI stations directly attached to the rings will switch to this secondary ring when necessary to route traffic around a fault&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;SAS &nbsp;SAS &nbsp;SAS&nbsp;<br>&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;|&nbsp;<br>concentrator/DAC&nbsp;<br>&nbsp;| | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |&nbsp;<br>o| |i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i| |o&nbsp;<br>u| |n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n| |u&nbsp;<br>t| |n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n| |t&nbsp;<br>e| |e &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e| |e&nbsp;<br>r| |r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r| |r&nbsp;<br>&nbsp;| | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |&nbsp;<br>concentrator/DAC&nbsp;<br>&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;|&nbsp;<br>&nbsp;SAS &nbsp;SAS &nbsp;SAS&nbsp;<br>&nbsp;<br>&nbsp;<br>The Rings can extend up to 200 kilometers and support up to 500 dual attached devices&#46; FDDI can be implemented with up to 1000 single attached devices supported on both rings (500 on each)&#46; This however eliminates FDDI&#039;s fault tolerance and recovery capability and hence eliminates one of the key benefits and justifiers for the added expense of the technology&#46;&nbsp;<br>&nbsp;<br>The Design specification calls for no more than 1 bit error out of 2&#46;5 X 1010 bits transmitted&#46; Most implementations however, exceed this standard!&nbsp;<br>&nbsp;<br>[Device Classes]&nbsp;<br>&nbsp;<br>There are four classes of connection devices supported by FDDI&#46; They are&#58;&nbsp;<br>&nbsp;<br>&#45; 1&#46; Dual Attached Stations (DAS)&nbsp;<br>&#45; 2&#46; Single Attached Stations (SAS)&nbsp;<br>&#45; 3&#46; Dual Attached Concentrators (DAC)&nbsp;<br>&#45; 4&#46; Single Attached Concentrator (SAC)&nbsp;<br>&nbsp;<br>A dual attached device is one that has connections to both rings&#46; A single attached device is one that attaches only to one ring&#46;&nbsp;<br>&nbsp;<br>All devices directly connected to the rings must be dual attached&#46; This means that SAS and SAC devices can only be attached to the network through a DAC&#46; DAS devices can be attached directly to the rings or to DAS ports on a DAC&#46;&nbsp;<br>&nbsp;<br>DAC and SAC devices are concentrators which means that they are not end nodes on the network but rather multiple port concentrators for several end devices&#46; End Devices are either DACs or SACs&#46;&nbsp;<br>&nbsp;<br>Mission critical devices or devices with high fault tolerance requirements are usually dual attached&#46; These include business application servers, 7X24 workstations and shared peripherals like high speed, high volume laser printers&#46; Desktop systems and less critical servers/peripherals are usually single attached since their availability would not effect as large a population of users or a mission critical business process that must be completed and dual attaching them is not cost justifiable&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;FDDI token & frame format&nbsp;<br>###&nbsp;<br>&nbsp;<br>##&nbsp;<br>## (1) FDDI token format&nbsp;<br>##&nbsp;<br>&nbsp;<br>an FDDI token consists of [PA|SD|FC|ED] where&nbsp;<br>&nbsp;<br>PA = Preamble&#58; 4 or more symbols of Idle&#46;&nbsp;<br>SD = Starting Delimiter&#58; The symbols &#039;J&#039; and &#039;K&#039;&#46;&nbsp;<br>FC = Frame Control&#58; 2 symbols describing what type the token is&#46;&nbsp;<br>ED = Ending Delimiter&#58; two &#039;T&#039; symbols&#46;&nbsp;<br>&nbsp;<br>[Preamble]&nbsp;<br>The preamble consists of a minimum of 16 symbols of Idle&#46; Physical Layers of subsequent repeating stations may change the length of the Idle pattern as Physical Layer clocking requirements change&#46; Thus, repeating stations may see a variable length preamble that is shorter or longer than the originally transmitted preamble&#46; Tokens are recognized and acted upon when received with a preamble of zero or greater length&#46; If a valid token is received but cannot be repeated (due to ring timing or latency constraints), the station shall issue a new token&#46;&nbsp;<br>&nbsp;<br>[Starting Delimiter]&nbsp;<br>The Starting Delimiter is a unique indicator that identifies the start of the token&#46; It consists of the symbols &#039;J&#039; and &#039;K&#039; &#46; These symbols are exclusevely used for the start of a frame or token resulting in a unique sequence of bits that will not be seen anywhere else&#46; The symbol names of &quot;J&quot; and &quot;K&quot; relate back to FDDI&#039;s Token Ring roots where the &quot;J&quot; and &quot;K&quot; bits made up the Token Ring SD&#46;&nbsp;<br>&nbsp;<br>[Frame Control]&nbsp;<br>The frame control tells what kind of token it is&#46; A frame control of (hex) 80 is a Nonrestricted Token, while a frame control of (hex) C0 is a Restricted Token&#46;&nbsp;<br>&nbsp;<br>[Ending Delimiter]&nbsp;<br>The Ending Delimiter consists of two &#039;T&#039; symbols&#46; These &#039;T&#039; symbols indicate that the token is complete&#46; Any data sequence that does not end with these &#039;T&#039; symbols is not considered a token&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## (2) FDDI frame format&nbsp;<br>##&nbsp;<br>&nbsp;<br>an FDDI frame consists of [PA|SD|FC|DA|SA|INFO|FCS|ED|FS] where&nbsp;<br>&nbsp;<br>PA &#45; Preamble&#58; 4 or more symbols of Idle&#46;&nbsp;<br>SD &#45; Starting Delimiter&#58; The symbols &#039;J&#039; and &#039;K&#039;&#46;&nbsp;<br>FC &#45; Frame Control&#58; 2 symbols describing the type of frame (MAC or LLC)&#46;&nbsp;<br>DA &#45; Destination Address&#58; 12 symbols indicating who the recipient of the frame will be&#46;&nbsp;<br>SA &#45; Source Address&#58; 12 symbols indicating who sourced the frame&#46;&nbsp;<br>INFO &#45; Information Field&#58; 0 to 4478 bytes of information&#46;&nbsp;<br>FCS &#45; Frame Check Sequence&#58; 8 symbols of Cyclic Redundancy Check&#46;&nbsp;<br>ED &#45; Ending Delimiter&#58; a &#039;T&#039; symbol&#46;&nbsp;<br>FS &#45; End of Frame Sequence&#58; 3 indicator symbols&#46;&nbsp;<br>&nbsp;<br>[Preamble]&nbsp;<br>Preamble (PA)&#46; The PA of a frame is transmitted by the frame originator as a minimum of 16 symbols of Idle&#46; The physical Layers of subsequent repeating stations may change the length of the Idle pattern consistent with Physical Layer clocking requirements&#46; Thus, repeating stations may see a variable length preamble that is shorter or longer than the originally transmitted preamble&#46; A given MAC implementation is not required to copy frames received with less than 12 preamble symbols&#46;&nbsp;<br>&nbsp;<br>[Starting Delimiter]&nbsp;<br>The Starting Delimiter is an indicator of the start of the frame&#46; It consists of the symbols &#039;J&#039; and &#039;K&#039; and these symbols will not be seen anywhere else but at the start of a frame or a token&#46;&nbsp;<br>&nbsp;<br>[Frame control]&nbsp;<br>The frame control tells what kind of frame follows in the INFO field&#46; The most common Frame types are&#58;&nbsp;<br>&nbsp;<br>40 &nbsp;Void frame&nbsp;<br>41 &nbsp;Station Management (SMT) frame&nbsp;<br>4F &nbsp;Station Management (SMT) frame&nbsp;<br>C2 &nbsp;MAC frame&nbsp;<br>C3 &nbsp;MAC frame&nbsp;<br>50 &nbsp;LLC frame&nbsp;<br>51 &nbsp;LLC frame&nbsp;<br>60 &nbsp;Implementer frame&nbsp;<br>70 &nbsp;Reserved frame&nbsp;<br>&nbsp;<br>&nbsp;<br>[Destination Address]&nbsp;<br>&nbsp;<br>The Destination Address is a 12 symbol (48bit) code that indicates which station the frame is destined to&#46; Each station has a unique 12 symbol address that identifies it&#46; When a station receives a frame, it compares the DA of that frame to its own address&#46; If the two match, the station will copy the contents of the frame into its buffers&#46;&nbsp;<br>&nbsp;<br>A frame can also be intended for more than one station using group addressing&#46; The first bit transmitted in the destination address is an indictor of whether the address is an individual address, or a group address&#46; If the first bit is set (1), the address is a group address&#46; If it is not set (0), the address is an individual address&#46; Group addresses can be used to address a frame to multiple destination stations&#46;&nbsp;<br>&nbsp;<br>A broadcast address is a special type of group address which applies to all of the stations on the network&#46; In this address, all of the bits are set to one, so the broadcast address is 12 &#039;F&#039; symbols&#46;&nbsp;<br>&nbsp;<br>Addresses can either be locally or universally administered&#46; If the addresses are universally administered, then the first 6 symbols of the address is the manufacturer&#039;s OUI&#46; Each manufacturer is assigned a unique OUI to use for all of its products&#46; The last 6 symbols of the address differentiate between stations with the same manufacturer&#46; In a universally administered addressed network, the manufacturers assigned address is used&#46; Note that this address assignment and allocation is the same method for Ethernet MAC addresses as well&#46;&nbsp;<br>&nbsp;<br>In a locally administered addressing scheme, a network manager sets the address for each of the stations&#46; The second bit transmitted is the indicator of whether the address is a universal or a local address&#46; A set bit (1) means a locally administered address, while an unset bit (0) is a universally administered address&#46;&nbsp;<br>&nbsp;<br>[Source Address]&nbsp;<br>&nbsp;<br>The Source Address is the address of the station that created the frame&#46; In FDDI, the frame will be passed from one station to the next until it returns to the originating station&#46; The originating station then strips the frame (remove the frame from the physical medium)&#46; When a station receives a frame and the source address of that frame matches the address of the station, the station will strip the frame from the network&#46; Each station is responsible for removing its own frames from the ring&#46;&nbsp;<br>&nbsp;<br>As with Token Ring, the potential exists for a source station to be removed from the network before a frame it sourced returns&#46;&nbsp;<br>&nbsp;<br>[INFO]&nbsp;<br>&nbsp;<br>The INFO field contains all the data of the frame&#46; The frame is essentially built around this field as a mechanism for getting the info from one station to another&#46; The Frame Control field identifies what kind of information is contained in the INFO field&#46; For Example&#58;&nbsp;<br>&nbsp;<br>A frame with an FC of X&#039;50&#039; indicates an LLC frame, so the INFO field of a frame with a FC of X&#039;50&#039; will contain an LLC header followed by the upper layer headers (i&#46;e&#46; SNAP, ARP, IP, TCP, SNMP, etc&#46;) and their associated data (e&#46;g&#46;, IP Packet, TCP Frame, etc&#46;)&nbsp;<br>&nbsp;<br>A frame with an FC of X&#039;41&#039; or X&#039;4F&#039; will contain SMT (Station Management) information&#46; The INFO field in these you will see an SMT header followed by SMT information (e&#46;g&#46;, synchronize clock, activate secondary ring reception/transmission, etc&#46;)&#46;&nbsp;<br>&nbsp;<br>A frame with an FC of X&#039;C2&#039; or X&#039;C3&#039; is a MAC frame, and the info field will contain information relevent to the MAC protocol (e&#46;g&#46; Claim token, etc&#46;)&nbsp;<br>&nbsp;<br>[LLC Frame]&nbsp;<br>The first two bytes of every LLC header are addresses within each station called Service Access Points (SAPs)&#46; DSAP is the SAP on the destination machine, and SSAP is the SAP on the source machine&#46; SAPs are connection points for upper level programs&#46; If you have several application tasks running, each can have its own SAP&#46; By selecting the correct DSAP, you can control which task at the receiving end of the transmission processes the LLC frame&#46;&nbsp;<br>&nbsp;<br>The LLC control field will be one byte and may or may not be followed by data or information&#46; It all depends on what type of LLC frame is indicated within the control field&#46; Three types are possible&#46; Two of these can carry user data&#46; Refer back to Class # 3 for the description of I&#45;Format, S&#45;Format and U&#45;Format LLC Frames&#46;&nbsp;<br>&nbsp;<br>[SMT Frame]&nbsp;<br>For Station Management frames, the INFO field is occupied by an SMT Header and an SMT Information portion&#46; The SMT header is the protocol header for all SMT frames&#46; SMT Information is the information that is indicated by the header&#46; These two fields together make up an SMT Protocol Data Unit (PDU)&#46;&nbsp;<br>&nbsp;<br>[MAC Frame]&nbsp;<br>There are two different types of MAC frames&#58;&nbsp;<br>&nbsp;<br>&#45; Claim frames&nbsp;<br>&#45; Beacon frames&nbsp;<br>&nbsp;<br>A Claim frame has an FC of X&#039;C3&#039; and the MAC Info is the station&#039;s attempt to initiate a new token on the ring (and become the Active Monitor)&#46;&nbsp;<br>A Beacon frame has an FC of X&#039;C2&#039; and the MACInfo for a Beacon frame is as follows&#58;&nbsp;<br>1 Byte describing the Beacon Type&nbsp;<br>X&#039;00&#039;&#58; Regular Beacon (broadcast to all stations)&nbsp;<br>X&#039;01&#039;&#58; Directed Beacon (attempt to reach a specific device)&nbsp;<br>X&#039;02&#039;&#58; Jam Beacon (notification of ring failure)&nbsp;<br>3 bytes of pad (X&#039;00 00 00&#039;) Upstream Neighbor Address (optional)&nbsp;<br>&nbsp;<br>[SMT Frame]&nbsp;<br>&nbsp;<br>The SMT Info field consists of a list of parameters&#46; The parameters are of the form&#58;&nbsp;<br>&nbsp;<br>&#45; Parameter Type (2 bytes)&nbsp;<br>&#45; Parameter Length (2 bytes)&nbsp;<br>&#45; Resource Index (4 bytes)&nbsp;<br>&#45; Parameter Value (n bytes)&nbsp;<br>&nbsp;<br>If more than one parameter is present in the frame, they will be listed one after another&#46; The Parameter Type is the value that identifies specific parameter is being transmitted&#46; SMT parameters deal with issues like which ring to transmit or receive on, which port to activate/deactivate etc&#46;&nbsp;<br>&nbsp;<br>[Frame Control Sequence (FCS)]&nbsp;<br>&nbsp;<br>The FCS is used by a receiving station to verify that the frame traversed the network without incurring any bit errors&#46; The FCS is calculated by the station that sourced the frame using the bits of the FC, DA, SA, INFO, and FCS fields&#46; The FCS is recalculated by the receiving station and compared to the value on the incoming frame&#46; If any of the bits in those fields have been altered the will notice the receiving station will discard the frame&#46;&nbsp;<br>&nbsp;<br>FDDI performs error detection but does not provide error recovery&#46; No request for regeneration occurs&#46; Requests for retransmissions can be made by higher layer protocols like an LLC connection oriented service (FCS is a MAC layer function)&#46;&nbsp;<br>&nbsp;<br>[Ending Delimiter]&nbsp;<br>&nbsp;<br>The Ending Delimiter consists of a single &#039;T&#039; symbol&#46; This &#039;T&#039; symbol indicates that the frame is complete&#46; Any data sequence that does not end with this &#039;T&#039; symbol is not a considered a frame&#46;&nbsp;<br>&nbsp;<br>[Frame Status]&nbsp;<br>The Frame Status consists of 3 indicators which may have one of two values&#46; The indicators can either be Set (&#039;S&#039;) or Reset (&#039;R&#039;)&nbsp;<br>&nbsp;<br>Since the FS is outside of the FCS calculation the indicators could be corrupted&#46; A corrupted indicator is detected when the value is neither an &#039;S&#039; or an &#039;R&#039;&#46; Every frame is originally transmitted with all of the&nbsp;<br>&nbsp;<br>indicators set to &#039;R&#039; (reset)&#46; The indicators can be set by intermediate stations when they retransmit the frame&#46; The three indicators are&#58;&nbsp;<br>&nbsp;<br>&#45; 1&#46; Error (&#039;E&#039;)&nbsp;<br>&#45; 2&#46; Address recognized (or Acknowledge) (&#039;A&#039;)&nbsp;<br>&#45; 3&#46; Frame Copy (&#039;C&#039;)&#46;&nbsp;<br>&nbsp;<br>1&#46; Error&#58;&nbsp;<br>&nbsp;<br>This indicator is set when a station determines that the frame is in error&#46; This may be due to a format error, or to a failure of the CRC&#46; If a frame is received and the &#039;E&#039; indicator is anything other than Reset (&#039;R&#039;), then that frame is disregarded&#46;&nbsp;<br>&nbsp;<br>2&#46; Address Recognized&#58;&nbsp;<br>&nbsp;<br>This indicator is set by a station when it receives the frame and determines that the address applies to itself&#46; This could be because the destination address of the frame is the MAC address of the station, or because the destination address of the frame is a broadcast address&#46;&nbsp;<br>&nbsp;<br>3&#46; Copy&#58;&nbsp;<br>&nbsp;<br>This indicator is set when the station receives the frame and is able to copy the contents into its buffers&#46; Most stations do not copy the contents unless the frame is explicitly destined to them (or broadcast), so the &#039;A&#039; and the &#039;C&#039; indicators are usually set at the same time&#46; However, sometimes a station will be receiving so much traffic that it cannot copy all the information to its buffers even though the frame is addressed to it&#46; In this case, it would retransmit the frame with the &#039;A&#039; indicator set, but the &#039;C&#039; indicator will remain reset&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;FDDI transmission process&nbsp;<br>###&nbsp;<br>&nbsp;<br>A station gains the right to transmit its information onto the medium when it detects a token passing on the medium&#46; The token is a control signal comprised of a unique symbol sequence that circulates on the medium following each information transmission&#46; Any station, upon detection of a token, may capture the token by removing it from the ring&#46; The station may then transmit one or more frames of information&#46; At the completion of its information transmission, the station issues a new Token, which provides other stations the opportunity to gain access to the ring&#46;&nbsp;<br>When a station has something to send, it captures the Token, sends the information in formatted FDDI frames, then releases the token&#46; The header of these frames includes the address of the station(s) that will copy the frame&#46; All nodes read the frame as it is passed around the ring to determine if they are the recipient of the frame&#46; If they are, they extract the data, retransmitting the frame to the next station on the ring&#46;&nbsp;<br>&nbsp;<br>When the frame returns to the originating station, the originating station strips the frame&#46; The token&#45;access control scheme thus allows all stations to share the network bandwidth in an orderly and efficient manner&#46;&nbsp;<br>&nbsp;<br>When the station receives the token it compares the time it took for the token to circulate (TRT) to the Target Token Rotation Time (TTRT)&#46; If the token arrived early the station can transmit its synchronous frames for the allocated amount of time (known as the Synchronous Allocation (SA)&#46;&nbsp;<br>&nbsp;<br>The station can transmit its asynchronous frames if the remaining transmission allocation has not expired&#46; If the token arrives past the TTRT the station can only transmit its synchronous frames and relinquish the token&#46; Any asynchronous frames must continue to be held until an early token with an appropriate amount of available transmit time arrives&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;FDDI station management (aka SMT)&nbsp;<br>###&nbsp;<br>&nbsp;<br>Station Management provides the control necessary at the station (node) level to manage the processes in the various FDDI layers&#46; SMT provides services such as connection management, station insertion and removal, station initialization, configuration management, fault isolation and recovery, communications protocol for external authority, scheduling policies, and collection of statistics&#46;&nbsp;<br>&nbsp;<br>SMT maintains knowledge of both the uniqueness of the node and the current network structure to the extent that the node&#039;s function is affected&#46;&nbsp;<br>&nbsp;<br>A variety of internal node configurations are possible&#46; It may have multiple instances of MACs, PHYs, and PMDs defined by the implementer&#46; A node however can have only one SMT entity&#46; The capability to do this is the result of the isolation and independence of the SMT functions from the other core layer functions&#46; Hence, a device with multiple FDDI connections (NICs) like a Hub can be viewed and managed by SMT as a single entity&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;SMT functions&nbsp;<br>##&nbsp;<br>&nbsp;<br>(1) physical connection mgmt&nbsp;<br>(2) token establishment&nbsp;<br>(3) ring failure&nbsp;<br>&nbsp;<br>#&nbsp;<br># (1) physical connection mgmt&nbsp;<br>#&nbsp;<br>&nbsp;<br>Within every FDDI station there are SMT entities called PCM (Physical Connection Management)&#46; The number of PCM entities within a station is exactly equal to the number of ports that the station has&#46; This is because each PCM is responsible for one port&#46;&nbsp;<br>&nbsp;<br>The PCM entities are the part of SMT that control the ports&#46; In order to make a connection, two ports must be physically connected to each other by means of a fiber&#45;optic or copper cable&#46; When this happens, the PCMs that are responsible for those ports can recognize each other&#039;s existence and begin communicating&#46; They do this by sending Line States out of the port and onto the fiber&#46; The PCM at the other end of the connection will recognize the line state and respond accordingly&#46; When the PCM sees another PCM on the other end of the connection, they will synchronize and communicate with each other&#46; During this communication, a couple of important things happen&#58;&nbsp;<br>&nbsp;<br>&#45; The PCMs figure out the type of port at the other end and determine if they are compatible&#46;&nbsp;<br>&#45; The PCMs Perform an LCT (Link Confidence Test)&#46; The LCT determines if the quality of the link is good enough to establish a connection&#46; If it is not, the PCMs will not make a connection&#46;&nbsp;<br>&nbsp;<br>If the line state signaling is successful, the PCMs will establish a connection and place the ports on the token path that goes through that station&#46;&nbsp;<br>&nbsp;<br>At this point, data (in the form of frames) can be sent through these ports and the ports become part of the network&#46;&nbsp;<br>&nbsp;<br>PCM entities have a number of internal states that they can be in&#46; While in any state, the PCM has the port send out a certain line state&#46; This line state will be received by the PCM on the other side of the connection&#46; The other PCM entity (at the other end of the connection) will be able to tell which state the original PCM is in&#46; PCMs use this information to signal data across the connection&#46;&nbsp;<br>&nbsp;<br>There are 7 basic states that the PCM can be in&#58;&nbsp;<br>&nbsp;<br>&#45; Connect&nbsp;<br>&#45; Break&nbsp;<br>&#45; Next&nbsp;<br>&#45; Signal&nbsp;<br>&#45; Join&nbsp;<br>&#45; Verify&nbsp;<br>&#45; Active&nbsp;<br>&nbsp;<br>#&nbsp;<br># (2) token establishment&nbsp;<br>#&nbsp;<br>&nbsp;<br>If a station has established connectivity to the upstream and down stream devices the station moves to a ready or Active state&#46; In this state the station will continue to sample the medium looking for a token or frame transmission&#46; If no transmission is detected after a predetermined wait period, the station will begin its claim token process&#46;&nbsp;<br>&nbsp;<br>Each station begins to transmit a continuous stream of control frames called &quot;claim frames&quot;&#46; Each frame contains a suggested &quot;Target Token Rotation Time&quot; (TTRT)&#46; If the station receives a claim frame from another station it compares the TTRT value in the received frame to the one the station used in its claim frame&#46; If its suggested TTRT is lower than the received frame it discards the received frame and continues to transmit its own claim frame&#46; If the value on the received frame is lower it stops generating its own claim frames and retransmits the other station&#039;s claim frame&#46;&nbsp;<br>&nbsp;<br>Eventually the claim frame with the lowest TTRT will be transmitted back to its originating station&#46; At that point the station declares itself the winner of the claim token process and will generate the token onto the ring&#46; This token will contain the winning TTRT value which will be copied and used by every other station in the ring&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># (3) ring failure&nbsp;<br>#&nbsp;<br>&nbsp;<br>When a serious failure occurs in the network, i&#46;e&#46;, a break in one or both rings in one or more places, the fault isolation and recovery process is initiated&#46;&nbsp;<br>&nbsp;<br>Similar to previously discussed Token Ring, Each station begins transmitting a special frame called a beacon&#46; As each station receives the beacon from its upstram predecessor it stops transmittiong its own beacon and regenerates the beacon received from the upstream system&#46; Eventually the station immediately down stream from the break recognizes that the break is immediately up stream (since no other beacon signal has been received)&#46;&nbsp;<br>&nbsp;<br>Unlike Token Ring, FDDI with its dual counter rotating ring configuration is able to bypass the faulty station by reconfiguring its ports to close the loop by utilizing the &quot;good side&quot; of the primary and secondary rings&#46;&nbsp;<br>&nbsp;<br>Since all other stations were able to communicate with this station on the primary ring, it can communicate with the system that was immediately upstream of the break&#46; This station will also initiate its port management function to close the loop by transmitting all outgoing signals on the secondary ring&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###############################&nbsp;<br>### &nbsp;&nbsp;&nbsp;network layer (L3) &nbsp;&nbsp;###&nbsp;<br>###############################&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;intro&nbsp;<br>##&nbsp;<br>&nbsp;<br>The network layer concerns itself with getting data all the way from the source to the destination It is concerned with the end&#45;to&#45;end delivery of the data, over intermediate nodes if necessary&#46;&nbsp;<br>&nbsp;<br>In the OSI reference model, this layer lies above the datalink layer and below the transport layer&#46; An understanding of how the network layer relates to the layers above and below will be discussed before discussing the relationship between the network layer at the peer level with other systems&#46;&nbsp;<br>&nbsp;<br>The interaction between the network and transport layers is defined in terms of the service provided to the transport layer&#46; While the transport layer may provide a guaranteed data transmission, it has no influence over how the information is delivered in terms of identifying where it should go and how it should get there&#46; If the information being transferred between two end systems needs to be processed at as higher level of quality ,i&#46;e&#46;, received in packet order sequence, then it is the responsibility of the transport layer to negotiate and manage this process&#46; The Network layer makes its &quot;best attempt&quot; to reach the end station for each packet received from the transport layer&#46; It will not however guarantee its delivery or the order of its delivery in relation to other packets destined for the same end station&#46;&nbsp;<br>&nbsp;<br>The datalink layer&#039;s responsibility is to take a raw communication channel (provided by the physical layer) and transform it into an error free bit transmission facility&#46; The important thing to note here is that this &quot;raw&quot; communication channel is built over a single link between two nodes or on a shared link with a finite number of nodes&#46; In most instances the two &quot;end&quot; systems wishing to communicate will not be directly connected or on the same shared medium&#46; Communication between the two has to be routed through one or more intermediate nodes&#46; The routing of the information is handled by the network layer&#46; The Network Layer establishes and maintains a logical set of source and destination addresses that are retained within the data from end to end of the transmission as opposed to the DLL physical addresses which are used only when two systems have a direct physical path between them&#46; There is a exception to this case, which we will discuss later &#45; the idea of NAT and PAT, Network Address Translation and Port Address Translation &#45; these technologies may alter the Network Layer payload addresses during transmission, but in a special case, and only at one point, typically at the edge of a private network&#46;&nbsp;<br>&nbsp;<br>The network layer needs to know&#58;&nbsp;<br>&nbsp;<br>&#45; The physical attributes (directly attached networks and hosts) of the underlying communication network to which the device is attached&nbsp;<br>&#45; The specific paths or path options to all other networks not immediately attached to the device&#039;s network&nbsp;<br>&#45; the most efficient way to reach those networks without causing congestion&#46;&nbsp;<br>&nbsp;<br>Congestion can be caused by the speed of the system processing the packet or the speed of the network connection on which the packets travel&#46;&nbsp;<br>&nbsp;<br>System congestion is the result of packets being transferred through the network at such a rate that it absorbs all the buffers within the one or more systems along the path&#46; It has nothing to do with the bandwidth between the systems&#46; Regardless of the capacity of the connection between the systems, if the buffers are too slow to deal with the traffic entering a device, then queues will build up&#46;&nbsp;<br>&nbsp;<br>The other situation is where the buffers have plenty of available capacity but the rate of incoming packets exceeds the output line capacity&#46; This is actually a very common occurance, even for home networks&#46; If you consider your home router &#45; it is likely that you would have multiple &quot;internal&quot; LAN connections on your home router, but only one WAN port&#46; If all of them at 100MB/s ports &#45; and you have more than one system on the LAN &#45; if the multiple systems all try to send the full bandwidth of their individual connections to a device on the WAN, the WAN port would be half or less the capacity of the inbound traffic to the router&#46; (This is assuming that the router itself could handle more than one full connection bandwidth internally&#46;)&nbsp;<br>&nbsp;<br>Congestion has a domino effect on the network&#46; When congestion due to buffer absorption occurs, any additional incoming packets will be &quot;dropped&quot; (not copied into a buffer)&#46; This results in additional network requests to re&#45;generate the dropped packets causing even more congestion if not controlled&#46; If congestion is caused by line speed, this will result in more packets being held in the buffers which will eventually lead to buffer congestion if left uncontrolled&#46; Since each intermediary system holds packets until their transmission to the next &quot;hop&quot; in the network is confirmed, their buffers will begin to fill up as packets are dropped from downstream systems&#46; This can cascade all the way back through the network&#46;&nbsp;<br>&nbsp;<br>Each network layer device must have a mechanism to control congestion&#46; Some common types of congestion control include&#58;&nbsp;<br>&nbsp;<br>&#45; Packet Discarding&nbsp;<br>&#45; Pre&#45;allocation of Buffers&nbsp;<br>&#45; Flow Control&nbsp;<br>&#45; Choke Packets&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Routable vs&#46; Non Routable Protocols&nbsp;<br>###&nbsp;<br>&nbsp;<br>Routing is the selection of paths for packets and is performed by the network layer protocol software&#46; In some implementations, the source can also identify the path that the packets will follow&#46;&nbsp;<br>&nbsp;<br>Not all network layer protocols are &quot;Routable&quot;&#46; A routable protocol contains intelligence and an addressing scheme to facilitate routing&#46; Examples of routable protocols are&#58;&nbsp;<br>&nbsp;<br>&#45; XNS (Xerox Networking System)&nbsp;<br>&#45; IPX (Netware)&nbsp;<br>&#45; IP&nbsp;<br>&#45; DecNet Phase IV&nbsp;<br>&#45; DecNet 10SI&nbsp;<br>&#45; Apple talk&nbsp;<br>&nbsp;<br>Two key components are necessary for a protocol to be routable&#46; First, the protocol must specify a logical addressing scheme that provides a way to identify all the networks where the protocol is operating and all devices on each of those networks&#46; Secondly, the protocol must be capable of binding to the LLC as a recognizable subnet access protocol (SNAP)&#46; Obviously, a third condition for success is that a (physical or wireless) transmission path must exist all the way from the sending to the receiving node&#46;&nbsp;<br>&nbsp;<br>Later in this class when we discuss the Internet Protocol (IP) you will see that the IP address is comprised of two components&#46; The first part of the address is a &quot;network&quot; identifier and the second part is a &quot;host&quot; or system identifier&#46; These two pieces of information are used by the IP software in each system to move the data to its final destination&#46;&nbsp;<br>&nbsp;<br>Routable protocols maintain their routing information in &quot;routing tables&#46;&quot; Routing tables are data stored in buffers that identify the MAC (physical) addresses of&#58;&nbsp;<br>&#45; systems or hosts on the same network&nbsp;<br>&#45; intermediary devices that connect all other networks directly attached to the station&#039;s network&nbsp;<br>&#45; the default path when neither of the above will result in proper delivery of the data&nbsp;<br>&nbsp;<br>Non&#45;routable protocols contain no unique intelligence or inter&#45;networking IDs in the address scheme&#46; Most non&#45;routable protocols rely on broadcast address capability at the physical (MAC) layer level to communicate with other systems&#46; However, if intermediary devices (like bridges/switches or routers) have their &quot;broadcast filtering&quot; capability on, all broadcast transmissions will not move off of the segment upon which they were generated&#46; Therefore no traffic will move beyond the physical subnet where the broadcast was generated&#46;&nbsp;<br>&nbsp;<br>Examples of non routable protocols are&#58;&nbsp;<br>&nbsp;<br>&#45; NetBIOS&nbsp;<br>&#45; SNA Subarea Networking&nbsp;<br>&#45; SNA APPN(Adv&#46; Peer to Peer Networking)&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Routing Process and Alternatives&nbsp;<br>###&nbsp;<br>&nbsp;<br>Routing is the main process used by networked devices to deliver packets to their end destination&#46; Since the transmission of information at the data link level requires physical source address to physical destination address frame transmission, routing can be thought of as a hop&#45;by&#45;hop process transcending one or more point to point physical connections&#46; This means that each host or router that handles a packet examines the logical (network layer) destination address in the network layer packet header and determines the next hop (physical connection) that will bring the packet one step closer to its destination&#46; Once this is determined the network layer will construct a PDU that is passed to the MAC layer for delivery to the next physical point in the path&#46; The MAC layer constructs a new frame to deliver to the next device&#46; This process is repeated at the next and all subsequent devices until the end destination is reached&#46;&nbsp;<br>&nbsp;<br>Hence routed frames contain two addresses for both source and destination&#58;&nbsp;<br>&nbsp;<br>1) The network layer source and destination addresses which stay intact until delivered, stored inside the network layer PDU (which is inside the LLC Info field of the frame)&#46;&nbsp;<br>&nbsp;<br>2) The current system&#039;s (the original source machine, or the current router processing the packet) source MAC address and next&#45;hop or final destination MAC address which changes as the frame is passed from one intermediate node to another&#46;&nbsp;<br>&nbsp;<br>The following table shows how addresses are changed at the physical layer but remain the same at the logical layer as the information moves from hop to hop&#46;&nbsp;<br>&nbsp;<br>Station &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAC Address &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Network Addr &nbsp;MAC Src Addr &nbsp;&nbsp;&nbsp;&nbsp;MAC Dest&#46; Addr &nbsp;&nbsp;IP Src Addr &nbsp;&nbsp;IP Dst Addr&nbsp;<br>Sending Station 0100100101011011 203&#46;105&#46;31&#46;14 0100100101011011 0100111101000011 203&#46;105&#46;31&#46;14 202&#46;15&#46;31&#46;6&nbsp;<br>Router 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0100111101000011 203&#46;105&#46;31&#46;2 &nbsp;0100111101000011 0101110001000011 203&#46;105&#46;31&#46;14 202&#46;15&#46;31&#46;6&nbsp;<br>Router 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0101110001000011 202&#46;15&#46;31&#46;11 &nbsp;0101110001000011 0101110001001111 203&#46;105&#46;31&#46;14 202&#46;15&#46;31&#46;6&nbsp;<br>Rcving Station &nbsp;0101110001001111 202&#46;15&#46;31&#46;6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;203&#46;105&#46;31&#46;14 202&#46;15&#46;31&#46;6&nbsp;<br>&nbsp;<br>In the above table three distinct DLL frames are created&#58;&nbsp;<br>&nbsp;<br>&#45; A frame from the sending station to router 1&nbsp;<br>&#45; A frame from router 1 to router 2&nbsp;<br>&#45; A frame from router 2 to the receiving station&nbsp;<br>&nbsp;<br>However only one distinct Network Layer packet (with the appopriate higher layer data encapsulated in the payload) was created which remains intact from the sender to the receiver&#46;&nbsp;<br>&nbsp;<br>Routes can pass across LANs with different DLL & physical protocols & types&#46; In the above table, the sending station could be an wired Ethernet NIC connected via Twisted Pair and the receiving device 802&#46;11a wireless to a final destination&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Routing Tables&nbsp;<br>##&nbsp;<br>&nbsp;<br>Network Layer protocols use routing tables to compute the next hop for a packet&#46; Routing tables can take many forms depending on the protocol&#46;&nbsp;<br>&nbsp;<br>In IP each entry in a routing table has at least three fields&#58;&nbsp;<br>&nbsp;<br>&#45; Routing Address&nbsp;<br>&#45; Routing Mask&nbsp;<br>&#45; Next Hop&nbsp;<br>&nbsp;<br>The Next Hop is always the IP address of another host or router that is directly reachable via an Ethernet, serial link, or some other physical connection&#46; The Routing Address and Routing Mask specify a set of destinations for which the routing entry is valid &#46; In other words, if the network ID (calculated by using the subnet mask) of the destination address in the packet matches the routing address and routing mask then the packet is sent to the identified next hop&#46;&nbsp;<br>&nbsp;<br>If no routing table entries match a packet&#039;s Destination Address, the packet is processed using the &quot;default gateway&quot; or &quot;default route&quot; entry in the table, or discarded as undeliverable if no default route is defined&#46;&nbsp;<br>&nbsp;<br>If multiple routing tables entries match (i&#46;e&#46;, there is more than one path to the destination known), the longest match is preferred&#46; The longest match is the entry with the most 1 bits in its routing mask &#45; meaning the most &quot;specific&quot; match&#46;&nbsp;<br>&nbsp;<br>Bridged and MAC layer switched networks are invisible to the network layer and regarded as a single connection &#45; this is because from the DLL the sender does not need to know anything about the topology/layout because the DLL devices will move the data to the destination within that logical segment&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Routing Mask&nbsp;<br>#&nbsp;<br>&nbsp;<br>To avoid needing routing entries for every possible Internet destination, most hosts and routers use a default route (some routing tables contain nothing but a single default route)&#46; A default route has a Routing Address/Mask pair of 0&#46;0&#46;0&#46;0/0&#46;0&#46;0&#46;0&#46; In other words, it matches every IP address, but since there are no 1 bits in its Routing Mask, any other match would be selected by the longest match rule referenced earlier&#46; The default route will only be used if there are no other matches in the routing table&#46; Default routes are quite common, and are put to best use on networks with only a single link connecting to the global Internet or to an external network&#46; On such a network, routing tables will have entries for local networks and subnets, as well as a single default route leading to the outbound link&#46; However, remember that all Next Hops must be directly reachable, so the default routes won&#039;t necessarily point to the same IP address&#46; Also, some networks (large Internet service providers, mostly) use routing tables without defaults that must be able to match every IP address in the global network&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Routing Protocols&nbsp;<br>##&nbsp;<br>&nbsp;<br>Routers can use pre&#45;defined routing tables which identify all paths, or can use discovery packets to solicit node information and build their own maps&#46;&nbsp;<br>&nbsp;<br>Static routing has no real time adaptation&#46; All routing information is hand coded (data manually entered) into the routing tables&#46; Any changes to the network or devices on the network need to be re&#45;entered in all the affected tables&#46; Static routing is no longer used except in highly secured private networks as an added safety valve against encroachment&#46;&nbsp;<br>&nbsp;<br>Quasi&#45;static is static routing with alternate (multiple) paths&#46; While all routing information is again hand&#45;coded into the system, the network can adapt to congestion or line failure by switching to an alternative hard&#45;coded route&#46;&nbsp;<br>&nbsp;<br>For all routing techniques except for static and quasi&#45;static, a mechanism for responding to routing information requests needs to be implemented&#46; Examples of these implementations include&#58;&nbsp;<br>&nbsp;<br>Centralized (a central device provides routing information to the requesting router)&nbsp;<br>&nbsp;<br>Distributed (routing information is distributed among some or all of the routing devices in the network)&nbsp;<br>&nbsp;<br>Centralized routing has some drawbacks in that the central device can be a bottleneck or worse take entire network down if it fails&#46;&nbsp;<br>&nbsp;<br>Distributed routing has drawbacks in that changes in the network, even if minor, can result in flooded proliferation of update information across the network&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Centralized Routing&nbsp;<br>#&nbsp;<br>&nbsp;<br>Centralized routing requires a Routing Control Center (RCC) to make the routing decisions from a single network node&#46; Each node periodically reports its path information to the RCC (e&#46;g&#46; lists of neighbors, current queue lengths, amount of traffic processed since last report, etc&#46;) The RCC has an overall picture of the network, and can use the supplied information as metrics to make a routing decision&#46; While this method, with its seemingly complete knowledge of the network, seems ideal for finding optimal paths there are several problems with this approach&#46;&nbsp;<br>&nbsp;<br>The links into the RCC will be heavily loaded with status packets adding overhead and potentially congestion to the network&#46; If the RCC fails or becomes disconnected then no routing information will be returned to stations requesting the path resulting in no packets being routed&#46; If the network topology or traffic fluctuates frequently, then status reports will potentially provide an inaccurate picture of the network&#039;s overall state&#46;&nbsp;<br>&nbsp;<br>Setting up two or more RCCs and distributing routing alternatives instead of single best paths eliminate or reduce the impacts of the central approach&#46; This, however contradicts rationale behind a centralized routing paradigm&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Distributed Routing&nbsp;<br>#&nbsp;<br>&nbsp;<br>Distributed routing is where routing information is distributed among all the devices that perform the routing function&#46; The amount of information distributed to each device varies by protocol in terms of understanding all or some of the network&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Distance&#45;Vector Routing Protocols]&nbsp;<br>&nbsp;<br>This routing protocol requires that each router simply inform its neighbors of its routing table&#46; For each network path, the receiving routers pick the neighbor advertising the lowest cost, then add this entry into its routing table for re&#45;advertisement&#46; Hello and RIP are common Distance&#45;Vector routing protocols&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Link State Routing Protocols]&nbsp;<br>&nbsp;<br>This type of routing protocol requires each router to maintain at least a partial map of the network&#46; When a network link changes state (up to down, or vice versa), a notification is flooded throughout the network&#46; All the routers note the change, and re&#45;compute their routes accordingly&#46; This method is more reliable, easier to debug and less bandwidth&#45;intensive than Distance&#45;Vector&#46; It is also more complex and more compute&#45; and memory&#45;intensive&#46; OSPF and OSI&#039;s IS&#45;IS are link state routing protocols&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Routing Demarcations&nbsp;<br>##&nbsp;<br>&nbsp;<br>&#45;&#45; [Interior Routing]&nbsp;<br>&nbsp;<br>Interior routing occurs within an autonomous system&#46; Most common routing protocols, such as RIP and Open Shortest Path First (OSPF), are interior routing protocols&#46; The basic routable element is the IP network or subnetwork, or CIDR (Classless Inter&#45;Domain Routing) prefix for newer protocols&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [OSPF&#45;2 Protocol]&nbsp;<br>&nbsp;<br>Open Shortest Path First (OSPF) is a relatively common Internet interior routing scene&#46; OSPF Version 2 is documented in RFC 1583&#46; Sanctioned by the Internet Engineering Task Force (IETF), OSPF is a link&#45;state protocol with a complex set of options and features&#46; Not all of these features are available on all implementations, but some of its advantages are&#58;&nbsp;<br>&nbsp;<br>Scalability&#58;&nbsp;<br>&#45; OSPF is specifically designed to operate with larger networks&#46; It does not impose a hop&#45;count restriction and permits its domain to be subdivided for easier management&#46;&nbsp;<br>&nbsp;<br>Hello packets&#58;&nbsp;<br>&#45; OSPF uses small &quot;hello&quot; packets to verify link operation without transferring large tables&#46; In stable networks, large updates occur only once every 30 minutes&#46;&nbsp;<br>&nbsp;<br>Type Of Service (TOS) routing&#58;&nbsp;<br>&#45; OSPF can route packets by different criterion based on their Type Of Service (TOS) field&#46; For example, file transfers could be routed over a satellite link while terminal I/O could avoid such high delays&#46; This requires cooperative applications on the end systems&#46;&nbsp;<br>&nbsp;<br>Tagged routes&#58;&nbsp;<br>&#45; Routes can be tagged with arbitrary values, easing inter&#45;operation with EGPs, which can tag OSPF routes with AS numbers&#46;&nbsp;<br>&nbsp;<br>Full subnetting support&#58;&nbsp;<br>&#45; OSPF can fully support subnetting, including VLSM and non&#45;contiguous subnets&#46;&nbsp;<br>&nbsp;<br>OSPF has some disadvantages as well&#46; Chief among them are its complexity and its demands on memory and computation resources&#46; Although link&#45;state protocols are not difficult to understand, OSPF adds complexity with a host of options and features&#46;&nbsp;<br>&nbsp;<br>OSPF divides its routing domain into areas&#46; Area 0, the backbone, is required&#46; This divides interior routing into two levels&#46; If traffic must travel between two areas, the packets are first routed to the backbone&#46; This may cause non&#45;optimal routes, since inter&#45;area routing is not done until the packet reaches the backbone&#46; Once there, it is routed to the destination area, which is then responsible for final delivery&#46; This layering permits addresses to be consolidated by area, reducing the size of databases&#46; Small networks can operate with a single OSPF area&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>RIP Protocol Overview&nbsp;<br>Of Internet interior routing protocols, RIP was the most widely used early on, but the significant limitations have made it less common&#46; It is a distance&#45;vector protocol based on a 1970s Xerox design&#46; Ported to TCP/IP when LANs first appeared in the early 80s, RIP has changed little in the past decade and suffers from several limitations including&#58;&nbsp;<br>&nbsp;<br>Width restriction&#58;&nbsp;<br>&#45; RIP uses a 4&#45;bit metric to count router hops to a destination&#46; A RIP network can be no wider than 15 hops (16 is infinity)&#46; If hop counts are elevated on slower or less reliable links, this can quickly becomes a problem&#46;&nbsp;<br>&nbsp;<br>Subnet support&#58;&nbsp;<br>&#45; RIP was deployed prior to subnetting and has no direct support for it&#46; It can be used in subnetted environments, subject to restrictions&#46; VLSM can not be used in RIP networks&#46;&nbsp;<br>&nbsp;<br>Bandwidth consumption&#58;&nbsp;<br>&#45; Every 30 seconds or so, a RIP router will broadcast lists of networks and subnets it can reach&#46; Depending on the lengths of these lists, which depend on the size of the network, bandwidth usage can become prohibitive on slow links&#46;&nbsp;<br>&nbsp;<br>Security&#58;&nbsp;<br>&#45; RIP itself has no security features&#46; Some developers have produced RIP implementations that will only accept updates from specific hosts, to minimize the risk&#46;&nbsp;<br>&nbsp;<br>RIP however, has several benefits&#46; It has the highest level of interoperability and compatibility in products that use interior gateway protocols&#46; RIP is also easy to configure&#46; Finally, RIP processing does not impose serious CPU utilization or flash memory storage requirements on the devices where it is installed&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Exterior Routing&nbsp;<br>##&nbsp;<br>&nbsp;<br>Exterior routing occurs between autonomous systems, and is of concern to service providers and other large or complex networks&#46; The basic routable element is the Autonomous System, a collection of CIDR prefixes identified by an Autonomous System number&#46; While there may be many different interior routing scheme, a single exterior routing system manages the global Internet, based on the BGP&#45;4 exterior routing protocol&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;BGP&#45;4 Protocol&nbsp;<br>#&nbsp;<br>&nbsp;<br>Border Gateway Protocol Version 4 (BGP&#45;4), documented in RFC 1771, is the current exterior routing protocol used for the global Internet&#46; BGP is essentially a distance&#45;vector algorithm, but with several twists that resemble link&#45;state operation&#46;&nbsp;<br>&nbsp;<br>On connection start, BGP peers exchange complete copies of their routing tables, which can be quite large&#46; However, only changes (deltas) are then exchanged, which makes long running BGP sessions more efficient than shorter ones&#46;&nbsp;<br>&nbsp;<br>BGP&#039;s basic unit of routing information is the BGP path, a route to a certain set of CIDR prefixes&#46; Paths are tagged with various path attributes&#46; The sender of the path is noted as the next hop&#46; It the responsibility of the BGP implementation to select among competing paths &#46;&nbsp;<br>&nbsp;<br>In store and forward networks packets can be transported one of two ways&#58;&nbsp;<br>&nbsp;<br>&#45; For datagram transport the network selects the path for each packet individually&#46;&nbsp;<br>&#45; For virtual circuit transport the network makes one path selection for all the packets of the same connection&#46;&nbsp;<br>&nbsp;<br>Useful Routing Algorithm Characteristics&#58;&nbsp;<br>&nbsp;<br>The following metrics should be considered when evaluating routing protocols&#58;&nbsp;<br>&nbsp;<br>&#45; Robustness &#45; it should adapt the routing decisions to changing conditions (i&#46;e &#46; network traffic and topology)&#46;&nbsp;<br>&#45; Stability &#45; a small change in conditions should result in a small change in routing decisions&#46;&nbsp;<br>&#45; Fairness &#45; different users should experience equitable delays and transmission rates&#46;&nbsp;<br>&#45; Optimization &#45; maximizing the network designers objective function while satisfying the design constraints&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Network Layer Addressing&nbsp;<br>###&nbsp;<br>&nbsp;<br>[MAC versus Networking Layer Addressing]&nbsp;<br>&nbsp;<br>At this point in the learning process you should understand that a data communication between two physical devices can only occur if there is a physical or (wireless) communication path between the two devices&#46; You should also understand that the MAC layer controls how that communication between those two physical devices is initiated (access to the Medium), how to read it (Frame Format), and who it is for (MAC Address)&#46;&nbsp;<br>&nbsp;<br>Communications at the Network Layer are logical communication channels not physical ones&#46; The Network layer assigns a unique, Logical, Network address (or Internet Address) to each system in the entire network&#46; This logical address is not the same in terms of its structure or its unique value assigned to each system for different network protocols e&#46;g&#46;, IP network addressing is different than IPX&#039;s&#46; A system that participates in both IP and IPX networks has an IP address assigned to it by IP administration and an IPX address assigned by IPX&#46; If that device is attached to one network (has only one NIC) it will have only one physical address and two logical addresses that both reference the same physical address in their routing tables&#46; (The ARP physical address is the same in both protocols)&#46;&nbsp;<br>&nbsp;<br>The MAC Address identifies a specific (unique) physical Interface Card (NIC) attached to the network&#46; A device that is attached to more than one physical network (like a Bridge or a Router) will have two Network interface cards and hence two physical addresses&#46;&nbsp;<br>&nbsp;<br>Routers which function at the Network Layer are capable of passing messages through intermediate nodes until its final destination is reached&#46; Therefore Information that needs to be routed must have two address types associated with it&#58;&nbsp;<br>&nbsp;<br>1) the original source and final destination (Network Layer) addresses which stay intact in the information field of the frame until delivered to the final destination&#46;&nbsp;<br>&nbsp;<br>2) the current sender and next intermediate hop or final destination (MAC Layer) addresses which change as the frame is passed from one intermediate node to another&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Network Layer and the LLC&nbsp;<br>###&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Services&nbsp;<br>##&nbsp;<br>&nbsp;<br>The interface to upper Network Layer defines the services LLC should provide in order for the data transmission be transparent to Network layer&#46;&nbsp;<br>&nbsp;<br>For Type 1 LLC services a connection is not required&#46; Only two service primitives are needed&#58;&nbsp;<br>&nbsp;<br>&#45; the DATA&#46;request from the Network layer to the LLC for transmission of a connectionless frame&nbsp;<br>&#45; the DATA&#46;indication from the LLC to pass a connectionless frame up to Network Layer&#46;&nbsp;<br>&nbsp;<br>For Type 2 LLC services a connection between two systems via their SAP points is required&#46; Thus the services must include the data link CONNECT, DISCONNECT, CONNECTION&#45;FLOWCONTROL, and connection RESET services as well&#46; All of these services have three primitives&#58;&nbsp;<br>&nbsp;<br>&#45; request&nbsp;<br>&#45; indication&nbsp;<br>&#45; confirmation&nbsp;<br>&nbsp;<br>The only exception is the CONNECTION&#45;FLOWCONTROL, which does not need to be confirmed&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Sub&#45;network access protocol frame&#58;&nbsp;<br>##&nbsp;<br>&nbsp;<br>As LANs evolved into multiple interconnected networks and interconnected with Wide Area Networks the requirement to support internetwork routing became essential&#46; Even though LANs only address the DLL and Physical layers, they must define the interface specifications for the adjacent layers&#46; Since the upper network layer could be running any of a multiple of network layer protocols, the LLC must have a mechanism to determine what Network layer protocol needs to be called to accept the Info stripped from the frame&#46;&nbsp;<br>&nbsp;<br>To solve this problem, an extension to the original 802&#46;2 format was provided called the SNAP (Subnetwork Access Protocol)&#46; When this format is used, the LLC frame encapsulates the SNAP header&#58;&nbsp;<br>&nbsp;<br>Setting the DSAP and SSAP to 0xAA indicates that a SNAP header follows in the next 5 bytes&#46; The first 3 bytes identify the Organization Code which is assigned by IEEE&#46; The next 2 bytes contain the LLC specific control header information (1byte) which is specific to the underlying LAN standard and the actual SNAP header fields (1byte)&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Internet Protocol Introduction&nbsp;<br>###&nbsp;<br>&nbsp;<br>In the 1960&#039;s and 1970&#039;s the US Department of Defense (DoD) in conjunction with several universities established a workgroup to develop a standard communications system and universal protocols&#46; In 1980, the Defense Advanced Research Projects Agency (DARPA) was established&#46; It formed a group to develop the set of standards for the Internet called the Internet Configuration Control Board (ICCB) which became the Internet Activities Board in 1983, and they were tasked with designing, engineering, and managing the Internet&#46; TCP/IP was born out of this group&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IP Addressing&nbsp;<br>###&nbsp;<br>&nbsp;<br>The IP Address and Classes&nbsp;<br>&nbsp;<br>&#45;&#45; [Hosts and networks]&nbsp;<br>&nbsp;<br>IP addressing is based on the concept of &quot;hosts&quot; and &quot;networks&quot;&#46; A host is essentially any device on the network that is capable of receiving and transmitting IP packets such as a workstation or a router&#46; It is not to be confused with a server or a &quot;mainframe host&quot;&#46; Servers, mainframes and desktop workstations are all IP hosts&#46;&nbsp;<br>The hosts are connected together by one or more networks&#46; The IP address of any host consists of its network address plus its own host address on the network&#46; IP addressing uses one address number to represent both network and host address&#46;&nbsp;<br>&nbsp;<br>How much of the address is used for the network portion and how much for the host portion varies depending on the address &quot;Class&quot; and how they are individually configured from network to network (with or without subnetting&#46;)&nbsp;<br>&nbsp;<br>&#45;&#45; [IP addressing]&nbsp;<br>&nbsp;<br>The IP address is 32 bits or 4 bytes wide, and as discussed above, composed of two parts&#58; the network number, and the host number&#46; By convention, each byte in its binary value is expressed as four decimal numbers separated by periods, such as &quot;200&#46;1&#46;2&#46;3&quot; Each dotted group represents the decimal value of each of the four bytes&#46; Valid addresses thus range from 0&#46;0&#46;0&#46;0 to 255&#46;255&#46;255&#46;255 for a theoretical total of about 4&#46;3 billion addresses&#46;&nbsp;<br>The first few bits of the address number are known as the prefix and indicate the Class that the address belongs to&#58;&nbsp;<br>&nbsp;<br>Class &nbsp;Prefix &nbsp;&nbsp;&nbsp;Network Number Host Number&nbsp;<br>A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bits 1&#45;7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bits 8&#45;31&nbsp;<br>B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bits 2&#45;15 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bits 16&#45;31&nbsp;<br>C &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;110 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bits 3&#45;23 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bits 24&#45;31&nbsp;<br>D &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1110 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N/A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N/A&nbsp;<br>E &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N/A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N/A&nbsp;<br>&nbsp;<br>The bits are labeled in network order, so that the first bit is bit 0 and the last is bit 31, reading from left to right&#46;&nbsp;<br>&nbsp;<br>Class D addresses are multicast, and Class E are reserved&#46;&nbsp;<br>&nbsp;<br>The range of network numbers and host numbers may be derived from the above table&#58;&nbsp;<br>&nbsp;<br>&nbsp;<br>Class &nbsp;&nbsp;&nbsp;&nbsp;Range of Net Numbers &nbsp;&nbsp;&nbsp;Range of Host Numbers&nbsp;<br>A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 to 126 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&#46;0&#46;1 to 255&#46;255&#46;254&nbsp;<br>B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;128&#46;0 to 191&#46;255 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&#46;1 to 255&#46;254&nbsp;<br>C &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;192&#46;0&#46;0 to 233&#46;255&#46;255 &nbsp;1 to 254&nbsp;<br>&nbsp;<br>Any address starting with 127 is a loopback address and should never be used for addressing outside the host&#46; A host number of all binary 1&#039;s indicates a directed broadcast over the specific network&#46; For example, 200&#46;1&#46;2&#46;255 would indicate a broadcast over the 200&#46;1&#46;2 network&#46; If the host number is 0, it indicates &quot;this host&quot;&#46; If the network number is 0, it indicates &quot;this network&quot; &#46;&nbsp;<br>&nbsp;<br>All the reserved bits and reserved addresses severely reduce the available IP addresses from the 4&#46;3 billion theoretical maximum&#46; Most users connected to the Internet will be assigned addresses within Class C, as space is becoming very limited&#46; This is the primary reason for the development of IPv6, which will have 128 bits of address space&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IP Subnetting&nbsp;<br>###&nbsp;<br>&nbsp;<br>Subnetting is a process for splitting or dividing a single larger IP Class A, B, or C network into smaller pieces&#46; Subnetting was introduced to overcome some of the problems that parts of the Internet were beginning to experience with the two&#45;level class based addressing hierarchy of IP&#58;&nbsp;<br>&nbsp;<br>&#45; Internet routing tables were beginning to grow&#46;&nbsp;<br>&#45; Local administrators had to request another network number from the Internet before a new network could be installed at their site&#46;&nbsp;<br>&nbsp;<br>Subnetting addressed both of these problems by adding another level of hierarchy to the IP&nbsp;<br>addressing structure&#46; Subnetting created a three&#45;level hierarchy&#58;&nbsp;<br>&nbsp;<br>&#45; Network ID&nbsp;<br>&#45; Host Number&nbsp;<br>&#45; Subnet MASK&nbsp;<br>&nbsp;<br>The basic process of subnetting is to divide the standard IP host&#45;number field into two parts &#45; the subnet&#45;number and the host&#45;number on that subnet&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Subnet Address Hierarchy&nbsp;<br>##&nbsp;<br>&nbsp;<br>Subnetting helped the expanding routing table problem by ensuring that the subnet structure of a network is never visible outside of the organization&#039;s private network&#46; The route from the Internet to any subnet of a given IP address is the same, no matter which subnet the destination host is on&#46; This is because all subnets of a given network number use the same network&#45;prefix but different subnet numbers&#46; The routers within the private organization need to differentiate between the individual subnets, but as far as the Internet routers are concerned, all of the subnets in the organization are collected into a single routing table entry&#46; This allows the local administrator to utilize the three layer complexity of subnetting into the private network without affecting the size of the Internet&#039;s routing tables&#46;&nbsp;<br>&nbsp;<br>Subnetting helped the registered number issue by assigning each organization one (or at most a few) network number(s) from the IPv4 address space&#46; The organization is then free to assign a distinct subnetwork number for each of its internal networks&#46; This allows the organization to deploy additional subnets without needing to obtain a new network number from the Internet&#46;&nbsp;<br>&nbsp;<br>Example of how subnetting reduces the unique class address requirements&nbsp;<br>&nbsp;<br>The deployment of subnetting within the private network provides several benefits&#58;&nbsp;<br>&nbsp;<br>&#45; the size of the global Internet routing table does not grow because the site administrator does not need to obtain additional address space&nbsp;<br>&#45; the routing advertisements for all of the subnets are combined into a single routing table entry&#46;&nbsp;<br>&#45; the local administrator has the flexibility to deploy additional subnets without obtaining a new network number from the Internet&#46;&nbsp;<br>Route flapping (i&#46;e&#46;, the rapid changing of routes) within the private network does not affect the Internet routing table since Internet routers do not know about the reachability of the individual subnets&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Extended&#45;Network&#45;Prefix&nbsp;<br>###&nbsp;<br>&nbsp;<br>Internet routers use only the network&#45;prefix of the destination address to route traffic to a subnetted environment&#46; Routers within the subnetted environment use the extended&#45;network&#45; prefix to route traffic between the individual subnets&#46; The extended&#45;network&#45;prefix is composed of the class network&#45;prefix and the subnet&#45;number&#46;&nbsp;<br>&nbsp;<br>Extended&#45;Network&#45;Prefix&nbsp;<br>&nbsp;<br>The extended&#45;network&#45;prefix has traditionally been identified by the subnet mask&#46; For example, if you have the address of 130&#46;5&#46;0&#46;0 and you want to use the entire third octet to represent the subnet&#45;number, you need to specify a subnet mask of 255&#46;255&#46;255&#46;0&#46; The bits in the subnet mask and the Internet address have a one&#45;to&#45;one correspondence&#46; The bits of the subnet mask are set to 1 if the system examining the address should treat the corresponding bit in the IP address as part of the extended&#45;network&#45;prefix&#46; The bits in the mask are set to 0 if the system should treat the bit as part of the host&#45;number&#46;&nbsp;<br>&nbsp;<br>The prefix length is equal to the number of contiguous one&#45;bits in the traditional subnet mask&#46; This means that specifying the network address 130&#46;5&#46;5&#46;25 with a subnet mask of 255&#46;255&#46;255&#46;0 can also be expressed as 130&#46;5&#46;5&#46;25/24&#46; The /[prefix&#45;length] notation is more compact and easier to understand than writing out the mask in its traditional dotted&#45;decimal format&#46;&nbsp;<br>&nbsp;<br>It is important to note that modern routing protocols carry the subnet mask&#46; There are no Internet standard routing protocols that have a one&#45;byte field in their header that contains the number of bits in the extended&#45;network prefix&#46; Rather, each routing protocol is still required to carry the complete four&#45;octet subnet mask&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Subnet Design Considerations&nbsp;<br>##&nbsp;<br>&nbsp;<br>The deployment of an addressing plan requires careful thought on the part of the network administrator&#46; There are four key questions that must be answered before any design should be undertaken&#58;&nbsp;<br>&nbsp;<br>1) How many total subnets does the organization need today?&nbsp;<br>2) How many total subnets will the organization need in the future?&nbsp;<br>3) How many hosts are there on the organization&#039;s largest subnet today?&nbsp;<br>4) How many hosts will there be on the organization&#039;s largest subnet in the future?&nbsp;<br>&nbsp;<br>The first step in the planning process is to take the maximum number of subnets required&nbsp;<br>and round up to the nearest power of two&#46; For example, if a organization needs 9 subnets, 2^3 (or 8) will not provide enough subnet addressing space, so the network administrator will need to round up to 2^4 (or 16)&#46;&nbsp;<br>&nbsp;<br>When performing this assessment, it is critical that the network administrator also allow for adequate future growth&#46; For example, if 14 subnets are required today, then 16 subnets might not be enough in three years&#46;&nbsp;<br>&nbsp;<br>The next step is to make sure that there are enough host addresses for the organization&#039;s largest subnet&#46; If the largest subnet needs to support 50 host addresses today, 2^5 (or 32) will not provide enough host address space so the network administrator will need to round up to 2^6 (or 64)&#46;&nbsp;<br>&nbsp;<br>The final step is to make sure that the organization&#039;s address allocation provides enough bits to deploy the required subnet addressing plan&#46; For example, if the organization has a single /16, it could easily deploy 4&#45;bits for the subnet&#45;number and 6&#45;bits for the host number&#46; However, if the organization has several /24s and it needs to deploy 9 subnets, it may be required to subnet each of its /24s into four subnets (using 2 bits) and then build the Internet by combining the subnets of 3 different /24 network numbers&#46; An alternative solution, would be to deploy network numbers from the private address space&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Other Considerations&nbsp;<br>##&nbsp;<br>&nbsp;<br>RIP&#45;1 Permits Only a Single Subnet Mask&#46; When using RIP&#45;1, subnet masks have to be uniform across the entire network&#45;prefix&#46; RIP&#45;1 allows only a single subnet mask to be used within each network number because it does not provide subnet mask information as part of its routing table update messages&#46; In the absence of this information, RIP&#45;1 is forced to make very simple assumptions about the mask that should be applied to any of its learned routes&#46;&nbsp;<br>&nbsp;<br>How does a RIP&#45;1 based router know what mask to apply to a route when it learns a&nbsp;<br>new route from a neighbor?&nbsp;<br>&nbsp;<br>If the router has a subnet of the same network number&nbsp;<br>assigned to a local interface, it assumes that the learned subnetwork was defined using&nbsp;<br>the same mask as the locally configured interface&#46; However, if the router does not have a&nbsp;<br>subnet of the learned network number assigned to a local interface, the router has to&nbsp;<br>assume that the network is not subnetted and applies the route&#039;s natural classful mask&#46;&nbsp;<br>&nbsp;<br>How does a RIP&#45;1 based router know if it should include the subnet&#45;number bits in a&nbsp;<br>routing table update to a RIP&#45;1 neighbor?&nbsp;<br>&nbsp;<br>A router executing RIP&#45;1 will only advertise the subnet&#45;number bits on another port if the update port is configured with a subnet of the same network number&#46; If the update port is configured with a different subnet or network number, the router will only advertise the network portion of the subnet route and &quot;zero&#45;out&quot; the subnet&#45;number field&#46; For example, assume that Port 1 of a router has been assigned the IP address 130&#46;24&#46;13&#46;1/24 and that Port 2 has been assigned the IP address 200&#46;14&#46;13&#46;2/24&#46; Also, assume that the router has learned about network 130&#46;24&#46;36&#46;0 from a neighbor&#46; Since Port 1 is configured with another subnet of the 130&#46;24&#46;0&#46;0 network, the router assumes that network 130&#46;24&#46;36&#46;0 has a /24 subnet mask&#46; When it comes to advertise this route, it advertises 130&#46;24&#46;36&#46;0 on Port 1, but it only advertises 130&#46;24&#46;0&#46;0 on Port 2&#46;&nbsp;<br>&nbsp;<br>For these reasons, RIP&#45;1 is limited to only a single subnet mask for each network number&#46; However, there are several advantages to be gained if more than one subnet mask can be assigned to a given IP network number&#58;&nbsp;<br>&nbsp;<br>&#45; Multiple subnet masks permit more efficient use of an organization&#039;s assigned IP address space&#46;&nbsp;<br>&#45; Multiple subnet masks permit route aggregation which can significantly reduce the amount of routing information at the &quot;backbone&quot; level within an organization&#039;s routing domain&#46;&nbsp;<br>&nbsp;<br>VLSM supports more efficient use of an organization&#039;s assigned IP address space&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;IPv6 &#45; The Next generation of IP&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45;&#45; [Introduction]&nbsp;<br>&nbsp;<br>IPng was recommended by the IPng Area Directors of the Internet Engineering Task Force&#46; It is documented in RFC 1752, &quot;The Recommendation for the IP Next Generation Protocol&quot; (July 25, 1994)&#46; The recommendation was approved by the Internet Engineering Steering Group and made a Proposed Standard on November 17, 1994 &#46;&nbsp;<br>&nbsp;<br>The formal name of this protocol is IPv6 where the &quot;6&quot; refers to it being assigned version number 6&#46; The current version of the Internet Protocol is version 4 (referred to as IPv4)&#46;&nbsp;<br>&nbsp;<br>IPv6 is a new version of IP which is designed to be an evolutionary step from IPv4&#46; It is a natural increment to IPv4&#46; It can be installed as a normal software upgrade in Internet devices and is interoperable with the current IPv4&#46; IPv6 is designed to run well on high performance networks (e&#46;g&#46;, ATM) and at the same time is still efficient for low bandwidth networks (e&#46;g&#46;, wireless)&#46; In addition, it provides a platform for new Internet functionality that will be required in the future&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Key Issues]&nbsp;<br>There are several key issues that should be considered when reviewing the design of the next generation Internet protocol&#46; Some are very straightforward&#46; For example the new protocol must be able to support large global internetworks&#46; Others are less obvious&#46; There must be a clear way to transition the current large installed base of IPv4 systems&#46; It doesn&#039;t matter how good a new protocol is if there isn&#039;t a practical way to transition the current operational systems running IPv4 to the new protocol&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Growth]&nbsp;<br>&nbsp;<br>Growth is the basic issue which caused there to be a need for a next generation IP&#46; Our experience with IPv4 it is that the addressing and routing must be capable of handling reasonable scenarios of future growth&#46; It is important that we have an understanding of the past growth and where the future growth will come from&#46;&nbsp;<br>&nbsp;<br>Currently IPv4 serves what could be called the computer market&#46; The computer market has been the driver of the growth of the Internet&#46; It comprises the current Internet and countless other smaller intranets which are not connected to the Internet&#46; Its focus is to connect computers together in the large business, government, and university education markets&#46; This market has been growing at an exponential rate&#46; The computers which are used at the endpoints of Internet communications range from PC&#039;s to Supercomputers&#46; Most are attached to Local Area Networks (LANs) and the vast majority are becoming more mobile&#46;&nbsp;<br>&nbsp;<br>The next phase of growth will probably not be driven by the computer market&#46; While the computer market will continue to grow at significant rates due to expansion into other areas such as schools (elementary through high school) and small businesses, it is doubtful it will continue to grow at an exponential rate&#46; What is likely to happen is that other kinds of markets will develop&#46; These markets will fall into several areas&#46; They all have the characteristic that they are extremely large&#46; They also bring with them a new set of requirements which were not as evident in the early stages of IPv4 deployment&#46; The new markets are also likely to happen in parallel with one another&#46;&nbsp;<br>&nbsp;<br>It may turn out that we will look back on the last ten years of Internet growth as the time when the Internet was small and only doubling every year&#46; The challenge for an IPv6 is to provide a solution which solves today&#039;s problems and is attractive in these emerging markets&#46;&nbsp;<br>&nbsp;<br>Nomadic personal computing devices are proliferating as their prices drop and their capabilities increase&#46; A key capability is that they will are networked&#46; Unlike the majority of today&#039;s networked computers they will support a variety of types of network attachments&#46; When disconnected they use RF wireless networks, when used in networked facilities they can use infrared or WiFi attachment, and when docked they may use physical wires&#46; This makes them an ideal candidate for internetworking technology as they will need a common protocol which can work over a variety of physical networks&#46; These types of devices are general consumer devices and will replace the current generation of cellular phones, pagers, and personal digital assistants over time, or the features integrated into tablets and other general purpose devices that may serve as all of these&#46; In addition to the obvious requirement of an Internet protocol which can support large scale routing and addressing, they require an Internet protocol which imposes a low overhead and supports auto configuration and mobility as a basic element&#46; The nature of nomadic computing requires an Internet protocol to have built in authentication and confidentiality&#46; It also goes without saying that these devices will need to communicate with the current generation of computers&#46; The requirement for low overhead comes from the wireless media&#46;&nbsp;<br>&nbsp;<br>Unlike LAN&#039;s which will be always increasing and very high speed, the wireless media will typically always be several orders of magnitude slower due to constraints on available frequencies, spectrum allocation, error rates, and power consumption&#46;&nbsp;<br>&nbsp;<br>Another market is networked entertainment&#46; This emerging market has new proposals being discussed for 500 channels of television, video on demand, etc&#46; This is clearly a consumer market&#46; The possibility is that every television set will become an Internet host&#46; As the world of only digital high definition television approaches, the differences between a computer and a television will diminish&#46; As in the previous market, this market will require an Internet protocol which supports large scale routing and addressing, and auto configuration&#46; This market also requires a protocol suite which imposes the minimum overhead to get the job done&#46; Cost will be the major factor in the selection of an appropriate technology&#46;&nbsp;<br>&nbsp;<br>Another market which could use the next generation IP is device control&#46; This consists of the control of everyday devices such as lighting equipment, heating and cooling equipment, motors, and other types of equipment which are currently controlled via analog switches and in aggregate consume considerable amounts of electrical power&#46; The size of this market is enormous and requires solutions which are simple, robust, easy to use, and very low cost&#46; The potential pay&#45;back is that networked control of devices will result in cost savings which are extremely large&#46;&nbsp;<br>&nbsp;<br>The challenge the IETF faced in the selection of an IPng is to pick a protocol which meets today&#039;s requirements and also matches the requirements of these emerging markets&#46; These markets will happen with or without an IETF IPng&#46; If an IETF IPng is a good match for these new markets it is likely to be used&#46; If not, these markets will develop something else&#46; They will not wait for an IETF solution&#46; If this should happen it is probable that because of the size and scale of the new markets the IETF protocol would be supplanted&#46; If the IETF IPng is not appropriate for use in these markets, it is also probable that they will each develop their own protocols, perhaps proprietary&#46; The result of the development of the protocols and the design has been a settling on IPv6 as the appropriate IPng that has gained traction&#46; While adoption has been slow, there is a fair amount of deployment in Japan and other countries, and it is slowly becoming more common with the backbone of the US networks and almost all modern OS versions have IPv6 support standard&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Transition&nbsp;<br>##&nbsp;<br>&nbsp;<br>Slowly, we are seeing a conversion and adoption of IPv6, starting with the core networks and working their way out to the end systems over time&#46; Two factors are driving this&#58; routing and addressing&#46; Global Internet routing based on the on 32&#45;bit addresses of IPv4 is becoming increasingly strained, although a large amount of the pressure was relieved with widespread use of NAT (Network Address Translation), which allowed more sparing use of IPv4 addresses for public facing interfaces, but allowed internal systems in corporate and home networks to use private, non&#45;routable IP ranges&#46; IPv4 address do not provide enough flexibility to construct efficient hierarchies which can be aggregated, and while the deployment of Classless Inter&#45; Domain Routing has extended the life time of IPv4 routing by years, the effort to manage the routing will continue to be strained&#46; Even if the IPv4 routing can be scaled to support a full IPv4 Internet, the Internet will eventually run out of network numbers&#46; There is no question that an IPv6 is needed, but only a question of when&#46;&nbsp;<br>&nbsp;<br>The challenge for an IPv6 is for its transition to be complete before IPv4 routing and addressing break&#46; The transition will be much easier if IPv4 address are still globally unique&#46; The two transition requirements which are the most important are flexibility of deployment and the ability for IPv4 hosts to communicate with IPv6 hosts&#46; There will be IPv6&#45; only hosts, just as there will be IPv4&#45;only hosts&#46;&nbsp;<br>&nbsp;<br>The capability must exist for IPv6&#45;only hosts to communicate with IPv4&#45;only hosts globally while IPv4 addresses are globally unique&#46; The deployment strategy for an IPv6 must be as flexible as possible&#46; The Internet is too large for any kind of controlled roll out to be successful&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IPv6 Overview&nbsp;<br>#&nbsp;<br>&nbsp;<br>IPv6 was designed to take an evolutionary step from IPv4&#46; Functions which work in IPv4 were kept in IPv6&#46; Functions which didn&#039;t work were removed&#46; The changes from IPv4 to IPv6 relate mostly to expanded Routing and Addressing capabilities&#46;&nbsp;<br>&nbsp;<br>IPv6 increases the IP address size from 32 bits to 128 bits to support more levels of addressing hierarchy and a much greater number of addressable nodes and simpler auto&#45;configuration of addresses&#46;&nbsp;<br>&nbsp;<br>The scalability of multicast routing is improved by adding a &quot;scope&quot; field to multicast addresses&#46;&nbsp;<br>A new type of address called a &quot;anycast address&quot; is defined, to identify sets of nodes where a packet sent to an anycast address is delivered to one of the nodes&#46; The use of anycast addresses in the IPv6 source route allows nodes to control the path which their traffic flows&#46;&nbsp;<br>&nbsp;<br>[Header Format Simplification]&nbsp;<br>&nbsp;<br>Some IPv4 header fields have been dropped or made optional, to reduce the common&#45;case processing cost of packet handling and to keep the bandwidth cost of the IPv6 header as low as possible despite the increased size of the addresses&#46; Even though the IPv6 addresses are four times longer than the IPv4 addresses, the IPv6 header is only twice the size of the IPv4 header&#46;&nbsp;<br>&nbsp;<br>[Improved Support for Options]&nbsp;<br>&nbsp;<br>Changes in the way IP header options are encoded allows for more efficient forwarding, less stringent limits on the length of options, and greater flexibility for introducing new options in the future&#46;&nbsp;<br>&nbsp;<br>[Quality&#45;of&#45;Service Capabilities]&nbsp;<br>&nbsp;<br>A new capability is added to enable the labeling of packets belonging to particular traffic &quot;flows&quot; for which the sender requests special handling, such as non&#45;default quality of service or &quot;real&#45; time&quot; service&#46;&nbsp;<br>&nbsp;<br>[Authentication and Privacy Capabilities]&nbsp;<br>&nbsp;<br>IPv6 includes the definition of extensions which provide support for authentication, data integrity, and confidentiality&#46; This is included as a basic element of IPv6 and will be included in all implementations&#46; The IPv6 protocol consists of two parts, the basic IPv6 header and IPv6 extension headers&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IPv6 Extensions&nbsp;<br>#&nbsp;<br>&nbsp;<br>IPv6 includes an improved option mechanism over IPv4&#46; IPv6 options are placed in separate extension headers that are located between the IPv6 header and the transport&#45;layer header in a packet&#46; Most IPv6 extension headers are not examined or processed by any router along a packet&#039;s delivery path until it arrives at its final destination&#46; This facilitates a major improvement in router performance for packets containing options&#46; In IPv4 the presence of any options requires the router to examine all options&#46;&nbsp;<br>&nbsp;<br>The other improvement is that unlike IPv4 options, IPv6 extension headers can be of arbitrary length and the total amount of options carried in a packet is not limited to 40 bytes&#46; This feature plus the manner in which they are processed, permits IPv6 options to be used for functions which were not practical in IPv4&#46; A good example of this is the IPv6 Authentication and Security Encapsulation options&#46;&nbsp;<br>&nbsp;<br>The IPv6 extension headers which are currently defined are&#58;&nbsp;<br>&#45; Routing&nbsp;<br>&#45; Extended Routing (like IPv4 loose source route)&#46;&nbsp;<br>&#45; Fragmentation&nbsp;<br>&#45; Fragmentation and Re&#45;assembly&#46;&nbsp;<br>&#45; Authentication&nbsp;<br>&#45; Integrity and Authentication&#46; Security&nbsp;<br>&#45; Encapsulation&nbsp;<br>&#45; Confidentiality&#46;&nbsp;<br>&#45; Hop&#45;by&#45;Hop Option (Special options which require hop by hop processing&#46;)&nbsp;<br>&#45; Destination Options (Optional information to be examined by the destination node&#46;)&nbsp;<br>&nbsp;<br>note&#58; IPv4 can encapsulate IPv6 packets (aka tunnel)&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IPv6 Addressing&nbsp;<br>#&nbsp;<br>&nbsp;<br>IPv6 addresses are 128&#45;bits long and are identifiers for individual interfaces and sets of interfaces&#46;&nbsp;<br>IPv6 Addresses of all types are assigned to interfaces, not nodes&#46; Since each interface belongs to a single node, any of that node&#039;s interfaces&#039; unicast addresses may be used as an identifier for the node&#46; A single interface may be assigned multiple IPv6 addresses of any type&#46;&nbsp;<br>&nbsp;<br>There are three types of IPv6 addresses&#46; These are unicast, anycast, and multicast&#46; Unicast addresses identify a single interface&#46; Anycast addresses identify a set of interfaces such that a packet sent to a anycast address will be delivered to one member of the set&#46; Multicast addresses identify a group of interfaces, such that a packet sent to a multicast address is delivered to all of the interfaces in the group&#46; There are no broadcast addresses in IPv6, their function being superseded by multicast addresses&#46;&nbsp;<br>&nbsp;<br>IPv6 supports addresses which are four times the number of bits as IPv4 addresses (128 vs&#46; 32)&#46; This is 4 Billion times 4 Billion (2^^96) times the size of the IPv4 address space (2^^32)&#46; This works out to be&#58;&nbsp;<br>&nbsp;<br>340,282,366,920,938,463,463,374,607,431,768,211,456&nbsp;<br>&nbsp;<br>This is an extremely large address space&#46;&nbsp;<br>&nbsp;<br>The assignment and routing of addresses requires the creation of hierarchies which reduces the efficiency of the usage of the address space&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IPv6 Routing&nbsp;<br>#&nbsp;<br>&nbsp;<br>Routing in IPv6 is almost identical to IPv4 routing under CIDR except that the addresses are 128&#45; bit IPv6 addresses instead of 32&#45;bit IPv4 addresses&#46; With very straightforward extensions, all of IPv4&#039;s routing algorithms (OSPF, RIP, IDRP, ISIS, etc&#46;) can used to route IPv6&#46;&nbsp;<br>&nbsp;<br>IPv6 also includes simple routing extensions which support powerful new routing functionality&#46; These capabilities include&#58;&nbsp;<br>&nbsp;<br>&#45; Provider Selection (based on policy, performance, cost, etc&#46;)&nbsp;<br>&#45; Host Mobility (route to current location)&nbsp;<br>&#45; Auto&#45;Readdressing (route to new address)&nbsp;<br>&nbsp;<br>The new routing functionality is obtained by creating sequences of IPv6 addresses using the IPv6 Routing option&#46; The routing option is used by a IPv6 source to list one or more intermediate nodes (or topological group) to be &quot;visited&quot; on the way to a packet&#039;s destination&#46; This function is very similar in function to IPv4&#039;s Loose Source and Record Route option&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IPv6 Quality&#45;of&#45;Service Capabilities&nbsp;<br>#&nbsp;<br>&nbsp;<br>The Flow Label and the Priority fields in the IPv6 header may be used by a host to identify those packets for which it requests special handling by IPv6 routers, such as non&#45;default quality of service or &quot;real&#45;time&quot; service&#46; This capability is important in order to support applications which require some degree of consistent throughput, delay, and/or jitter&#46; These type of applications are commonly described as &quot;multi&#45; media&quot; or &quot;real&#45;time&quot; applications&#46;&nbsp;<br>&nbsp;<br>[Priority]&nbsp;<br>&nbsp;<br>The 4&#45;bit Priority field in the IPv6 header enables a source to identify the desired delivery priority of its packets, relative to other packets from the same source&#46; The Priority values are divided into two ranges&#58; Values 0 through 7 are used to specify the priority of traffic for which the source is providing congestion control, i&#46;e&#46;, traffic that &quot;backs off&quot; in response to congestion, such as TCP traffic&#46; Values 8 through 15 are used to specify the priority of traffic that does not back off in response to congestion, e&#46;g&#46;, &quot;real&#45;time&quot; packets being sent at a constant rate&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IPv6 Security&nbsp;<br>#&nbsp;<br>&nbsp;<br>The current Internet has a number of security problems and lacks effective privacy and authentication mechanisms below the application layer&#46; IPv6 remedies these shortcomings by having two integrated options that provide security services&#46; These two options may be used singly or together to provide differing levels of security to different users&#46; This is very important because different user communities have different security needs&#46;&nbsp;<br>&nbsp;<br>The first mechanism, called the &quot;IPv6 Authentication Header&quot;, is an extension header which provides authentication and integrity (without confidentiality) to IPv6 datagrams&#46; While the extension is algorithm&#45; independent and will support many different authentication techniques, the use of keyed MD5 is proposed to help ensure interoperability within the worldwide Internet&#46; This can be used to eliminate a significant class of network attacks, including host masquerading attacks&#46; The use of the IPv6 Authentication Header is particularly important when source routing is used with IPv6 because of the known risks in IP source routing&#46; Its placement at the Internet layer can help provide host origin authentication to those upper layer protocols and services that currently lack meaningful protections&#46;&nbsp;<br>&nbsp;<br>This mechanism should be exportable by vendors in the United States and other countries with similar export restrictions because it only provides authentication and integrity, and specifically does not provide confidentiality&#46; The exportability of the IPv6 Authentication Header encourages its widespread deployment and use&#46;&nbsp;<br>&nbsp;<br>The second security extension header provided with IPv6 is the &quot;IPv6 Encapsulating Security Header&quot; &#46; This mechanism provides integrity and confidentiality to IPv6 datagrams&#46; It is simpler&nbsp;<br>than some similar security protocols (e&#46;g&#46;, SP3D, ISO NLSP) but remains flexible and algorithm&#45;independent&#46; To achieve interoperability within the global Internet, the use of DES CBC is being used as the standard algorithm for use with the IPv6 Encapsulating Security Header&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Transition Mechanisms&nbsp;<br>#&nbsp;<br>&nbsp;<br>The key transition objective is to allow IPv6 and IPv4 hosts to interoperate&#46; A second objective is to allow IPv6 hosts and routers to be deployed in the Internet in a highly diffuse and incremental fashion, with few interdependencies&#46; A third objective is that the transition should be as easy as possible for end&#45; users, system administrators, and network operators to understand and carry out&#46;&nbsp;<br>&nbsp;<br>The IPv6 transition mechanisms are a set of protocol mechanisms implemented in hosts and routers, along with some operational guidelines for addressing and deployment, designed to make transition the Internet to IPv6 work with as little disruption as possible&#46;&nbsp;<br>&nbsp;<br>note&#58; regarding &quot;hardware&quot; compatibility, yes IPv6 is just a protocol so any HW that can run IPv4 should be in theory able to run IPv6 because L3 protocl is really dependent on firmware/software but in reality firmware/software may be coupled with HW when it comes to routers/computers so it is not quite correct to say &quot;any HW that currently runs IPv4 can run IPv6&quot;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Summary&nbsp;<br>#&nbsp;<br>&nbsp;<br>There are a number of reasons why IPv6 is appropriate for the next generation of the Internet Protocol&#46; It solves the Internet scaling problem, provides a flexible transition mechanism for the current Internet, and was designed to meet the needs of new markets such as nomadic personal computing devices, networked entertainment, and device control&#46; It does this in a evolutionary way which reduces the risk of architectural problems&#46;&nbsp;<br>&nbsp;<br>IPv6 is designed to interoperate with IPv4&#46; Specific mechanisms (embedded IPv4 addresses, pseudo&#45; checksum rules etc&#46;) were built into IPv6 to support transition and compatibility with IPv4&#46; It was designed to permit a gradual and piecemeal deployment with a minimum of dependencies&#46;&nbsp;<br>&nbsp;<br>IPv6 supports large hierarchical addresses which will allow the Internet to continue to grow and&nbsp;<br>provide new routing capabilities not built into IPv4&#46; It has anycast addresses which can be used for policy route selection and has scoped multicast addresses which provide improved scalability over IPv4 multicast&#46; It also has local use address mechanisms which provide the ability for &quot;plug and play&quot; installation&#46;&nbsp;<br>&nbsp;<br>The address structure of IPv6 was also designed to support carrying the addresses of other Internet protocol suites&#46; Space was allocated in the addressing plan for IPX and NSAP addresses&#46; This was done to facilitate migration of these Internet protocols to IPv6&#46;&nbsp;<br>&nbsp;<br>IPv6 provides a platform for new Internet functionality&#46; This includes support for real&#45;time flows,&nbsp;<br>provider selection, host mobility, end&#45;to&#45; end security, auto&#45;configuration, and auto&#45;reconfiguration&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Internetworking networks&nbsp;<br>###&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Introduction&nbsp;<br>#&nbsp;<br>&nbsp;<br>In the early 1980s LANs were strictly local area networks that is a mechanism to link small contiguous groups of computers in company departments&#46; As these department LANs proliferated within these companies, users began connecting them together to allow inter&#45;department communications and resource sharing&#46; This gave birth to LAN internetworks&#46; Initially these were strictly data link layer (bridged) internetworks&#46; As the geographical boundaries of the interconnected departments expanded more complexity in the form of multiple and alternate paths and public network components (WANs) required internetworking to move beyond the data link layer into the network layer&#46; While this provided communication capability for LAN based end devices, many companies still had additional network infrastructure to support their traditional, non LAN based computing environment, i&#46;e&#46;, their mainframe and/or supermini computing networks&#46; Since these were based on a proprietary network architecture and standards they were not readily adaptable to the LAN intermediary and end devices&#46; The desire to merge two totally different network architectures into a single interconnected physical environment gave birth to network &quot;gateways&#46;&quot;&nbsp;<br>&nbsp;<br>In class # 1 we discussed how LANs can be thought of from two perspectives&#58;&nbsp;<br>&nbsp;<br>&#45; From a data link technology perspective&nbsp;<br>&#45; From a networking software perspective&nbsp;<br>&nbsp;<br>When we talk about internetworking we can also think of the process from two similar perspectives&#46;&nbsp;<br>&nbsp;<br>&#45; From a physical componentry perspective&nbsp;<br>&#45; From a logical software perspective&nbsp;<br>&nbsp;<br>The logical software perspective is often referred to as &quot;Interoperability&quot; rather than internetworking&#46; Neither the physical or logical perspective falls neatly into either of these labels&#46; Physical components like routers also include network layer software necessary for them to provide internetworking&#46; Middleware products like those based on CORBA or DCE standards provide networked systems interoperability but are not network standards&#46; Finally Gateways combine both hardware and software to provide interoperability&#46;&nbsp;<br>&nbsp;<br>For purposes of this course, Internetworking from a physical perspective will refer to network interconnection devices such as Bridges, Routers and Switches/Hubs&#46; Internetworking from a logical perspective will refer to the process for supporting multiple network layer protocols and the mechanisms for handling higher layer information across dissimilar layer three protocols&#46;&nbsp;<br>&nbsp;<br>This class will focus on internetworking from a logical perspective&#46; The next class will focus on the physical perspective&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Internetworking from a Logical Perspective&nbsp;<br>##&nbsp;<br>&nbsp;<br>Internetworking is ability to send messages from one network segment (data link layer) to another&#46; Along with congestion control and routing, internetworking is a important function of the network layer&#46; Internetworking has added complexities in addition to those associatesd with single network routing&#46; There is the added problem of understanding how to reach many different networks to get to the network we want and the bigger problem of encountering different protocols on those networks&#46; There are many methods of internetworking&#46; Which one(s) are used depends on what higher layer services need to be supported and how much control one has over the entire network path from end to end&#46;&nbsp;<br>&nbsp;<br>Logical internetworking is addressed from two interdependent perspectives&#58;&nbsp;<br>&nbsp;<br>&#45; The protocols and protocol encapsulation/resolution capabilities of intermediary network devices&#46;&nbsp;<br>&#45; The protocols and protocol translation capabilities supported within the end devices&#46;&nbsp;<br>&nbsp;<br>It is important to recognize that the selection of which protocol to use is made by the application on the originating station, and unlike MAC layer protocols, must also be utilized by the ultimate receiving station as well&#46; In other words, an IP packet can be sent from a station on Ethernet to a destination station on Token Ring or FDDI&#46; The destination station does not have to be on Ethernet&#46; The destination station does however have to be running IP since the LLC will identify the IP SNAP address and attempt to call the IP program stack&#46;&nbsp;<br>&nbsp;<br>It is also important to recognize that any intermediary networks in the path between the originating and receiving station do not necessarily have to utilize the same protocol&#46; Techniques can be employed to allow the original protocol information to be preserved and transported across a different network and restored to its original protocol format when processed on the receiving stations network&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Network Protocol Tunneling&nbsp;<br>##&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;What is Tunneling ?&nbsp;<br>#&nbsp;<br>&nbsp;<br>Tunneling is the technique of &quot;wrapping&quot; a packet generated by one protocol inside a packet generated by a different protocol and sending it across the network based on the (second) outside protocol&#46; When the packet reaches the router at the destination networks edge that supports both protocols the router strips off the secondary header, leaving the original protocol packet which is then placed on the destination network&#46; In this manner, workstations and servers on different networks interconnected by alternate protocols can see each other &#46; There is a performance penalty compared to end to end native transmissions&#46;&nbsp;<br>&nbsp;<br>The &quot;wrapping&quot; and &quot;unwrapping&quot; (or more formally known as encapsulation and decapsulation) can be supported within an end device like a server as well as within an intermediary device like a router&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;IP Tunneling of IPX&nbsp;<br>#&nbsp;<br>&nbsp;<br>IP Tunneling is the act of wrapping an IPX packet inside an IP packet and sending it to the closest IP router&#46; This IP router then routes the packet to a destination IP router that strips off the IP header, leaving a native IPX packet on the destination network&#46;&nbsp;<br>&nbsp;<br>There are two ways to set up IP tunneling of IPX&#58;&nbsp;<br>&nbsp;<br>1&#46; workstation&#45;to&#45;server&nbsp;<br>2&#46; server&#45;to&#45;server&nbsp;<br>&nbsp;<br>Workstation&#45;to&#45;Server IP Tunnel allows a NetWare workstation to tunnel to a NetWare server on another network, even if there is no NetWare server on the workstation&#039;s local network&#46;&nbsp;<br>&nbsp;<br>Server&#45;to&#45;Server IP Tunnel sets up a tunnel between two NetWare servers that will allow IPX workstations attached to either server to see the remote server on the other end of the tunnel&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Predominant Usage of Tunneling&nbsp;<br>#&nbsp;<br>&nbsp;<br>While tunneling can be used in local area internetworking, it is most often used in wide area network interconnections of local area networks&#46; IP can be &quot;tunnelled&quot; over a Frame Relay or ATM network with the edge device routers stripping away the Frame Relay packets or re&#45;assembling the ATM cells&#46; This IP packet in turn could have encapsulated an IPX packet to be delivered to a local Netware workstation or server&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Virtual Private Networks&nbsp;<br>#&nbsp;<br>&nbsp;<br>Virtual Private Networks, or VPNs√Ç implement tunnelling to allow clients to have a secure connection from an end system to an otherwise firewalled√Ç or secure network&#46; This allows your local endpoint to be able to create a tunnel through the public internet√Ç to a VPN gateway that is running in the target network&#46; The VPN client performs a handshake and authentication with the gateway, and then established a connection along with IP routes that make sure that addresses on the remote network would be routed through the tunnel&#46; These tunnels are usually just IP packets tunnelled√Ç inside another IP packet &#45; where the outer IP packet is used to move the encrypted data through the public internet to the VPN gateway and back to the end station&#46; This is useful for connecting from public places like coffee shops that may be insecure&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Multiple Protocol Support&nbsp;<br>###&nbsp;<br>&nbsp;<br>In the previous section tunneling addressed the problem of moving packets across networks where a different protocol than that used by the two end devices sits along the routing path&#46; This does not however address the issue of how to support another application on the end devices that uses a different, additional protocol&#46; As stated in the introduction section of this class, it is the application that determines the protocol to use&#46; If applications requiring different protocols are used on the same end station, then that end station must be able to support all those protocols either directly or indirectly&#46; Each protocol directly supported must be capable of being loaded and run on the supporting device&#46; These programs are often referred to as the &quot;protocol stacks&quot;&#46; This is distinct and different from tunnelling &#45; which does not need to understand the protocol being tunnelled at all, due to the encapsulation in a native protocol that can be directed through the normal means&#46; While this is one mechanism that was used &#45; you will rarely, if ever, see this in production today&#46; This is shown to illustrate the challenge of handling interoperability, and one solution that was put in place early on&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Supporting Multiple Protocol Stacks&nbsp;<br>##&nbsp;<br>&nbsp;<br>There are three ways that multiple protocol stacks can be supported&#58;&nbsp;<br>&nbsp;<br>&#45; In the Client&nbsp;<br>&#45; In a Server&nbsp;<br>&#45; Through a Gateway&nbsp;<br>&nbsp;<br>Each implementation has its positives and negatives and provides a different set of capabilities&#46; Which one to use is a factor of the requirements of the specific user&#039;s desktop applications&#46; The following diagrams help to describe these three above options and will be referenced in the descriptions of these three options that follows&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Multiple Protocol Stacks in the Client&nbsp;<br>##&nbsp;<br>&nbsp;<br>Today, the most common way for supporting multiple protocols is to have those protocols installed on every end device that requires them&#46; Even this is rare, because IP has become ubiquitous&#46; This was not always the case; especially where PC clients were concerned&#46; Memory restrictions on old DOS/Intel PC&#039;s limited the available memory for loading TSR (Terminate and Stay Resident) programs often restricting use to a single protocol&#46; The replacement of DOS as the PC operating systems and the advent of virtual drivers that could load and operate in extended memory alleviated this restriction&#46; A second major improvement in all end devices was the replacement of &quot;static&quot; LLC stack managers with &quot;Dynamic&quot; managers&#46; Static managers required that all protocols be bound to the network device and loaded into the stack memory register at boot time&#46; This meant that all the protocols had to be loaded and in a &quot;callable&quot; state even if they were not used&#46; Dynamic manages allowed the boot bindings to occur but dynamically link the protocol libraries only when needed&#46; This freed up stack register and environment space for other programs&#46;&nbsp;<br>&nbsp;<br>In the client, both protocols are controlled by the LLC which has bound both to the MAC layer of the NIC&#46; For outgoing messages the higher layer application makes its call to the appropriate lower layer protocol&#46; For example, the browser application on the client makes a call to TCP/IP to connect to a Web Server&#46; A file print command from that browser to print the web page to a network printer invokes the Netware client module to call SPX/IPX to send the print file to the print queue on the Netware server&#46;&nbsp;<br>&nbsp;<br>At the network layer, the IP or IPX packet will be constructed with the appropriate destination address inserted as determined by the higher layer application&#46; The LLC Encodes the appropriate SNAP address and passes the information down to the MAC layer for frame encapsulation and transmission&#46;&nbsp;<br>&nbsp;<br>The mechanism for determining the network layer destination address is specific to the protocol being used&#46; This process is described in a later section of this weeks class (Naming Services)&#46; This allows the client to use more than one protocol&#46;&nbsp;<br>&nbsp;<br>The advantage of this approach is that multiple protocol clients can support and run applications designed or configured for any of the installed protocols&#46; Some applications can only use a specific underlying protocol and therefore, cannot be loaded on the client unless the underlying protocol is also loaded&#46; Any applications that can access the Internet like FTP or PING for example must use the IP protocol&#46;&nbsp;<br>&nbsp;<br>The disadvantage of this approach is a more complex client configuration and more complicated routing tables in intermediary devices to support all the client installed protocols&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Multiple protocol stacks in a server&nbsp;<br>##&nbsp;<br>&nbsp;<br>A second way to support multiple protocols is within a server&#46;&nbsp;<br>&nbsp;<br>The advantage of this approach is that it simplifies the client configurations necessary to communicate with the server&#46; While it cannot facilitate the end to end communications of two devices with dissimilar protocols it can resource access and sharing to provide indirect communication&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>The disadvantage of this approach is that client can only run programs designed or configured for their specific, installed protocol&#46; The other disadvantage of this approach is the added complexity of the multi protocol configured server&#46; The danger is allowing these multi protocol servers to act as routers in addition to their intended primary purpose&#46; This routing can drain server resources and slow performance of the primary functions&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Multiple protocol support through gateways&nbsp;<br>##&nbsp;<br>&nbsp;<br>A third way to support multiple protocols is through a gateway&#46; A gateway is a device that at a minimum translates from one network layer protocol to another and potentially one full seven layer architecture to another&#46; Full Network translation gateways usually require a piece of installed software on the client designed to run within the client&#039;s installed protocol that &quot;tricks&quot; the application into thinking that it is running in its native network environment&#46; This transaction however is encapsulated in the non native protocol in the client and routed by that protocol to the gateway device&#46; Once received by the gateway all the underlying non native components are removed leaving only the native components generated by the application&#46; This portion is then formatted with the appropriate native components for all the underlying layers and sent out over the native network&#46; Hence gateways can have the following characteristics&#58;&nbsp;<br>&nbsp;<br>&#45; They can be connected to and participate in two separate networks&#46;&nbsp;<br>&#45; These two networks are potentially two totally different network architectures&#46;&nbsp;<br>&#45; A full translation of all services at every network layer is performed if necessary&#46;&nbsp;<br>&nbsp;<br>The advantage of a gateway is that it allows devices on one network architecture to communicate with devices on a totally different network architecture&#46; Without the gateway server (and the associated emulation software on the client) PCs would be incapable of connecting to IBM SNA networks&#46;&nbsp;<br>&nbsp;<br>The disadvantage of gateways is that they can create bottlenecks&#46; Translating up to seven layers from one network architecture to another is a resource intensive process&#46; There may be speed mismatches between the two networks which may introduce further delays&nbsp;<br>&nbsp;<br>One final note &#45; the reality of the current networks is that this has become essentially non&#45;existent because of tunnelling&#46; The technology referenced above has all disappeared from the technology landscape, and typically everything is implemented in IP and using tunnelling for things like VPNs&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Internetworking Enabling Services&nbsp;<br>###&nbsp;<br>&nbsp;<br>Routers compile and maintain information on how to reach other networks&#46; The question that needs to be answered before routing begins is exactly what device on which specific network do I want to reach&#46; In other words, the network layer destination address is all the router needs to identify an appropriate route but how is the destination address determined?&nbsp;<br>&nbsp;<br>In the case of tunneled protocols, how does the tunneling protocol know which address in its protocol tables represents the edge device to the network that knows how to reach the encapsulated protocols destination address?&nbsp;<br>&nbsp;<br>Three examples of mechanisms that help applications identify resources across networks are Host Files, Domain Name Services (DNS) and Windows Internet Naming Service (WINS)&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Host Files&nbsp;<br>#&nbsp;<br>&nbsp;<br>Host files contain mappings of network addresses to host names&#46; Host name is not to be confused with the Host ID portion of the network address&#46; The host name is an arbitrary name associated to the service within the application&#46; When the &nbsp;local system attempts to connect to a host by name, it can use this file to lookup the network address using the hostname and the host file&#46;&nbsp;<br>&nbsp;<br>Host files are stored on the local device and used by local applications&#46; One disadvantage of using host files is that the information has to be maintained on all local devices that use the host&#46; If the need arises to change the network address of the host system the host name to network address mapping in all the host files distributed on devices throughout the network have to be updated&#46;&nbsp;<br>&nbsp;<br>An example of a host name could be &quot;mailserver&quot; which is used by the mail client software to identify the destination device where the mail post office resides&#46; The host table would identify the network address of the device on the network known as the mailserver&#46; This address is then inserted as the destination address of the packet processed by the network layer protocol&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;DNS&nbsp;<br>#&nbsp;<br>&nbsp;<br>Domain Name Services provide a role similar to host files&#46; Domain Name Services are provided by an application and database running on a server instead of the client like the Host file and process&#46; Internal Domain Name Servers are set up inside a companies private network for identifying internal named services&#46; External Domain Services are a component of the Internet and provide all Internet and WWW users with Domain name to IP address resolution world wide&#46; DNS is discussed further in the next section&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;WINS&nbsp;<br>#&nbsp;<br>&nbsp;<br>WINS is a service run on Windows NT server machines to provide Windows clients (Windows NT, Windows 9X, Windows For Workgroups & Microsoft LanMan) a way to find other Windows based machines&#46; WINS, which stands for Windows Internet Naming Service, resolves Windows network machine names (also known as NetBIOS names) to Internet IP addresses, allowing Windows machines on a network to find and communicate with each other&#46;&nbsp;<br>&nbsp;<br>Utilizing a WINS server is essential for any Windows client machine that intends to work with other Windows machines over the Internet&#46; To utilize WINS services you must insert the IP address of the WINS servers you wish to use into your TCP/IP networking configuration&#46;&nbsp;<br>&nbsp;<br>WINS servers function as network layer protocol tunneling gateways, the tunnelled protocol is the non&#45;routable NetBIOS protocol&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;DNS&#58; Domain Name Services&nbsp;<br>###&nbsp;<br>&nbsp;<br>When you look for a particular web site on the Internet, entering a value like &quot;WWW&#46;UML&#46;EDU&quot; in your browser is a lot easier than remembering the site&#039;s numeric IP address&#46; But if you examined the packets that pass between your browser and the UML site, you&#039;d see the specific UML IP addresses in the packet header&#46; You may ask yourself, &quot;Where did the knowledge of which IP address is associated with UML come from?&quot;&nbsp;<br>&nbsp;<br>Domain Naming Service (DNS), an Internet protocol and distributed database, provides the mapping between these &quot;names&quot; associated with the site and the actual IP address for that site&#46;&nbsp;<br>&nbsp;<br>Having a basic understanding of how DNS works is key to successfully administering an Internet&#45;connected network&#46; First we need to take a quick look at the structure of Internet host names&#46; The last portion of a host name, such as &#46;com, is the top&#45;level domain to which the host belongs&#46; In addition to the &#46;com domain, there are six other top&#45;level domains assigned by InterNIC, the coordinating body for Internet name services&#46;&nbsp;<br>&nbsp;<br>If the site is outside the United States, the organization that assigns domain names has its own standards&#46; In most cases, top&#45;level domains for non&#45;U&#46;S&#46; hosts look something like &#46;co&#46;uk or &#46;ac&#46;uk, which indicate a company or academic institution in the United Kingdom&#46;&nbsp;<br>&nbsp;<br>At the top of the DNS database tree are root name servers, which contain pointers to master name servers for each of the top&#45;level domains&#46; For example, to find out the numeric address of www&#46;uml&#46;edu, a DNS server would ask the root name server for the address of the master name server for the &#46;edu domain&#46;&nbsp;<br>&nbsp;<br>In turn, the master name servers for each of the top&#45;level domains contain a record and name&#45;server address of each domain name&#46; So in trying to find out the numeric address of www&#46;uml&#46;edu, the DNS server asks the &#46;edu server for the name of the server that handles the uml&#46;edu domain&#46;&nbsp;<br>&nbsp;<br>The individual name servers for each domain name, such as uml&#46;edu, contain detailed address information for the hosts in that domain&#46; So in our example, the DNS server then asks the uml&#46;edu server for the name of the server that handles the uml&#46;edu domain&#46;&nbsp;<br>&nbsp;<br>Finally, this most specific name server supplies the DNS server with the IP address of the machine called www&#46;uml&#46;edu&#46;&nbsp;<br>&nbsp;<br>Providing DNS to your users is an important part of linking them to the Internet&#46; There are two basic ways to configure DNS&#46; One option is to use your ISP&#039;s (Internet service provider&#039;s) DNS server&#46; Many ISPs will let you do this&#46; Another option is to set up a DNS server on your own network&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;ISP provided DNS service&nbsp;<br>##&nbsp;<br>&nbsp;<br>There are three steps to this process&#46; First, have your ISP inform the InterNIC that it is providing both primary and secondary DNS services for your organization&#46;&nbsp;<br>&nbsp;<br>Second, your ISP will give you the numeric IP addresses of the primary and secondary DNS servers, which you&#039;ll need to configure your users&#039; TCP/IP stacks&#46; You can do this by entering the information manually either at the desktop or at your Dynamic Host Configuration Protocol (DHCP) server&#46;&nbsp;<br>&nbsp;<br>Finally, you need to tell your ISP about the DNS records that you wish to publish to allow outside users to interact with your network&#46;&nbsp;<br>&nbsp;<br>In addition, if you want to receive E&#45;mail from the Internet, you will need to have a Mail Exchange (MX) record for your domain in your ISP&#039;s DNS database&#46; MX refers to a machine that accepts E&#45;mail connections for your domain&#46;&nbsp;<br>&nbsp;<br>If you plan to use your ISP&#039;s DNS server, you&#039;ll also need to have the ISP set up some A records, which associate IP addresses with computer names&#46; Each of the computers mentioned in your MX records needs an A record to associate them with an IP address&#46;&nbsp;<br>&nbsp;<br>You may also want to set up A records for each of your workstations if your users need to use ftp (File Transfer Protocol) to download software from the Internet&#46; This is because some ftp sites perform a look up to get the DNS name of the machine from which they receive download requests&#46; If the machine has no name, the sites deny the request&#46;&nbsp;<br>&nbsp;<br>You&#039;ll also need A records for any public servers you maintain&#46; For example, if you have a World Wide Web server, you&#039;ll need to have the ISP set up an A record linking the name www&#46;zzzz&#46;com to the IP address of your Web server&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Internal Domain Name Servers&nbsp;<br>##&nbsp;<br>&nbsp;<br>If your ISP does not provide name services or if you need to have a DNS server at your site to support internal networking applications, the first thing you need to know is that you must have at least two name servers&#45;&#45;a primary and a secondary&#46;&nbsp;<br>&nbsp;<br>This is because the InterNIC will not grant you a domain name unless there are at least two DNS servers on the Internet with information about that domain&#46; Another reason for a second server is that you really need the fault tolerance a second name server can provide&#46; If your one and only DNS server goes down, your users will be cut off from the Internet names and would need to rely on IP addresses only&#46;&nbsp;<br>&nbsp;<br>Some sites take a middle&#45;of&#45;the&#45;road approach and use an on site DNS server as well as their ISP&#039;s&#46; Because maintenance of the domain names is done at the primary name server, choosing which one is primary and which is secondary is quite important&#46;&nbsp;<br>&nbsp;<br>If you choose to administer the primary name server yourself, keep in mind that you&#039;ll have to maintain the DNS records&#46;&nbsp;<br>&nbsp;<br>If you choose to have a secondary name server on site, your ISP will do all of the work, and your secondary name server will simply download the data about your domain from the primary server periodically&#46;&nbsp;<br>&nbsp;<br>Why should you bother with having a DNS server on your LAN in the first place? There are a few reasons&#46;&nbsp;<br>&nbsp;<br>First, if you are running IP network&#45;based applications inside your network that require users to connect to internal machines by name, it is not a great idea to advertise the names and addresses of these machines&#46; DNS can give hackers a map of your network, so setting up an internal DNS server that does not publish information to the world is a good idea&#46;&nbsp;<br>&nbsp;<br>Second, a DNS server inside your network lets you be the master of your own domain&#46; You can make changes, additions, and deletions on your own schedule&#46;&nbsp;<br>&nbsp;<br>Finally, name resolution will be faster for your users because your DNS server is probably not as heavily loaded as your ISP&#039;s server&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Top&#45;level domains&nbsp;<br>##&nbsp;<br>&nbsp;<br>The core three&#45;letter top&#45;level domains are &#46;COM, &#46;NET, &#46;ORG, &#46;EDU, &#46;INT, &#46;MIL and &#46;GOV&#46; The first three are operated on commercial principles, while the last four have restrictive conditions on who can register names in those domains (respectively, four&#45;year degree granting institutions in North America, organisations that were established by international treaty, the USA military, and the USA federal government)&#46; More TLDs are being added over time and as demand rises&#46;&nbsp;<br>&nbsp;<br>In addition, there are two&#45;letter top&#45;level domains for each country, and a special domain &#46;ARPA which currently contains some Internet infrastructure databases&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;SNA Gateways&nbsp;<br>###&nbsp;<br>&nbsp;<br>[Introduction]&nbsp;<br>The continuously increasing demand for access to TCP/IP based applications like the World Wide Web and Corporate Intranets forced more and more companies to deal with the integration of SNA with TCP/IP, although most new networks and systems are focused exclusively on TCP/IP and do not need to deal with SNA at all&#46;&nbsp;<br>&nbsp;<br>The remaining SNA applications, because they are more often than not mission&#45;critical, are firmly entrenched in many corporations&#46; The desire to run SNA applications in parallel with newer TCP/IP applications arises&#46; SNA and TCP/IP however are two very distinct ways of connecting computing devices, and the potential for compromising the functionality of end users or network management during the integration is very real&#46; Common problems that arise include loss of such SNA functions as terminal control keys or other bad keyboard mappings and loss of print completion acknowledgment over TCP/IP&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;The Evolution of SNA&nbsp;<br>#&nbsp;<br>Since IBM began selling modern business systems, Systems Network Architecture (SNA) has been coming with them&#46; SNA has proved to be reliable, predictable and manageable&#46; SNA Networks were built to link these business systems based on low&#45;bandwidth point&#45;to&#45;point connections&#46;&nbsp;<br>&nbsp;<br>Personal computers with SNA emulation software started replacing fixed function terminals&#46; In the following years, coax controllers with SDLC links were superseded by LANs&#46; With this second evolution came advanced router technology and high&#45;bandwidth enterprise networks&#46;&nbsp;<br>&nbsp;<br>The single largest technology to impact the role and ultimately existence of SNA is TCP/IP and the explosion of its use on personal computers, workstations, and servers, both inside and outside the enterprise&#46; TCP/IP provides peer&#45;to&#45;peer connectivity and simple access to a myriad of resources, all linked together by a common protocol&#46;&nbsp;<br>&nbsp;<br>User demands for accessing internal resources and the Internet, has IS organizations struggling with the implementation of TCP/IP and related technologies on legacy systems and their supporting infrastructures&#46;&nbsp;<br>&nbsp;<br>Many IS managers, unwilling to sacrifice their trusted 3270 SNA applications insist that it&#039;s just too expensive to rewrite their incumbent 3270 applications&#46; With the ready availability of TCP/IP application environments now, this is fading quickly&#46; In the cases where this is still an issue for their legacy applications, they make a conscious decision to forfeit the benefits of TCP/IP in the process&#46; Others, eager to erase all traces of SNA, learn&#45;too late&#45;that TCP/IP information access applications lack important functionality that was deeply embedded in the application and hence required for the application to run&#46;&nbsp;<br>&nbsp;<br>Integrating SNA with TCP/IP is one solution to satisfy the user demands while protecting the legacy investment&#46;&nbsp;<br>&nbsp;<br>Implementing TCP/IP throughout your enterprise is a smart move because it has become the de facto industry standard for open network computing, and it will continue to grow&#46; &nbsp;Vendors are almost all offering support for TCP/IP, and the best of both worlds when legacy apps are required to be supported can be achieved by keeping SNA on the host and finding a sleek integration path&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Integration Challenges&nbsp;<br>#&nbsp;<br>While host access with TCP/IP is becoming functionally more SNA&#45;like in many ways, distinct methodological differences remain between the two protocols&#46; Application compatibility, network management, and functionality are typical concerns of IS managers as they attempt to integrate these two technologies&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Application compatibility&nbsp;<br>#&nbsp;<br>Generally 3270 applications were built with SNA networks in mind&#46; They assume that the transport is SNA and tend to rely on functionality specific to SNA&#46; On the other hand, an overwhelming majority of today&#039;s desktop systems are personal computers based on the Intel architecture and running some version of the Microsoft Windows operating system&#46; Today, TCP/IP is a native part of that operating system&#46; Therefore, providing access to host&#45;based applications while avoiding the expense of SNA at the desktop or TCP/IP on the host becomes a challenge&#46; While there are a number of ways to address this issue, the most popular is the use of an SNA gateway to integrate PC and host networks&#46;&nbsp;<br>&nbsp;<br>SNA gateways can support batch, interactive, and transaction&#45;based access to host applications from client workstations on a TCP/IP LAN and WAN&#46; SNA gateways are so widely used because they can wear so many &quot;hats&#46;&quot; They can function as TCP/IP&#45;to&#45;SNA protocol converters, supporting TN3270 emulators and split&#45;stack clients&#46; Additionally, SNA gateways can act as servers for LU6&#46;2 applications such as file transfer or database access&#46; SNA gateways allow integration of SNA networks and TCP/IP networks by providing a transport protocol translation for the host applications being used by the clients&#46; Some SNA gateways (like Microsoft SNA Server) even provide an &quot;application&quot; gateway that can convert FTP to AFTP (APPC) for transferring a file between LAN&#45;based and host systems&#46; Consequently, more and more IS managers have come to a comforting conclusion about SNA gateways&#58; application compatibility just doesn&#039;t rear its troublesome head&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Basic SNA Concepts&nbsp;<br>##&nbsp;<br>&nbsp;<br>SNA defines the standards, protocols, and functions used by devices&#45;from mainframes to terminals&#45;to enable them to communicate with each other in SNA networks&#46;&nbsp;<br>&nbsp;<br>SNA functions are divided into a hierarchical structure of separate layers, each performing a specific set of functions&#46; This division of network functions into layers enables network devices to share information and processing resources without having detailed information about each device on the network&#46; A user at a workstation can communicate with another user without knowing anything about the physical devices on the network or the connections between those devices&#46;&nbsp;<br>&nbsp;<br>SNA as a hierarchical architecture is not comprised of equal or &quot;peer&quot; components&#46; As you move from the top of the hierarchical structure (the host mainframe) towards the bottom of the architecture (the &quot;dumb terminal&quot;) the devices become less intelligent and contain less capability/functionality&#46; This was a major drawback of the SNA architecture as originally designed brought to the forefront of interoperability as more and more dumb peripheral devices (terminals) were replaced with intelligent devices that could function as peer devices on a network&#46; This shortcoming was addressed through the expansion of SNA to include peer processing capability with Advanced Peer to Peer Networking (APPN)&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;SNA Network Types&nbsp;<br>#&nbsp;<br>&nbsp;<br>SNA supports the following types of networks&#58;&nbsp;<br>&nbsp;<br>&#45; A subarea network is a hierarchically organized network consisting of subarea nodes and peripheral nodes&#46; Subarea nodes, such as hosts and communication controllers, handle general network routing&#46; Peripheral nodes, such as terminals, attach to the network without awareness of general network routing&#46;&nbsp;<br>&#45; A peer network is a cooperatively organized network consisting of peer nodes that all participate in general network routing&#46;&nbsp;<br>&#45; A mixed network is a network that supports both host&#45;controlled communications and peer communications&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;SNA Nodes&nbsp;<br>#&nbsp;<br>In SNA networks, a node is a system, workstation, or other device&#45;with associated software components&#45;that implements SNA protocols and has at least one communication path to another node in the network&#46; Each node manages its end of the network communication paths, and uses SNA protocols to communicate with the node at the other end of each path&#46;&nbsp;<br>&nbsp;<br>Because subarea networks and peer networks define the relationships among nodes differently, they also use different terms for node types (to describe the roles that nodes play in the network)&#46;&nbsp;<br>&nbsp;<br>Node Types in a Subarea Network&#58;&nbsp;<br>&nbsp;<br>&#45; Subarea nodes control communication and network resources for all attached nodes&#46; SNA classifies subarea nodes according to their capabilities and the amount of control they have over other nodes&#58;&nbsp;<br>&nbsp;<br>&#45; Type 5 nodes provide SNA functions that control network resources, support transaction programs, support network operators, and provide end&#45;user services&#46; Because these functions are often provided by host processors, type 5 nodes are also known as host nodes &#46; The devices and resources controlled by a type 5 subarea node constitute the domain of that node&#46;&nbsp;<br>&nbsp;<br>&#45; Type 4 nodes provide SNA functions that route and control the flow of data in a part of the network&#46; Because these functions are often provided by communication controllers, type 4 nodes are also known as communication controller nodes &#46;&nbsp;<br>Peripheral nodes serve subordinate roles in subarea networks&#46; For example, a peripheral node can support 3270 emulation or dependent LU 6&#46;2 communication&#46; Peripheral nodes are devices such as distributed processors, cluster controllers, or workstations; they are also classified into type 2&#46;0 and type 2&#46;1 nodes&#58;&nbsp;<br>&nbsp;<br>Type 2&#46;0 nodes are always controlled by a type 4 or 5 node&#46; They cannot establish communication with other nodes without the participation of a type 4 or 5 node&#46; Type 2&#46;0 nodes are referred to as dependent nodes &#46;&nbsp;<br>&nbsp;<br>Type 2&#46;1 nodes can act as dependent nodes, but they can also communicate directly with other type 2&#46;1 nodes&#46;&nbsp;<br>&nbsp;<br>A type 4 or 5 subarea node to which a peripheral node is attached acts as a boundary node&#46; It performs a boundary function by translating between the network addresses used by a subarea node and the local addresses used by a peripheral node&#46;&nbsp;<br>&nbsp;<br>A simple subarea network includes the following components&#58;&nbsp;<br>&nbsp;<br>Host&#58;&nbsp;<br>&#45; A host is a mainframe computer compatible with the original IBM System/370&#46; A host is a type 5 node&#46;&nbsp;<br>&nbsp;<br>Communication controller&#58;&nbsp;<br>&#45; A communication controller, also known as a front&#45;end processor (FEP), is a separate processor attached to the host&#46; It manages the host&#039;s communications with other computers&#46;&nbsp;<br>&nbsp;<br>Communications link&#58;&nbsp;<br>&#45; A communications link connects the host site with an end&#45;user site&#46; The users are usually on a separate site from the host, so the two sites need to be connected by a communications link&#46;&nbsp;<br>&nbsp;<br>Terminal controller&#58;&nbsp;<br>&#45; At the remote end of the communications link is a terminal controller, also known as a cluster controller&#46; It is responsible for controlling the use of the link, and routes data to the terminals&#46; The most well&#45;known IBM terminal controllers are the 3174 and 3274&#46;&nbsp;<br>&nbsp;<br>Terminals&#58;&nbsp;<br>&#45; Users run host applications or submit work to the host from terminals&#46; The best&#45;known IBM terminal is the 3270&#46; A terminal can be connected through a terminal controller or directly connected to a communication controller&#46;&nbsp;<br>&nbsp;<br>Printers&#58;&nbsp;<br>&#45; Printers such as the IBM 3287 can also be attached to the terminal controller&#46; They can receive output from the host&#46;&nbsp;<br>The traditional subarea SNA set&#45;up enables the users to use the resources of a single host system&#46; The terminals provide only simple data entry and display functions to and from the terminal controller; the terminal controller is responsible for handling SNA communications between the terminals and the host&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Gateway integration&nbsp;<br>##&nbsp;<br>As stated earlier SNA gateways consist of two components&#58;&nbsp;<br>&nbsp;<br>&#45; A server based component that connects to the SNA network on one side and the LAN on the other side&#46;&nbsp;<br>&#45; A Client based component that runs on the workstation and provides SNA network services (from the Transport Layer to the Application Layer) to applications running on the client&#46;&nbsp;<br>&nbsp;<br>The Server component of the SNA Gateway connects to the SNA network as an SNA node in place of a terminal controller and its terminals&#46; From the host&#039;s point of view, the node appears as a terminal controller&#46; However, the gateway provides the users with additional functions, such as the ability to access more than one host system and facilities for customizing screen displays&#46; In addition, the gateway can be used for other tasks not related to SNA (unlike the terminal controller, which is used solely for communications with the host)&#46;&nbsp;<br>&nbsp;<br>The Server component also connects to the LAN and participates in that network as a peer or server device&#46; Layer 1 and 2 can be any LAN technology such as Ethernet or Token Ring&#46; Layer three is the Network Layer protocol (IP, IPX, etc&#46;) installed on the clients accessing the gateway server&#46;&nbsp;<br>&nbsp;<br>The client software component provides a transport layer service to applications that looks identical to an SNA transport layer service&#46; The software encapsulates this transport service in the underlying LAN based protocols for delivery to the Gateway Server&#46; When received by the gateway server the underlying three layers of LAN associated components are stripped off leaving the SNA compliant components of layers 4&#45;7&#46; These are transmitted down the SNA side of the gateway in full SNA node compliant format&#46;&nbsp;<br>&nbsp;<br>The process is reversed for communications going the other way&#46;&nbsp;<br>&nbsp;<br>Although TCP/IP integration solutions abound, some are clearly more effective than others&#46; The two primary means of accomplishing the integration are&#58;&nbsp;<br>&nbsp;<br>&#45; Conversion of the SNA data stream to TCP/IP protocols&nbsp;<br>&#45; Encapsulation of SNA in TCP/IP&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Conversion examples&nbsp;<br>#&nbsp;<br>&nbsp;<br>[Direct Connection]&nbsp;<br>TCP/IP access to an IBM host can be achieved with a TN3270E client&#45;server connection&#46; In this scenario, the TN3270E server converts the SNA data stream to Telnet&#46; Next, the Telnet protocol transports the 3270 data across the network to the TN3270E client&#46; The session services and delivery of the payload (3270 data), which are traditionally handled by SNA, are now assumed by the Telnet connection&#46; Host applications that are dependent on LU services now operate just as smoothly over TCP/IP as they did over traditional SNA links&#46;&nbsp;<br>&nbsp;<br>[MPTN Connection]&nbsp;<br>Multi&#45;Protocol Transport Networking (MPTN), developed by IBM and marketed under the brand name AnyNet, allows applications to pass data over a logical session spanning two incompatible networks (or allows an application to run over a non&#45;native network&#46;)&nbsp;<br>&nbsp;<br>For example, an application written to APPC/LU 6&#46;2 can run over TCP/IP using MPTN&#46; MPTN uses a translator called &quot;Common Transport Semantics,&quot; which interprets application calls to a particular network API (APPC) and maps them to actions on another network API (sockets)&#46; With MPTN, an application can still speak its &quot;native language&quot; (in this case, APPC) but can be transported over any network type&#46; There is no need to load or run multiple protocols from your workstation; a single protocol is used to pass applications transparently across MPTN&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Encapsulation Methods&nbsp;<br>#&nbsp;<br>&nbsp;<br>[Gateway Connection]&nbsp;<br>&nbsp;<br>SNA gateways, like Microsoft&#039;s SNA Server and Novell&#039;s SAA, allow the integration of SNA and TCP/IP with no impact on functionality to the end user, and little impact on local system resources&#46; The client requires only a TCP/IP protocol stack and emulation software&#46; The emulation software transports the 3270 data stream and application data over the network to the gateway, which is supporting the SNA session and network services&#46; In a gateway arrangement, SNA is effectively encapsulated through TCP/IP to the gateway server&#46; From the gateway to the host, the exchange is all SNA&#46; Current applications do not have to be modified to run in this configuration&#46; End users retain the key SNA or APPC functionality they need&#46;&nbsp;<br>&nbsp;<br>[Data Link Switching]&nbsp;<br>&nbsp;<br>Data Link Switching (DLS) is a router&#45;to&#45;router technology&#46; DLS encapsulates SNA in TCP/IP and &quot;tunnels&quot; it across the network&#46; Workstations are unaffected by the transaction&#46; DLS&#45;capable routers perform the encapsulation and de&#45;encapsulation of SNA at both ends&#46; Separate TCP circuits are established for each pair of communicating end stations, while the DLS router appears to the SNA devices as a link&#45;terminating bridge&#46; The switch&#039;s available resources are perceived by the end node to be just on the other side of the DLS bridge&#46; This solution has some built&#45;in bonuses for complex networks, because it does not impact host memory or require the rewriting of end system drivers&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;The Peer&#45;to&#45;Peer Topology&nbsp;<br>#&nbsp;<br>&nbsp;<br>In the late 1980&#039;s, IBM recognized the growing importance of peer&#45;oriented, client/server networks&#46; New products were introduced which allowed for the construction of peer&#45;to&#45;peer network topologies in which PU types 4 and 5 were not present&#46; This new network model is called Advanced Peer&#45;to&#45;Peer Networking (APPN)&#46;&nbsp;<br>&nbsp;<br>[Node Types in a Peer Network]&nbsp;<br>&nbsp;<br>Peer networks do not classify nodes hierarchically, as is done in a subarea network&#46; Exchanges with other nodes are not controlled by a host or other centralized processor&#46; Instead, any node can establish communication with any other node&#46;&nbsp;<br>&nbsp;<br>A peer network is composed of type 2&#46;1 nodes&#46; The nodes in a peer network can serve the following roles&#58;&nbsp;<br>&nbsp;<br>&#45; APPN network nodes (NNs) identify the locations of network resources, determine routes for sessions between these resources, route sessions, and serve&nbsp;<br>&#45; end nodes (EN) and low&#45;entry networking (LEN) nodes directly attached to the network node&#46; The domain of an APPN network node consists of itself and any end nodes for which it provides network services&#46;&nbsp;<br>&#45; APPN end nodes can access remote resources without requiring that those resources be configured on the end node&#46; An end node can communicate with adjacent nodes on its own, but requires the services of a network node server to access nonadjacent nodes&#46; The domain of an APPN end node includes only itself&#46;&nbsp;<br>&nbsp;<br>SNA Gateways support Peer to Peer Processing by facilitating the communication between two peer level devices&#46; Hence two workstations could initiate a peer to peer process between themselves&#46; The encapsulated packets would up and down the same (LAN) side of the gateway to reach the other peer device&#46; In this example the host device (as well as the communications controller) never participate in the peer to peer communication&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TN3270 & 3270 Emulation&nbsp;<br>###&nbsp;<br>&nbsp;<br>3270 emulation programs that communicate over TCP/IP (rather than over an SNA network) are referred to as TN3270 programs&#46; The TN stands for &quot;Telnet&quot; which is the terminal application of the TCP/IP Protocol Suite&#46;&nbsp;<br>&nbsp;<br>TN3270 programs can also include support for TN3270E (Telnet 3270 standard extensions)&#46; TN3270E supports 3270 device emulation (including both terminals and printers) using Telnet&#46; It enables a Telnet client to select a particular device (by specifying the LU name), and provides enhanced support for various SNA functions&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;TN3270E&nbsp;<br>#&nbsp;<br>&nbsp;<br>This new specification has enabled 3287 printing over TCP/IP with the kinds of functionality that end users expect&#46; In addition to supporting print enhancements, TN3270E also provides&#58;&nbsp;<br>&nbsp;<br>&#45; Resource Association&nbsp;<br>&#45; Assigned LU&nbsp;<br>&#45; SSCP (System Services Control Point) Support&nbsp;<br>&nbsp;<br>[Resource Association]&nbsp;<br>&nbsp;<br>LU sessions in an SNA network are generally static resources, where specific logical units can be assigned to specific users or applications&#46; In this way, a printer LU can be associated with a display LU&#46; Grouping resources is important, since it enables the applications to print directly to the printer associated with a particular user or workgroup&#46;&nbsp;<br>&nbsp;<br>[Assigned LU]&nbsp;<br>&nbsp;<br>Coax controllers have LUs that are configured on a per&#45;port basis, with each user having his own physical &quot;port&quot; connection to the controller; thereby having a known LU or LU address&#46; Since the connection is &quot;wired&quot; to the controller and the controller has structured LU/port assignments, the LU is almost always available to the user and is considered relatively secure&#46; When the user calls with a problem, the help desk person can quickly identify the connection in question&#46; In some cases where TN3270 connectivity is used, the LU assignments are invisible to the user and the help desk person&#46; But with TN3270E, an LU can be tagged to an IP address, providing enhanced security and manageability&#46;&nbsp;<br>&nbsp;<br>[SSCP (System Services Control Point) Support]&nbsp;<br>&nbsp;<br>The SSCP&#45;to&#45;LU session is important to the functional capabilities of a 3270 user since it is the control mechanism for SNA sessions&#46; This provides functions such as SysReq and Attn key support, as well as the response messages for functions like printing&#46;&nbsp;<br>&nbsp;<br>The progress of the IETF&#039;s TN3270E working group is ongoing&#46; The group, whose mission is to enrich host access via TCP/IP, is committed to the maturation of TCP/IP access to mainframe and AS/400 applications&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TN Server&nbsp;<br>##&nbsp;<br>&nbsp;<br>A TN server provides access to 3270 host computers for TN3270 users on other computers&#46; TN server enables TN3270 users to share a host connection with the TN Server or with other TN3270 users, instead of requiring a direct link&#46; TN Server also enables TN3270 users to access hosts that are not running TCP/IP&#46;&nbsp;<br>&nbsp;<br>The TN Server provides an association between a TN3270 user and a 3270 LU on the TN Server&#46; All data from the TN3270 user is routed to the LU&#46; This means that the configuration for both the host and the TN3270 user is as though they were connected directly; neither needs to be aware that data is being routed through the TN server&#46;&nbsp;<br>&nbsp;<br>TN Server supports all TN3270 client emulation programs that correctly implement the protocols defined in RFCs 1123, 1576, 1646, and 1647&#46;&nbsp;<br>&nbsp;<br>When a TN3270 program communicates with TN server, the server identifies the program by the TCP/IP address of the computer where the TN3270 program is running&#46; The TN Server cannot distinguish between two different TN3270 programs being used by different users on the same computer&#46;&nbsp;<br>&nbsp;<br>Each TN server user is normally configured to access a single 3270 LU, and so is restricted to one host session at a time&#46; However, you can also configure a TN server user to access a pool of 3270 LUs, instead of having a single dedicated 3270 LU for each user&#46; This enables the user to access as many sessions as there are available LUs in the pool&#46;&nbsp;<br>&nbsp;<br>Examples of Applications supported by TN Servers&#58;&nbsp;<br>&nbsp;<br>&#45; 3270 emulation programs&#46;&nbsp;<br>&#45; 5250 emulation programs (AS/400 Terminal Emulation)&#46;&nbsp;<br>&#45; APPC Application Suite&nbsp;<br>&nbsp;<br>Once a TN Server is established it will be relied upon to carry potentially mission critical application activity previously transported over the dedicated SNA network&#46; In general, you should define at least one backup TN Server in addition to the master server&#46; Any additional servers can be defined as additional backup servers, or they can be left as peer servers used for load balancing&#46;&nbsp;<br>&nbsp;<br>If the master server fails, the backup server will take over as the master&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;3270 Emulation&nbsp;<br>##&nbsp;<br>&nbsp;<br>You can use 3270 emulation software to log on to and use SNA host systems from your computer, control display and printer emulation sessions, and to transfer files between the local and host computers&#46; 3270 emulation uses the node&#039;s LU type 0&#45;3 resources&#46;&nbsp;<br>&nbsp;<br>To use 3270 emulation, you need to define the 3270 users on your system, identified by their login IDs, and the 3270 features available to each user or group of users&#46; 3270 users are defined as domain resources, which simplifies the configuration required to support emulation across the domain&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Benefit of TN3270 over 3270 Emulation&nbsp;<br>#&nbsp;<br>&nbsp;<br>Use of TN3270 does not have to be restricted to just SNA&#46; TN3270 is emerging as the standard way for a 3270 emulator to communicate with its host, whether that host is the mainframe itself or a gateway device functioning as a TN3270 server&#46; No longer do vendors have to code their emulators and/or comm servers for multiple interfaces between the client and server parts of the 3270 connectivity solution&#46; No longer are IS managers locked into a particular micro&#45;to&#45;mainframe connectivity vendor, because the TN3270 standard means they can mix and match 3270 emulators and servers to meet the needs of their users rather than the marketing strategies of vendors&#46;&nbsp;<br>&nbsp;<br>The TN3270 standard lets vendors do unique things with their products and know that they will still interoperate with other vendors products&#46;&nbsp;<br>&nbsp;<br>Aside from a handful of SNA&#45;specific functions that are not meaningful in the world of non&#45;SNA host connectivity, non&#45;SNA implementations of TN3270E are quite full&#45;featured&#46;&nbsp;<br>&nbsp;<br>And because TN3270E is a standard, users benefit from the ability to connect any TN3270E compliant client to any TN3270E&#45;compliant server able to support a non&#45;SNA connection to the host&#46; In a practical sense it means that organizations with a mix of SNA and non&#45;SNA hosts can standardize not only on TCP/IP for interconnectivity, but also TN3270E for host access, and any TN3270E emulator to provide that host access&#46; For organizations with only non&#45;SNA hosts, it means that mainframe data suddenly becomes as Internet, intranet, or extranet accessible as they wish to make it, whether through Java&#45;based or more traditional TN3270E terminal emulation packages&#46;&nbsp;<br>&nbsp;<br>############################################################################&nbsp;<br>### &nbsp;&nbsp;physical internetworking &nbsp;(hub/repeater, bridge, switch, router) &nbsp;&nbsp;###&nbsp;<br>############################################################################&nbsp;<br>&nbsp;<br>The term internetworking refers to linking individual LANs together to form a single internetwork&#46; This internetwork is sometimes called an enterprise network because it interconnects all of the computer networks throughout the entire enterprise&#46; Workgroup LANs on different floors of a building or in separate buildings on a business campus can be linked together so that all of the computing systems at that site are interconnected&#46; Geographically distant company sites can also be tied together in the enterprise&#45;wide internetwork&#46;&nbsp;<br>An individual LAN is subject to limits on such things as how far it can extend, how many stations can be connected to it, how fast data can be transmitted between stations, and how much traffic it can support&#46; If a company wants to go beyond those limits &#45;&#45; link more stations than that LAN can support, for example &#45;&#45; it must install another LAN and connect the two together in an internetwork&#46;&nbsp;<br>&nbsp;<br>There are two main reasons for implementing multiple LANs and internetworking them&#46; One is to extend the geographic coverage of the network beyond what a single LAN can support &#45;&#45; to multiple floors in a building, to nearby buildings, and to remote sites&#46; The other key reason for creating internetworks is to share traffic loads between more than one LAN&#46; A single LAN can only support so much traffic&#46; If the load increases beyond its carrying capacity, users will suffer reduced throughput and much of the productivity achieved by installing the LAN in the first place will be lost&#46; One way to handle heavy network traffic is to divide it between multiple internetworked LANs&#46;&nbsp;<br>&nbsp;<br>There are three major types of devices used for internetworking&#58; bridges, routers, and switches&#46; Today the most commonly used internetworking devices are high&#45;speed routers, especially in wide area internetworks linking geographically remote sites&#46; But routers are also heavily used in building and campus internetworks&#46;&nbsp;<br>&nbsp;<br>Bridges have also been popular, even though they offer less functionality than routers, because they are less expensive to purchase, implement, and maintain&#46;&nbsp;<br>&nbsp;<br>LAN switches are the most common, latest class of internetworking devices, and are found in most even small office and home office environments as well as larger office deployments&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;repeaters (non&#45;intelligent hub)&nbsp;<br>###&nbsp;<br>&nbsp;<br>Repeaters are devices that regenerate signals so they can travel farther on a cable&#46; The term &quot;repeater&quot; is often used to describe non intellegent hubs&#46;&nbsp;<br>Repeaters simply take in a digital signal received from one segment, &quot;reshape&quot; it to it&#039;s original strength and send it out on another segment&#46;&nbsp;<br>&nbsp;<br>Some repeaters are designed to support different media types on each segment&#46; Therefore the signal can be repeated across any combination of copper&#46; coax, or fiber cabling&#46; Repeaters can also interface to wireless networks as well&#46;&nbsp;<br>&nbsp;<br>A network built with repeaters is simply one large extended segment therefore all MAC addresses on segments connected with repeaters must be unique&#46;&nbsp;<br>&nbsp;<br>Since repeaters function exclusively at the physical layer they do not know what frames or addresses are, but they do understand the data link layer frame format in order to be able to interpret the incoming frames and regenerate them on the output&#46; Repeaters do not know what protocols are being used&#46;&nbsp;<br>&nbsp;<br>All segments connected by repeaters must&nbsp;<br>&#45; use the same MAC method&nbsp;<br>&#45; use the same physical transmission techniques (baseband)&nbsp;<br>&nbsp;<br>Repeaters are both the least expensive and most simple form of interconnection&#46; They are not however internetworking devices since they have no physical or logical network awareness or intelligence&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Repeaters &nbsp;vs &nbsp;Amplifiers&nbsp;<br>##&nbsp;<br>&nbsp;<br>Repeaters regenerate digital signals which means they are used to connect segments that utilize baseband signaling techniques&#46;&nbsp;<br>Analog or broadband signals are amplified not repeated&#46; A broadband signal based on Frequency Modulation (FM) or Amplitude Modulation (AM) is &quot;boosted&quot; by regenerating the incomming electromagnetic wave at the full transmission signal strength&#46;&nbsp;<br>&nbsp;<br>The terms AM and FM should sound familiar to anyone who has used a radio&#46; The radio employs an amplifier to boost the signal&#46; Anyone who has ever used a radio also has experienced the negative aspects of amplified signals&#46; If the signal is distorted or corrupted prior to being received the amplifier will boost the distortion as well&#46; Increasing the amplification of a &quot;staticky&quot; signal by turning up the volume makes the static louder&#46;&nbsp;<br>&nbsp;<br>We say a repeater &quot;reshapes&quot; the signal because baseband transmissions generate an electrical or light based signal that is interpreted as a specific bit value&#46; As long as the repeater can recognize the incoming signal as a specific bit it will generate a new pulse to the exact specifications of the signaling standard on the other side&#46; Hence, any distortion or corruption on the incoming signal is eliminated from the outgoing signal&#46;&nbsp;<br>&nbsp;<br>It is this capability to reshape the signal that makes baseband the transmission technique of choice for long distance transmissions&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Bridges and Routers &nbsp;&#45; overview&nbsp;<br>###&nbsp;<br>&nbsp;<br>Bridges and routers are both special kinds of devices used for internetworking LANs &#45;&#45; that is, linking different LANs or LAN segments together&#46; Many organizations have LANs located at sites that are geographically distant from each other&#46; Routers were originally designed to allow users to connect these remote LANs across a wide area network, but bridges can also be used for this purpose&#46; By placing routers or bridges on LANs at two distant sites and connecting them with a telecommunications link, a user on one of the LANs can access resources on the other LAN as if those resources were local&#46;&nbsp;<br>Bridges and routers link adjacent LANs&#46; Local bridges and routers were first used to extend the area a network could cover by allowing users to connect two adjacent LANs to maintain performance by reducing the number of users per segment&#46;&nbsp;<br>&nbsp;<br>Both Ethernet and Token Ring specify limits on maximum distances between workstations and hubs, hubs and hubs, and a maximum number of stations that can be connected to a single LAN&#46; To provide network connectivity for more people, or extend it to cover a larger area, it is sometimes necessary to link two different LANs or LAN segments&#46; Bridges and routers can both provide this function&#46;&nbsp;<br>&nbsp;<br>Today, however, these internetworking devices are also increasingly used to segment LANs to maintain performance by reducing the number of users per segment&#46; When users on a single LAN begin to experience slower response times, the culprit is often congestion&#58; too much traffic on the LAN&#46; One method users are employing to deal with this is to break large LANs with many users into smaller LANs, each with fewer users&#46; Adding new network users may require the organization to create new LANs to accommodate them&#46; Implementing new applications on an existing LAN can create so much incremental traffic that the organization may need to break the LAN into smaller LANs segments to maintain acceptable performance levels&#46;&nbsp;<br>&nbsp;<br>In all of these cases, it is still critical that users on one LAN be able to reach resources on other LANs within the organization&#46; But the LANs must be connected in such a way that packets are filtered, so that only those packets that need to pass from one LAN to another are forwarded across the link&#46; This keeps the packets sent between two stations on any one LAN from crossing over onto the other LANs and thereby congesting them&#46; A general rule of thumb suggests that 80 percent of the packets transmitted on a typical workgroup or department LAN are destined for stations on that LAN&#46;&nbsp;<br>&nbsp;<br>The lowered costs of switching devices, coupled with the significantly higher speeds like gigabit Ethernet, have made much of the worry of congestion go away for typical office environments&#46; The congestion problem still comes into play whenever there is an aggregation of the services or connections, such as a heavily used server, or a common Internet link used by a large office&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Bridges&nbsp;<br>###&nbsp;<br>&nbsp;<br>The discussion of bridges is for historical reference primarily, as switching technology has come down so far in cost that bridges have all but disappeared&#46; Bridges function at the Data Link Layer of the OSI Model making them simpler and less expensive than routers&#46; Bridges filter packets between LANs by making a simple forward/don&#039;t forward decision on each frame they receive from any of the networks they are connected to&#46; Filtering is done based on the MAC destination address of the frame&#46; If a frame&#039;s destination is a station on the same segment where it originated, it is not forwarded&#46; If it is destined for a station on another LAN it is fowarded to the port on the other side of the bridge&#46;&nbsp;<br>Bridges are not as simple as repeaters&#46; They have MAC layer processing intellegence&#46; They are also more expensive than repeaters&#46;&nbsp;<br>&nbsp;<br>Most bridges are standalone devices or a card in a hub&#46; A Bridge could however be a dedicated PC or other end node device connected to two segments and running bridging software&#46;&nbsp;<br>&nbsp;<br>(FYI) &nbsp;https&#58;//www&#46;diffen&#46;com/difference/Hub_vs_Switch&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Bridging process&nbsp;<br>##&nbsp;<br>&nbsp;<br>A Bridge is connected to two network segments&#46;&nbsp;<br>&nbsp;<br>The Bridge &quot;Listens&quot; to all the traffic on the two the segments (reads the source and destination MAC addresses of all frames transmitted&nbsp;<br>&nbsp;<br>Based on the address it makes a decision whether to pass the frame to the other segment or keep it on the segment from which it was received&#46;&nbsp;<br>&nbsp;<br>Additional information needed to make the decision to pass or filter the frame may come from one of the following &#58;&nbsp;<br>&nbsp;<br>&#45; Information stored in the bridge&nbsp;<br>&#45; Information within the frame&nbsp;<br>&nbsp;<br>If the information used to make the decision comes from a table inside the bridge the device is a &quot;Transparent Bridge&quot;&#46;&nbsp;<br>&nbsp;<br>If the information used to make the decision comes from within the frames it is a Source Routing Bridge&#46;&nbsp;<br>&nbsp;<br>Bridges may operate at the Media Access Control (MAC) Layer or the Logical Link Control (LLC) Layer&#46;&nbsp;<br>&nbsp;<br>Bridges can interconnect different network types as long as both sides are functioning at the LLC level&#46;&nbsp;<br>&nbsp;<br>MAC Layer Bridges are Ethernet&#45;to&#45;Ethernet or Token&#45;to&#45;Token&nbsp;<br>&nbsp;<br>LLC Layer Bridges can be for example, Ethernet&#45;to&#45;Token , Token&#45;to&#45;FDDI or Ethernet to FDDI&#46;&nbsp;<br>&nbsp;<br>All the addresses of the devices on both sides of the bridge must be unique&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Transparent Bridge&nbsp;<br>##&nbsp;<br>&nbsp;<br>When the bridge is connected to the two segments it begins listening to the frames transmitted on both sides&#46; It learns which devices are on each side of the bridge by recording the &quot;source&quot; address of each frame in the filter table&#46; All frames will be forwarded if there is an entry in the forwarding table for the &quot;destination&quot; address on the frame&#46; If a subsequent response frame is generated from a forwarded destination addresss device and received from the same side as the original frame then all subsequent frames sent to that device will be filtered&#46; Eventually the bridge will build a complete internal table of devices and their location in terms of which side they reside on&#46;&nbsp;<br>&nbsp;<br>(i&#46;e&#46; bridge/switch learns the filter/switch table based on &quot;src&quot; addr, and then filter/switch based on &quot;dest&quot; addr of L2 frames)&nbsp;<br>&nbsp;<br>Transparent Bridges will by default filter any broadcast or multicast transmissions&#46; This feature can be turned off but doing so severeley limits the effectiveness of the Bridge&#46;&nbsp;<br>&nbsp;<br>Bridges must be controlled to avoid frames being forwarded in an endless loop&#46; A mechanism known as a &quot;Spanning Tree&quot; algorithm is used to help prevent loops&#46; The spanning tree algorithim effectively limits the Bridge to filtering and forwarding in one direction only&#46; This means that all traffic heading in the other direction will automatically be filtered by the bridge&#46; This traffic will be forwarded if necessary by a second bridge attached to the same segment&#46;&nbsp;<br>&nbsp;<br>All Transparent Bridges periodically &quot;Flush&quot; their forwarding tables and rebuild them from scratch&#46; This is to adjust for any network changes or reconfigurations that may have occured&#46; Since the MAC address is physical it can move to other segments if the end device is moved&#46; Since the Bridge filters on this address it would not pass frames destined for it if it moved to the other side&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Source Routing Bridge&nbsp;<br>##&nbsp;<br>&nbsp;<br>Source Routing Bridges contain no internal tables&#46; Instead they look at Routing Information (RI) that has been embedded in the frames &#46;&nbsp;<br>&nbsp;<br>Unlike Transparent Bridges, Source Routing Bridges can support Multi&#45;Path routing&#46; If multiple paths exist, the bridge must have a mechanism for finding resources and the best way to reach them&#46; This is accomplished via a process known as &quot;discovery&quot;&#46;&nbsp;<br>&nbsp;<br>As the name implies, the source device is responsible for determining the entire route&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Source Routing Bridge &#45; Discovery Process&nbsp;<br>#&nbsp;<br>&nbsp;<br>The source device begins by sending out a data link layer control frame known as a &quot;discovery packet&quot;&#46; Each SR bridge inserts its routing information (RI) into the frame as each bridge is crossed &#46;&nbsp;<br>&nbsp;<br>Each device stamps its ID into the frame so that when it returns to the source system the exact path taken can be embedded in subsequent data frames&#46;&nbsp;<br>&nbsp;<br>When the target device is found it constructs a return path based on the reversed RI information in the frame and re&#45;transmits it back to the original source&#46; The return path is embedded in the frame&#46; The source device will use this discovered path (or the shortest one received if multiple are returned) for all subsequent transmissions&#46;&nbsp;<br>&nbsp;<br>If the path fails, it re&#45;discovers the resource&#46; Other advantages of SR Bridges are dynamic load balancing , Fastest path (at discovery time) utilization and higher fault tolerance through path redundancy&#46;&nbsp;<br>&nbsp;<br>The biggest disadvantage is that they generate network traffic which errodes available bandwidth&#46;&nbsp;<br>&nbsp;<br>Mechanisms need to be established to prevent endless discovery frames&#46; These mechanisms include&#58;&nbsp;<br>&nbsp;<br>Hop&#45;count limits&nbsp;<br>&nbsp;<br>Recognition of previously seen discovery frames so the Bridge will not pass same frame twice&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Mixed bridges&nbsp;<br>##&nbsp;<br>&nbsp;<br>Source Routing and Transparent bridges may co&#45;exist ‚Ä¢Called Source Routing Transparent (SRT) Bridges&#46; These are LLC layer bridges used to support Ethernet on the Transparent side and Token Ring or FDDI on the Source Routing Side&#46;&nbsp;<br>&nbsp;<br>Many bridges today filter and forward frames with very little delay, making them good for large traffic volumes&#46; They do however have some negative aspects&#46;&nbsp;<br>&nbsp;<br>Bridges still have inhent shortcommings the most significant being the linier intercinnection of segments&#46; If traffic needs to be sent over multiple segments it must pass through all the bridges (and segments) in the middle&#46; Switches and routers help solve this problem&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Store&#45;and&#45;Forward &nbsp;vs &nbsp;Cut&#45;Through&nbsp;<br>##&nbsp;<br>&nbsp;<br>Transparent Bridges initially used a mechanism known as &quot;Store and Forward&quot; when forwarding or filtering frames&#46; This process requires that the entire frame be stored in a buffer in the bridge and validated as error free before it was forwarded or filtered&#46; This process added delays to the network&#46;&nbsp;<br>A different type of bridge was developed that began the forwarding or filtering process as soon as the destination address on the frame was known&#46; These are known as &quot;cut through&quot; Bridges&#46; While these bridges shortened the delay, they also increased traffic by forwarding error and runt (incomplete due to a collision or some other fault) frames to the other segment&#46;&nbsp;<br>&nbsp;<br>A third variation of a Bridge known as a Hybrid Bridge was developed that began the forwarding/filtering process after the &quot;collision window&quot; time was paseed but potentially before the end of the frame and the CRC check was processed&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Routers&nbsp;<br>###&nbsp;<br>&nbsp;<br>Routers transfer data packets between multiple LANs&#46; With the transmission capabilities built&#45;in, the router is able to evaluate the network environment (traffic) on a per packet basis to make intelligent routing decisions&#46;&nbsp;<br>&nbsp;<br>Routers are frequently tied to other routers so there may be multiple &quot;hops&quot; between the originating source and final destination&#46; Thus, a packet may have to pass through several routers (with multiple pathways) to reach its ultimate destination&#46; In such a case, the intelligence behind the router allows each routing device (along the transmission path of a packet) to identify which path to the destination is best in terms of hop count, congestion and outages&#46;&nbsp;<br>&nbsp;<br>Routers are more complex and more expensive than Bridges and switches&#46; Routers function at the Network Layer of the OSI Model&#46;&nbsp;<br>&nbsp;<br>A frame may pass through many routers on the way to its destination&#46;&nbsp;<br>&nbsp;<br>Routing requires knowledge of two addresses&#58;&nbsp;<br>&nbsp;<br>&#45; the address of the destination device&nbsp;<br>&#45; the address of the next router&nbsp;<br>&nbsp;<br>The Network Layer protocol and by default, the network layer addresses used must be compatable accross all devices in the route&#46; The Physical and Data Link layers need not match&#46;&nbsp;<br>&nbsp;<br>Routers are designed for a specific protocol, Multiple protocols may be routed within the same box&#46; These are called a multi&#45;protocol routers&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Multi&#45;Protocol Routers&nbsp;<br>##&nbsp;<br>&nbsp;<br>Each protocol is purchased and installed seperately just as each network interface is purchased separately&#46; Each protocol requires its own routing tables and routing software&#46;&nbsp;<br>&nbsp;<br>Each protocol needs to be &quot;bound&quot; to the lower layer NIC just as in end devices&#46; If the router is connected to multiple network with different LAN configurations (e&#46;g&#46;, Token Ring, Ethernet and FDDI) then each protocol must be bound to each of these devices&#46;&nbsp;<br>&nbsp;<br>Multi&#45;protocol routers handle information and communication between different networks&#46; For example, Windows systems using NETBUEI protocol, Macintosh systems using AppleTalk protocol, IBM PCs using IPX/SPX protocol, and Internet systems using TCP/IP protocol can all communicate with each other&#46; The multi&#45;protocol router gets all these different types of data packets to the proper destinations&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Single&#45;Protocol Routers&nbsp;<br>##&nbsp;<br>&nbsp;<br>Single Protocol Routers are usually used to do a specific task&#46; Routers that provide premis edge device access or Internet Firewall security are usually single protocol devices&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Routing &nbsp;&#45; &nbsp;Reasons and Options&nbsp;<br>###&nbsp;<br>&nbsp;<br>Routing operates on L3 of the OSI model which means that they have knowledge of how to reach the logical end nodes of the network&#46; Routers can therefore make more intelligent decisions about sending a packet across the network by examining the logical network layer source and destination address of each packet&#46; It only forwards packets destined for a remote network&#46; This eliminates unnecessary traffic and makes better use of bandwidth&#46; Routers are used for the following reasons&#58;&nbsp;<br>&nbsp;<br>&#45; Support multiple and alternate network paths for fault tolerance and load balancing&nbsp;<br>&#45; Provide security and other network restrictions&nbsp;<br>&#45; Efficiently support and utilize complex networks&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Multiple paths]&nbsp;<br>#&nbsp;<br>&nbsp;<br>Since routers understand the end to end delivery of the network transmission it can make intelligent decisions about the delivery of the transmission&#46; Routers can be made aware of alternate paths and use those paths when congestion or failure occurs on the preferred path&#46; This allows for routing layer fault tolerance for mission critical applications&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Security]&nbsp;<br>#&nbsp;<br>&nbsp;<br>Because routers have processing intelligence, they can support processing logic designed to control and restrict network transmissions&#46; A &quot;firewall&quot; is a router that has routing restriction policies incorporated in ts routing process intelligence&#46; A bridge or layer 2 switch is designed by default to forward transmissions destined for physical devices which it does not know&#46; This is very bad from a security perspective&#46; Routers on the other hand will only forward traffic for which it has a identified path&#46; Whereas an internal router has a default gateway as the path when no routing information can be ascertained, a Firewall has no default gateway and will only forward traffic to known paths and only if all the policy conditions are met&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># [Complexity]&nbsp;<br>#&nbsp;<br>&nbsp;<br>Not all networks are comprised of of contiguous Local Area Networks confined to a single building&#46; Many networks consist of devices in multiple, geographically disparate locations&#46; They include WANs, LANs, and perhaps MANs&#46; WANs and MANs do not understand MAC layer LAN addresses, nor do they process data at speeds and packet sizes that would allow their seamless transition from the LAN&#46; Routers can connect to and understand WAN and MAN technologies ans well as LAN technologies&#46; They can use this intelligence to &quot;Tunnel&quot; traffic to a distant location delivering what appears to be a seamless native to native delivery of the information&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Ways to route&nbsp;<br>##&nbsp;<br>&nbsp;<br>Today, most routers are dedicated devices designed specifically for routing&#46; They are the most effective and efficient way to route&#46; They also can handle multiple and many physical connection types, multiple and many network types and multiple and many routing mechanisms&#46; They are also very expensive&#46; There are alternatives that can be used for routing besides a dedicated box&#58;&nbsp;<br>&nbsp;<br>&#45; Use a server (Netware, NT, Unix) as a router&nbsp;<br>&#45; Use a dedicate PC running a routing program&nbsp;<br>&nbsp;<br>In both cases the PC or Server needs connections to all the networks that it wishes to have direct route paths&#46; While using these alternatives allows one to route without investing in additional hardware (assuming the Server or PC and NICs were spares) they will do so at a significantly slower speed than a dedicated router&#46; When you buy a dedicated router you are buying throughput horsepower to avoid or minimize network delays&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;LAN Switches&nbsp;<br>###&nbsp;<br>&nbsp;<br>Using LAN switches allows a network designer to create several small network segments&#46; These smaller segments mean that fewer stations are competing for bandwidth, thereby diminishing network congestion&#46;&nbsp;<br>&nbsp;<br>Today&#039;s local&#45;area networks (LANs) are becoming increasingly congested and overburdened&#46; In addition to an ever&#45;growing population of network users, several factors have combined to stress the capabilities of traditional LANs&#58;&nbsp;<br>&nbsp;<br>&#45; Faster CPUs&#46; (process work faster therefor want faster and more often network services)&nbsp;<br>&#45; Multitasking operating systems&#46; (Multitasking allows users to initiate simultaneous network transactions&#46; )&nbsp;<br>&#45; Network&#45;intensive applications&#46; (Client&#45;server and Internet/Intranet applications are proliferating)&nbsp;<br>&nbsp;<br>Switching is a technology that alleviates congestion in Ethernet, Token Ring, and Fiber Distributed Data Interface (FDDI) LANs by reducing traffic and increasing bandwidth&#46; Such switches, known as LAN switches, are designed to work with existing cable infrastructures so that they can be installed with minimal disruption of existing networks&#46; Often, they replace shared hubs or other intermediary devices like bridges&#46;&nbsp;<br>&nbsp;<br>Switches are used to increase performance on an organization&#039;s network by segmenting large networks into many smaller, less congested LANs, while still transparently providing necessary interconnectivity between them&#46; Switches increase network performance by providing each port with dedicated bandwidth, without requiring users to change any existing equipment, such as NICs, hubs, wiring, or any routers or bridges that are currently in place&#46; Switches can also support numerous transmissions simultaneously&#46; While they are very easy to deploy to improve older LANs, new installations will almost exclusively use switches&#46;&nbsp;<br>&nbsp;<br>Switches provide more flexible segmentation with the ability to &quot;switch&quot; to the appropriate segment to complete transmission&#46; A switch extends the bridging concept from linking two networks together to linking multiple separate segments of the same LAN type&#46; The switch, like the bridge, filters and speeds the data flow between LANs&#46; Unlike a bridge however, the switch can forward the frame to any of the segments attached to it&#46; The following pictures of a bridged versus switched environment shows how switches provide further traffic reduction over bridges&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>(imagine at least a few computers hanging off of each hub segment)&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[hub/bridge&#45;connected LAN]&nbsp;<br>&nbsp;<br>hub segment A &#45;&#45;&#45;|&#45;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#45;|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|H| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|H|&#45;&#45;&#45; hub segment D&nbsp;<br>hub segment B &#45;&#45;&#45;|U|&#45;&#45;[bridge]&#45;&#45;|U|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|B| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|B|&#45;&#45;&#45; hub segment E&nbsp;<br>hub segment C &#45;&#45;&#45;|&#45;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#45;|&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[switch&#45;connected LAN]&nbsp;<br>&nbsp;<br>hub segment A &#45;&#45;&#45;|S|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|W|&#45;&#45;&#45; hub segment D&nbsp;<br>hub segment B &#45;&#45;&#45;|I|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|T|&#45;&#45;&#45; hub segment E&nbsp;<br>hub segment C &#45;&#45;&#45;|C|&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|H|&nbsp;<br>&nbsp;<br>&nbsp;<br>In the bridge environment frames from segment A devices to segment E devices must be forwarded across all segments in between&#46; Therefore the frame will also be traffic on segments B,C,and D as well&#46;&nbsp;<br>&nbsp;<br>In the Switched environment the switch will bridge directly to segment E&#46; The frame from segment A will never hit segments B, C, or D&#46;&nbsp;<br>&nbsp;<br>A switch like bridges can be one of three types&#58;&nbsp;<br>&nbsp;<br>(1) Cut&#45;through/ fast forward (Address recognition)&nbsp;<br>(2) Cut&#45;through/ fragment free (Hybrid &#45; Collision Window)&nbsp;<br>(3) Store&#45;and&#45;Forward&nbsp;<br>&nbsp;<br>The process is the same as the bridge&#46;&nbsp;<br>&nbsp;<br>You can think of a Switch as a device that controls and operates a number of bridges&#46; Each port is a bridge port&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>(nice visualization) &nbsp;http&#58;//www&#46;fiber&#45;optic&#45;solutions&#46;com/buy&#45;ethernet&#45;switch&#45;hub&#46;html&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;FDDI and Switching&nbsp;<br>##&nbsp;<br>&nbsp;<br>FDDI Switching is a way to multiply an FDDI backbone bandwidth by subdividing the shared FDDI backbone with FDDI switching&#46;&nbsp;<br>&nbsp;<br>Conceived as a high capacity LAN backbone technology, FDDI was designed specifically to serve the needs of high&#45;performance mission&#45;critical LAN applications&#46; No other standard LAN medium has the reliability features of FDDI&#46;&nbsp;<br>&nbsp;<br>The dual counter&#45;rotating ring, and dual homing at the MAC layer give FDDI a unique ability to provide redundant, therefore highly reliable, station connection at the MAC layer&#46; These features, and the maturity and reliability of FDDI products and management procedures, make many users wish to extend the life of FDDI networks&#46; Although the 100 Mbps bandwidth of FDDI is sufficient for server and high&#45;end work station connections, 100 Mbps is often not enough total bandwidth for the LAN backbone&#46; FDDI switching can alleviate this problem&#46;&nbsp;<br>&nbsp;<br>An FDDI switch operates by subdividing a single ring into several distinct rings so that the total LAN traffic can greatly exceed 100 Mbps&#46;&nbsp;<br>&nbsp;<br>FDDI Switches (and to a lesser degree, Token Ring Switches) are much more complex than Ethernet switches&#46; They must deal with priorities, frame removal, and ring control/maintenance)&#46;&nbsp;<br>&nbsp;<br>As a result of the cost and the low adoption of FDDI, the most commonly found switches are all Ethernet&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Virtual LANs&nbsp;<br>###&nbsp;<br>&nbsp;<br>A virtual LAN (VLAN) is a group of hosts or network devices, such as routers (running transparent bridging) and bridges/switches, that form a single bridging domain&#46; Layer 2 bridging protocols, such as IEEE 802&#46;10 and Inter&#45;Switch Link (ISL) allow a VLANs to exist across a variety of equipment supporting layer 2 functionality&#46;&nbsp;<br>&nbsp;<br>VLANs are formed to group related users regardless of the physical connections of their hosts to the network&#46; The users can be spread across a campus network or even across geographically dispersed locations&#46; A variety of strategies can be used to group users&#46; For example, the users might be grouped according to their department or functional team&#46; In general, the goal is to group users into VLANs so that most of their traffic stays within the VLAN&#46;&nbsp;<br>&nbsp;<br>When you configure VLANs, the network can take advantage of the following benefits&#58;&nbsp;<br>&nbsp;<br>Broadcast control&#45;&#45;Just as switches physically isolate collision domains for attached hosts and only forward traffic out a particular port, VLANs provide logical collision domains that confine broadcast and multicast traffic to the bridging domain&#46;&nbsp;<br>&nbsp;<br>Security&#45;&#45;If you do not include a router in a VLAN, no users outside of that VLAN will be able to communicate with the users in the VLAN and vice versa&#46; This extreme level of security can be highly desirable for certain projects and applications&#46;&nbsp;<br>&nbsp;<br>Performance&#45;&#45;You can assign users that require high&#45;performance networking to their own VLANs&#46; You might, for example, assign an engineer who is testing a multicast application and the servers the engineer uses to a single VLAN&#46; The engineer experiences improved network performance by being on a &quot;dedicated LAN,&quot; and the rest of the engineering group experiences improved network performance because the traffic generated by the network&#45;intensive application is isolated to another VLAN&#46;&nbsp;<br>&nbsp;<br>Network Management&#45;&#45;Software on the switch allows you to assign users to VLANs and, later, reassign them to another VLAN&#46; Recabling to change connectivity is no longer necessary in the switched LAN environment because network management tools allow you to reconfigure the LAN logically&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Gateways&nbsp;<br>###&nbsp;<br>&nbsp;<br>A gateway is a hardware and software solution that handles internetwork communication between programs that have different network, hardware, and software protocols&#46; Gateways at a minimum mediate incompatible protocol communications between networks&#46; In most cases they are used to interconnect networks that have entirely different architectures&#46; The device understands the data handling formats of each network it interconnects&#46; Gateways are used primarily to interpret mainframe protocols&#46;&nbsp;<br>&nbsp;<br>Gateways link LANs at the session, presentation layers and application layers of the OSI model&#46;&nbsp;<br>&nbsp;<br>Conversions functions performed by Gateways include&#58;&nbsp;<br>&nbsp;<br>(1) message format conversion &#45; Frame format, Min/Max size, Coding&nbsp;<br>&nbsp;<br>(2) Address translation (eg 16 to 48 bit)&nbsp;<br>&nbsp;<br>(3) Protocol Conversion &#45; restructure of control information relating to comparable functions on each net , eg&#46; message segmentation & reassembly, data flow control, AND error detect & recovery&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Three types of gateways&nbsp;<br>##&nbsp;<br>&nbsp;<br>(1) Encapsulating router&nbsp;<br>An Encapsulating router gateway encloses packets from one network in the packet format of the second network for transmission&#46;&nbsp;<br>&nbsp;<br>(2) Transport Level gateways&nbsp;<br>Transport Level gateways also enclose packets in the second protocols packet format but perform this function by using a Layer 4 protocol instead of the layer 3 protocol used in encapsulating routers&#46;&nbsp;<br>&nbsp;<br>(3) Application Layer gateways&nbsp;<br>Application Layer gateways translate all seven layers of one network architecture to the seven layer protocols of another architrecture&#46;&nbsp;<br>&nbsp;<br>Products like Microsoft&#039;s NT SNA Gateway and Novell&#039;s SAA are application layer gateways that translate the full seven layers of the IBM SNA architecture&#46;&nbsp;<br>&nbsp;<br>TN3270 is a transport layer gateway that transports a TCP/IP program called TN3270 directly to an IBM host running TCP/IP or to gateway server that runs a TN3270 Server on one side and an SNA node on the other&#46; At the session layer the TN3270 connection from the client looks identical to a native 3270 session to the SNA host&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>#######################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;&nbsp;WAN &nbsp;(wide area network) &nbsp;&nbsp;&nbsp;###&nbsp;<br>#######################################&nbsp;<br>&nbsp;<br>A WAN is a computer network that covers a broad geographic region, ranging in diameter from a few miles to span entire continents&#46; WANs can transmit all types of information across their lines They are often used to link other networks like private LANs together&#46;&nbsp;<br>&nbsp;<br>WANs can be a comprised of physical media (e&#46;g&#46; cable and fiber optic cabling), travelling along shared or dedicated paths&#46; WANs can also be comprised of wireless mediums using satellite transmission and microwave communication, usually in places where physical media plants cannot be constructed or are cost prohibitive&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;WAN structure&nbsp;<br>#&nbsp;<br>WAN is similar to LAN, in terms of configuration&#46; However, while LANs link pieces of equipment (e&#46;g&#46;, workstations, printers, FAX machines, etc&#46;), WANs usually link other networks&#46;&nbsp;<br>&nbsp;<br>The traditional definition of wide area networking has been &quot;connecting two or more networks existing at widely separate geographic sites&#46;&quot; Traditionalists tend to believe that the separate networks must be connected by means of common carrier telecommunication facilities (private companies that rent resources such as T1 lines and microwave transmission equipment)&#46;&nbsp;<br>&nbsp;<br>like any general term used in connection with rapidly changing technology, not everyone will agree on an exact definition of wide area networking&#46; What is &quot;widely separate&quot; and, does the connection really have to be through a common carrier? Many major companies now own their own equipment linking networks many miles apart&#46;&nbsp;<br>&nbsp;<br>Suppose you connect two networks in two different buildings 100 yards apart by means of asynchronous modems and common telephone lines&#46; Is that a wide area network? Most computer networking people would say no&#46; They would consider this a &quot;campus&quot; network&#46; What if the networks were two miles apart and separated by a major interstate highway? Or, what if they were 15 miles apart, on opposite sides of a major city? There are many computer networking people who would still not call this wide area networking; but rather a &quot;metropolitan area network&#46;&quot; Others consider metropolitan area networking a part of wide area networking&#46; Everyone would agree that two networks connected on opposite sides of a continent by means of a satellite microwave link rented from a common carrier is an example of a wide area network&#46;&nbsp;<br>&nbsp;<br>Speed of the network can no longer be a determining factor either&#46; In the past, higher speed local networks (like 10MBPS Ethernet) were connected via lower speed WANs (1&#46;54MBPS T1&#039;s)&#46; Today these LANs can be interconnected over technologies like 155MBPS ATM or higher DS/OC rates&#46;&nbsp;<br>&nbsp;<br>The point is that the distinction between LANs MANs and WANs are becoming blurred delineated more by a tariff structure rather than a technology or speed&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;WAN Components&nbsp;<br>#&nbsp;<br>the most critical internetworking component to the WAN environment is the Router&#46;&nbsp;<br>&nbsp;<br>Routers link LANs and WANs together, to facilitate a network connection&#46; Routers can integrate components that support the bottom three layers of LAN and WAN technologies supplying translation logic and a common shared backplane for transferring information from LANs to WANs and vice versa&#46;&nbsp;<br>&nbsp;<br>Routers can connect to all types of networks providing integration across the Layer 1&#45;3 protocols&#46; On the LAN side they connect through traditional LAN technologies like Ethernet, Token Ring or FDDI and provide layer three routing functionality (usually IP or IPX)&#46; On the WAN side, they connect to standard Telco &quot;premise&quot; devices like DSU/CSUs (Digital Service Unit/Channel Service Unit&#46;) The router can support a Layer 2 WAN connection providing a point to point dedicated link between two end nodes or full Layer 3 services over virtual packet or cell switched links&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;WAN use case&nbsp;<br>#&nbsp;<br>WANs are often used to transmit other forms of information like voice and video in addition to transmitting computer data&#46; In fact data WANs were developed out of the telephone network&#46; A single WAN connection can be &quot;channel split&quot; to provide voice, data or other transmissions over a single connection&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Public Facilities&nbsp;<br>###&nbsp;<br>&nbsp;<br>A WAN uses communications facilities that are outside the organization&#039;s properties and cross public areas that are regulated by local, national or international authorities&#46; The public switched telephone network (PSTN) typically provides the links between remote sites but some organizations have established their WAN links using microwave, satellite or other communication technologies&#46;&nbsp;<br>&nbsp;<br>WAN infrastructures, unlike LANs, are not owned by the company using them&#46; The company contracts for the right of use of these public channels from a governmentally regulated supplier of these services&#46; Even Microwave and Satellite WANs must be authorized to use the frequency or spectrum of bandwidth on which their data transmissions ride&#46;&nbsp;<br>&nbsp;<br>Public data Networks are nearly always used to build WANs, especially in the case of the Internet&#46; A Public Data Network is a network that is owned the company that owns the WAN&#46; It provides access and use of its public infrastructure to its network customers&#46;&nbsp;<br>&nbsp;<br>The first Data Network was gradually established using the PSTN&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;WAN Technologies&nbsp;<br>###&nbsp;<br>&nbsp;<br>Wide area technologies include&#58;&nbsp;<br>&nbsp;<br>Dial up lines &nbsp;&nbsp;&#58;where modems are used to establish a transmission link over a PSTN&#46;&nbsp;<br>Dedicated lines &#58;where a &quot;T&quot; or &quot;Fractional T&quot; line is &quot;Leased&quot; to provide a point to point dedicated connection between two facilities&#46;&nbsp;<br>Frame Relay &nbsp;&nbsp;&nbsp;&nbsp;&#58;A virtual packet switched &quot;pay as you go&quot; service&#46;&nbsp;<br>SONET &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#58;A dedicated Fiber optic facility that is ring based rather than point to point&#46;&nbsp;<br>X&#46;25 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#58;Traditional packet switched network that dominated the virtual service market before Frame Relay&#46;&nbsp;<br>ATM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#58;A cell switching virtual service&#46;&nbsp;<br>&nbsp;<br>Frame Relay (FR) networks are one form of WAN which has been gaining in popularity over the past few years&#46; Frame Relays&#039; popularity has grown out of its dynamic (virtual) nature and its ability to support (tunnel) SNA as well as TCP/IP network traffic making it highly desirable to companies with unpredictable traffic to unpredictable locations and/or traffic over two distinct network environments&#46;&nbsp;<br>&nbsp;<br>As above, there are a multitude of connectivity options that should be considered when planning a wide&#45;area network installation&#46; The most critical phase of this planning is in the design of the network&#46; There are different topologies that will provide the best possible throughput for the data to your remote locations&#46; In addition, with the most advanced hardware available which allows voice/fax connections to ride free on the existing data lines, thereby giving you &quot;free&quot; long distance service between your geographically spread facilities&#46;&nbsp;<br>&nbsp;<br>A WAN can also be constructed via the Internet which is in a sense a &quot;World&#45;Wide Area Network&#46;&quot; Many organizations are looking to the Internet for connecting their remote offices and mobile employees rather than investing in expensive WANs&#46; For example, a single employee at a remote site (perhaps even working out of their home) can log on to the internet via their local ISP connection and access their corporate web site&#46; Using a secured client at their remote location (using for example a digital certificate) they can link into their secured corporate Intranet through their corporate web site&#46; From the Intranet they could launch an order entry system, run reports, view backlogs etc&#46; just as if they had a dedicated remote connection to the corporate systems&#46;&nbsp;<br>&nbsp;<br>This is just one example of how both technology and human work habits have changed the Wide Area Network Paradyme&#46; WAN&#039;s as originally implemented served two major functions&#58;&nbsp;<br>&nbsp;<br>1&#46; Provide a back end (usually a batched oriented file transfer) connection between two geographically dispersed host systems&#46;&nbsp;<br>2&#46; Provide remote terminal access to the host&#46;&nbsp;<br>&nbsp;<br>Almost all the devices were located in stationary, very static locations&#46; They were very seldom moved to different wide area locations&#46; They were also very deterministic and predictable&#46; The fact that a particular terminal accessed a single application on the host and was used to enter orders from 9&#45;5 EST was known by the network engineer&#46; The exact size of the transmissions between the terminal and the host each time a transmission was sent was also known (limited to an 80 by 24 character array plus a small amount of control overhead)&#46; This made WAN very easy to size and support&#46;&nbsp;<br>&nbsp;<br>Today, users of intelligent PC devices want access to any amount of data or any transaction process on any system from any location&#46; And thanks to Multi&#45;Tasking, they want to do this simultaneously with many systems&#46; This is clearly a more complex and nebulous environment that is significantly more difficult to estimate and manage&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;Public Network Components&nbsp;<br>###&nbsp;<br>&nbsp;<br>The PSTN can be described in terms of the following components&#58;&nbsp;<br>&nbsp;<br>[Local Loops] &#58;Carries a analog or digital signal from business or personal premise to the nearest switch&nbsp;<br>[Switch] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#58;Establishes the connection to another switch in order to go from the source to the destination&#46; Many switches can be involved in this circuit between source and destination&#46;&nbsp;<br>[Trunk Lines] &#58;Carries the digital signal from one switch to another switch over a larger geographical area&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Local Loop&nbsp;<br>#&nbsp;<br>The Local Loop is the part of the network that extend from the Telephone company&#039;s central office&#46;&nbsp;<br>&nbsp;<br>Local Loops are the last remaining components that have analog signaling components&#46; Eventually all local loops will be digital as well&#46; Integrated Services Digital Networks (ISDN) and Digital Subscriber Loop (DSL) as well as digital based solutions from non traditional suppliers (Cable Company, Electric Company, etc&#46;) will replace the remaining analog households&#46;&nbsp;<br>&nbsp;<br>When the Local Loop service is analog, the switch nearest the sender and the switch nearest the receiver (the last ones in the circuit) translate signal between digital and analog)&nbsp;<br>&nbsp;<br>Analog networks require the &quot;edge devices&quot; (the computers that communicate over the analog circuit) to be connected by modems to a telephone line&#46; Once a connection is established via the telephone network, data can be transmitted and received by the two edge devices&#46;There are many communications packages that can establish such a path&#46;&nbsp;<br>&nbsp;<br>With digital networks, the attached devices don&#039;t need a modem&#46; They are capable of directly transmitting digital data onto the network without having to modulate it&#46; The digital network uses very different techniques for transmission and is much faster and more reliable&#46;&nbsp;<br>&nbsp;<br>Packet switched networks involve a digital data service that does not establish a physical connection between the sender and the receiver&#46; Each packet of data is individually addressed and sent independently from the other packets&#46; The network software will assemble and disassemble the packets and each end&#46; This facilitates network performance, reliability and reduces costs&#46;&nbsp;<br>&nbsp;<br>Cell switched networks also do not establish a physical connection between the sender and the receiver&#46; Unlike packet switching which addresses each packet individually, cell switching establishes a &quot;virtual switched path&quot; for all cells with the same address to follow&#46;&nbsp;<br>&nbsp;<br>You can have a private network, which means that you have a permanent link that you lease, called a leased line or dedicated line&#46; You do not have to &#039;dial&#45;up&#039; this line, it always exists&#46;&nbsp;<br>&nbsp;<br>All of these Network options connect to the customer through the local loop&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Switches&nbsp;<br>#&nbsp;<br>The Telephone switch is the heart of the telephone network&#46; The switch establishes the virtual circuit between the caller and the dialed receiver&#46; A call placed to neighbor within the same &quot;exchange&quot; may be processed by a sing switch&#46; A call placed to another continent will involve several switches&#46; The &quot;address&quot; used to determine the route of the call is the phone number&#46; The most important information for routing is placed at the beginning of the phone number address&#46; Dialing a &quot;1&quot; immediately triggers the first rout path to an interexchange switch rather than the local exchange&#46;&nbsp;<br>&nbsp;<br>The local CO (Central Office) exchange switch supports the local telephone services (Local Loop)&#46; In the case of an analog local loop the switch supports analog transmissions on the local dial tone side&#46; All transmissions from that point forward will be digital until it reaches the destination local loop in which case will be converted back to analog it the destination exchange is analog&#46; A local call within the same exchange will be processed entirely as an analog transmission if the exchange is analog&#46;&nbsp;<br>&nbsp;<br>PBX&#039;s or Private Branch Exchanges are switches that create a local loop exchange inside the boundaries of a private facility&#46; To the telephone network the PBX is just another switch in the telephone routing hierarchy&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Trunk Lines&nbsp;<br>#&nbsp;<br>Trunk Lines are the cabling plant that interconnect the switches&#46; The trunk lines provide multiplexed digital signaling of calls from one switch to another&#46; All trunk lines in operation today utilize digital signaling over fiber optic cable&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Intro to Digital Signaling&nbsp;<br>###&nbsp;<br>&nbsp;<br>[Digital Signaling History]&nbsp;<br>Telephone systems were originally all analog systems&#46; They were conceived as a mechanism to move voices or sounds&#46; The concept of &quot;data transmission&quot; was decades away&#46; The system did however have to move the voice transmissions over greater distances as the telephone system became more popular&#46; Earlier in the semester we talked about the drawbacks of analog signaling; most notably, the unavoidance of noise and interference amplification and retransmission&#46;&nbsp;<br>&nbsp;<br>In the early 1960&#039;s the &quot;T&#45;carrier&quot; system was implemented by the Bell System as a means of increasing the capacity of existing trunks between Central Offices&#46; Research performed at Bell Labs led to the technology which allowed 24 voice channels to be &quot;multiplexed&quot; and digitally transmitted in one direction using Pulse Code Modulation (PCM) on a single twisted pair&#46; The required electronics were much cheaper than installing more cable&#46; Since the PCM transmission was much less susceptible to noise and crosstalk, an added benefit of this increased capacity solution was a dramatic improvement in the signal quality as well&#46; This was due to the fact that the digital signal could be &quot;re&#45;shaped&quot; to its original form and regenerated at its original strength and quality&#46; As technologies advanced digital signaling capabilities increased as well&#46; Digital signaling was standardized on a hierarchical structure that was based on&#58;&nbsp;<br>&nbsp;<br>&#45; The analog signaling system&nbsp;<br>&#45; The PCM conversion of the analog signal&nbsp;<br>&nbsp;<br>The PCM conversion of the analog signal to digital to support the 24 channel multiplexed transmission identified above became the base digital signaling rate&#46; Higher rates were accomplished by multiplexing these signals into higher bandwidth transmissions&#46; In other words the base digital signal is a direct multiple of the analog signaling rate and all higher digital signaling rates are multiples of the base signaling rate&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Digital Signaling(transmission) Hierarchies&nbsp;<br>###&nbsp;<br>&nbsp;<br>There are two hierarchical structures that exist for digital networks&#58;&nbsp;<br>&nbsp;<br>&#45; Plesiochronous hierarchies (Plesiochronous means &quot;nearly synchronous&quot;)&nbsp;<br>&#45; Synchronous hierarchies&nbsp;<br>&nbsp;<br>To further complicate things, North American standards (usually derived from US standards bodies) are different from the International ITU&#45;T recommendations&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Plesiochronous Hierarchies&nbsp;<br>##&nbsp;<br>In a Plesiochronous hierarchy, the higher level multiplex functions include &quot;bit stuffing&quot; techniques&#46; This allows the input bit streams from I/O channels to use free&#45;running&quot; clocks&#46; As such, the user&#039;s clock rate is propagated (plus a little &quot;Jitter&quot;) through the higher level multiplexer&#46; Slip rates requirements between End&#45;User multiplex equipment must still be met, for adequate performance of voice and (particularly) data&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;North American Digital hierarchy&nbsp;<br>#&nbsp;<br>The North American Digital hierarchy starts off with a basic Digital Signal level of 64 KBPS (DS0)&#46; Thereafter, all facility types are usually referred to as &quot;T x&quot;, where &quot;x&quot; is the Digital Signal level within the hierarchy (e&#46;g&#46; T1 refers to the DS1 rate of 1&#46;544 MBPS)&#46; Up to the DS3 rate, these signals are usually delivered from the provider on Twisted&#45;Pair or Coaxial cables&#46;&nbsp;<br>&nbsp;<br>DS stands for &quot;Digital Stream&quot;&#46; The transmission speed of each digital stream is identified by the number that follows the DS&#46; The letter &quot;T&quot; was originally used in reference to the physical &quot;Transmission repeater&quot; system developed to transmit over four wire twisted pair (bi&#45;directional transmission with outgoing signals on one pair and incoming on the other&#46;)&nbsp;<br>&nbsp;<br>North American T1 service providers often refer to the signal interface between the User and the Network as &quot;DS&#45;1&quot; signals&#46; The DS hierarchy and associated speeds for the first five levels are listed in the following table&#46;&nbsp;<br>&nbsp;<br>Name &nbsp;Rate &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# of DS0s&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>DS0 &nbsp;&nbsp;64 KBPS &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;<br>DS1 &nbsp;&nbsp;1&#46;544 MBPS &nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;<br>DS1C &nbsp;3&#46;152 MBPS &nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;<br>DS2 &nbsp;&nbsp;6&#46;312 MBPS &nbsp;&nbsp;&nbsp;&nbsp;96&nbsp;<br>DS3 &nbsp;&nbsp;44&#46;736 MBPS &nbsp;&nbsp;&nbsp;672&nbsp;<br>&nbsp;<br>DS1 signals can be multiplexed with other DS1&#039;s into higher rate signals for transmission via other media, e&#46;g&#46;, coaxial cable, microwave, and fiber optic cable&#46;&nbsp;<br>&nbsp;<br>Hence a DS1C is 2 DS1&#039;s (plus additional framing overhead) and a DS2 is 4 DS1&#039;s plus overhead&#46;&nbsp;<br>&nbsp;<br>DS1 is the lowest rate that can be multiplexed asynchronously&#46; As long as the signal is within specifications, the telephone network multiplexers will lock on the framing pulses, transport the signal through the network and hand it back at the same frequency it was received&#46; In order to accomplish this, the subscriber&#039;s equipment must generate the signal in accordance with stringent requirements&#46; The frequency of the bit stream must be 1544000 + or &#45; 75 bits per second&#46; The pulse shape must conform to FCC rules&#46; A zero is represented by zero volts; a one is represented by either plus 3 volts or minus 3 volts (opposite polarity of the preceding one)&#46; This is called bipolar signaling or Alternate Mark Inversion (AMI)&#46; This type of signaling places a null in the signal at DC allowing power to be sent on the line&#46; It also allows timing to be extracted from the bit stream provided there are no long strings of zeros&#46;&nbsp;<br>&nbsp;<br>12&#46;5% of all bits must be ones, and there can be no more than 15 zeros in a row&#46; These are known as &quot;ones density&quot; requirements and are necessary to insure that the network repeaters do not jitter and lose sync&#46; Framing pulses must conform to a pattern known as D4&#46; This pattern is recognized by the network multiplexers and is required if the DS1 signal is to be multiplexed with other DS1 signals for transmission over microwave or fiber optic cable&#46;&nbsp;<br>&nbsp;<br>Since the early 1980&#039;s, DS1 service has been available to individual subscribers as a tariffed point to point dedicated service&#46; Virtually any twisted pair can be configured as a T1&#46; It can be ordered as a point to point DS1 or T1 circuit&#46; DS1 and T1 tend to be used interchangeably&#46; It may also be called 1&#46;5 Megabit service&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;International (CCITT) Digital hierarchy&nbsp;<br>#&nbsp;<br>The ITU&#45;T Digital hierarchy&#039;s basic level is the DS0 rate of 64 KBPS&#46; These signals are usually delivered from the provider on Twisted&#45;Pair or Coaxial cables&#46; The European standards are summarized below&#46;&nbsp;<br>&nbsp;<br>Name &nbsp;Rate&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>DS0 &nbsp;&nbsp;64 KBPS&nbsp;<br>E1 &nbsp;&nbsp;&nbsp;2&#46;048 MBPS&nbsp;<br>E2 &nbsp;&nbsp;&nbsp;8&#46;448 MBPS&nbsp;<br>E3 &nbsp;&nbsp;&nbsp;34&#46;368 MBPS&nbsp;<br>E4 &nbsp;&nbsp;&nbsp;139&#46;264 MBPS&nbsp;<br>&nbsp;<br>An important consequence of the different digital hierarchies between Europe and the US is that only a discreet set of fixed rates are available for transmissions that cross the digital hierarchies&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Synchronous Hierarchies&nbsp;<br>##&nbsp;<br>In the later 1980s, synchronous network hierarchies were defined&#46; In Synchronous networks, all multiplex functions operate using clocks derived from a common source&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;North American SONET (Synchronous Optical NETwork)&nbsp;<br>#&nbsp;<br>This system is based upon multiples of a fundamental rate of 51&#46;840 MBPS, called STS&#45;1 (Synchronous Transport Signal, Level 1)&#46; The facility designators are similar, but indicate the facility type, which is usually Fiber Optic Cable (e&#46;g&#46; OC&#45;1 is an Optical Carrier supporting a STS&#45;1 signal; while OC&#45;3 supports a STS&#45;3 signal, etc)&#46; Some typical rates are listed below&#58;&nbsp;<br>&nbsp;<br>Name &nbsp;&nbsp;&nbsp;Rate&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>STS&#45;1 &nbsp;&nbsp;51&#46;840 MBPS&nbsp;<br>STS&#45;3 &nbsp;&nbsp;155&#46;520 MBPS&nbsp;<br>STS&#45;9 &nbsp;&nbsp;466&#46;560 MBPS&nbsp;<br>STS&#45;12 &nbsp;622&#46;080 MBPS&nbsp;<br>STS&#45;48 &nbsp;2488&#46;320 MBPS&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;International SDH (Synchronous Digital Hierarchy)&nbsp;<br>#&nbsp;<br>This system is based upon a fundamental rate of 155&#46;520 MBPS, three times that of the SONET system&#46; This fundamental signal is called STM&#45;1 (Synchronous Transport Module, Level 1)&#46; The typical transmission media is defined to be fiber, but the Broadband ISDN specification does define a User&#45;Network Interface (UNI) STM&#45;1 (155&#46;520 MBPS) operating over coaxial cables&#46; Some typical rates within this hierarchy&#58;&nbsp;<br>&nbsp;<br>Name &nbsp;&nbsp;&nbsp;Rate&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>STM&#45;1 &nbsp;&nbsp;155&#46;520 MBPS&nbsp;<br>STM&#45;3 &nbsp;&nbsp;466&#46;560 MBPS&nbsp;<br>STM&#45;4 &nbsp;&nbsp;622&#46;080 MBPS&nbsp;<br>STM&#45;16 &nbsp;2488&#46;320 MBPS&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Analog versus Digital&nbsp;<br>###&nbsp;<br>Analog signals are continuous waves that can represent an unlimited number of values&#46; Telephone systems use analog&#45;switched lines to provide voice communications&#46; Data communication over analog lines has a limited transmission speed because of the narrow bandwidth of voice lines&#46;&nbsp;<br>&nbsp;<br>When transmitting data over phone lines, a modem is required to convert the digital data signals to analog signals&#46; When analog signals are transmitted over long distances, they need to be amplified, which can distort the value of the data transmitted&#46;&nbsp;<br>&nbsp;<br>When analog data is converted to digital data it can be transmitted over digital signals faster and without distortion&#46; Discreet samples of binary data make up the content of the payload&#46; Digital data is precise, but can never transmit the range of information available with analog&#46;&nbsp;<br>&nbsp;<br>The digital signal is transmitted in a binary code using 0&#039;s and 1&#039;s&#46; Either the signal is on (1) or it is off (0)&#46; The analog signal, on the other hand, is a wave of information that contains a continuous flow of varying voltage&#46; As the analog wave travels over the air and into homes, it can collect noise (snow, ghosts)&#46; The digital signal, on the other hand, arrives exactly as it was sent&#46;&nbsp;<br>&nbsp;<br>when a device receives a digital signal, it is given precise data on how to reproduce an exact duplication of the original image or sound&#46; An analog receiver only gets a narrower range of information, and will approximate the original image or sound&#46; This representation may be close to the original image, but usually will not be an exact duplication&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;AD conversion&nbsp;<br>###&nbsp;<br>&nbsp;<br>x&#45;axis = time&nbsp;<br>y&#45;axis = voltage&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Sampling frequency&nbsp;<br>##&nbsp;<br>&nbsp;<br>recall digital signaling was developed as a mechanism to increase CO back end capacity by multiplexing 24 analog transmissions&#46; The analog signal (an electromagnetic wave) generated on each channel is &quot;sampled&quot;&#46; The sample is converted into an 8bit representation of the sampled signal&#46;&nbsp;<br>&nbsp;<br>A sample is simply a detection of a distinct point along the electromagnetic wave&#46;&nbsp;<br>&nbsp;<br>By knowing the sample detection points in terms of where they lie on the Y axis (in terms of their +/&#45; distance from zero) and on the X axis (by knowing the exact time intervals between samples) the exact location of the sampled value can be documented&#46; This value is documented by an 8bit value as a digital representation of the sample location&#46;&nbsp;<br>&nbsp;<br>On the other side of the transmission, the digital signal is converted back to analog and sent down each of the 24 channels&#46; The 8bit digital &quot;points&quot; provide enough information about the height and slope to be able to &quot;plot&quot; the structure of the wave&#46; The height (maximum +/&#45; from zero) allows the amplitude to be reconstructed and the slope (the uniform grade at which the line moves from/towards zero as it moves down the x axis) allows the frequency to be reconstructed&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Quantization&nbsp;<br>##&nbsp;<br>In order to &quot;digitize&quot; an analog signal, the signal level at the instant of sampling is converted to a binary number by an analog to digital converter&#46; The number of bits in this binary number determines the number of levels that the signal will be &quot;quantized&quot; into&#46; Because the information that lies between these levels is lost, the number of levels used determines the dynamic range and distortion of the recovered analog signal&#46; If eight bits are used, 256 levels can be determined&#46; This yields a dynamic range of about 48 kB and about 0&#46;5% distortion at full output&#46; Each bit added doubles the number of levels, increases the dynamic range by 6 dB, and decreases the distortion by a factor of two&#46; For example, 14 bits yield 16384 levels, a dynamic range of about 84 dB, and about &#46;01% distortion&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Analog Telephone Sampling&nbsp;<br>##&nbsp;<br>in 1930s, Harry Nyquist defined a formula which states that if an analog signal is sampled at a rate greater than &quot;twice&quot; its bandwidth the samples will provide all the information needed to accurately reconstruct the signal&#46;&nbsp;<br>&nbsp;<br>A 3 kHz analog voice telephone channel is first band limited to around 3300 Hz&#46; This signal is sampled at an 8 kHz rate (8000 samples per second)&#46; Each sample is quantized to 8 bits&#46; This means that a voice channel requires 64000 bits per second to transmit (8000 samples X 8bits)&#46; This 64Kbit signal is called a DSO (Digital Stream hierarchy level 0) channel&#46; 24 DS0 channels are combined along with 8000 bits per second for framing to make a DS1 (T1) signal&#46; The equipment that accomplishes this is called a Channel Bank&#46; The DS1 (T1) signal has a bit rate of 1544000 bits per second (1&#46;544 Mbps) [(64000 X 24) + 8000]&#46;&nbsp;<br>&nbsp;<br>Bell Lab research team found that a telephone cable twisted pair could accept this high a bit rate provided the terminating impedance was lowered to 100 ohms and regenerative repeaters were installed every 6000 feet maximum&#46; These repeaters &quot;interpreted&quot; the degraded incoming signal as a one or a zero and sent a perfect (re&#45;shaped) one or zero to the next repeater&#46; Hence the quality of the bit stream at the terminating end was as good as the original signal generated at the other end&#46;&nbsp;<br>&nbsp;<br>Since the analog signal is encoded in the numbers represented by the digital bit stream, the distortion and noise of the recovered analog signal is not affected by the transmission medium so long as there are no bit errors&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Switching Techniques&nbsp;<br>###&nbsp;<br>while original telegraph systems were comprised of point to point connections between two end nodes (i&#46;e&#46; your phone always only connects to a particular end point only), it was recognized that the telephone needed to connect any combination of end nodes to form a communication connection&#46; This was originally accomplished by a &quot;Switch board&quot; where a human operator would physically connect on pair of wires to another pair by plugging in the appropriate jacks&#46; Thus the concept of switching was born&#46;&nbsp;<br>&nbsp;<br>there are a few ways to perform switching&#58;&nbsp;<br>&nbsp;<br>&#45; Circuit Switching&nbsp;<br>&#45; Packet Switching&nbsp;<br>&#45; Message Switching&nbsp;<br>&#45; Cell Switching&nbsp;<br>&nbsp;<br>[Circuit Switching]&nbsp;<br>This method involves the physical interconnection of two devices&#46; A good example of circuit switching involves the Public phone network&#46; A data example would be the classic A/B switch used to switch from one printer to another (in the old DOS days!)&nbsp;<br>&nbsp;<br>[Packet Switching]&nbsp;<br>Packet Switching techniques switch packets of data between destinations&#46; Traditionally, this applied to X&#46;25 techniques, but this also applies to TCP/IP and IPX/SPX routers also&#46; Frame Relay switches are also packet based&#46;&nbsp;<br>&nbsp;<br>[Message Switching]&nbsp;<br>Message Switching techniques were originally used in data communications&#46;&nbsp;<br>e&#46;g&#46;&nbsp;<br>&#45; early &quot;store and forward&quot; paper tape relay systems&#46;&nbsp;<br>&#45; email delivery&nbsp;<br>&#45; in voice systems, you can find Voice Mail delivery systems on the Internet&#46; The &quot;forward voice mail&quot; capability in some voice mail systems&#46;&nbsp;<br>&nbsp;<br>[Cell Switching]&nbsp;<br>Cell Switching is similar to packet switching, except that the switching does not necessarily occur on packet boundaries&#46; This is ideal for an integrated environment and is found within Cell&#45;based networks, such as ATM&#46; Cell&#45;switching can handle both digital voice and data signals&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Packet switching VS Cell switching&nbsp;<br>###&nbsp;<br>[similarity]&nbsp;<br>&#45; breaks data stream into packets which are then placed on lines that are shared by several streams&#46;&nbsp;<br>[difference]&nbsp;<br>&#45; cells have a fixed size while packets can have different sizes&#46; This makes it possible in principle to offer bounded delay guarantees (since a cell will not get stuck for a surprisingly long time behind an unusually large packet)&#46;&nbsp;<br>&#45; how the route is established and maintained&#46; Packet switches route each packet individually&#46; Packets can arrive at their destination by taking different paths depending on least cost delivery and congestion algorithms used by the network&#46; Hence packet switching, like routing, is often referred to as a &quot;route and forget&quot; technology&#46; Cell switching establishes a dedicated path in the form of a virtual connection upon which all cells destined for the same end node will ride&#46; it is a &quot;learn once route many&quot; approach&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;X25 &nbsp;packet switching&nbsp;<br>###&nbsp;<br>&nbsp;<br>Packet switching was devised to solve problems in the telephone system infra where telephone lines having various quality levels not sufficient to provide reliable connections for data applications&#46; Packet switching was a solution that provided an effective workaround for unpredictable reliability on the network&#46;&nbsp;<br>&nbsp;<br>Traditional voice services are TDM (time division multiplexing) where data (voice) is sent as a continuous stream through the network from one end to the other &#45; if any problem during transmission (e&#46;g&#46; some data was lost or corrupted) the two people conversing would simply ask each other to repeat what they had said&#46; With the data services, loss or corruption of data could mean that whole sections of data are of no use to the end destination&#46; Imagine the case of someone transferring a bank statement from one computer to another&#45; an error anywhere in the transmission could prove disasterous&#46;&nbsp;<br>&nbsp;<br>Packet switching method breaks up data into smaller pieces, and provides a way for the data to be verified by the destination&#46; In this mode, in case of missing/corrupt pieces, then only those pieces need to be resent, drastically reducing the amount of time (and the opportunities for errors) in overall data transmissions&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Impact of Packets]&nbsp;<br>&nbsp;<br>Packet switching comes at a cost &#45; because the process takes large pieces of data and breaks it up into smaller ones, the smaller pieces need to be &quot;labelled&quot; so the destination can put the pieces togther again&#46; This labelling means that there is additional overhead, and consequently more bandwidth&#46; When X25 was first being implemented, the network reliability demanded a method to ensure that the data was getting from one end to another without errors, so the additional overhead was accepted to address the issue at hand&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;HDLC and Packet Info&nbsp;<br>###&nbsp;<br>&nbsp;<br>HDLC = High&#45;level Data Link Control&nbsp;<br>&nbsp;<br>recall packets contain some overhead used for data integrity check (e&#46;g&#46; CRC)&#46; HDLC is used to tell the equipment in the network what kind of data is contained within the packet&#46; This is used to tell the equipment whether the packet contains customer data, or if it is information about other equipment in the network&#46; The three types of HDLC frames are (I) Information, indicating the packet contains data, (S) Supervisory, indicating the packet contains information about the state of network equipment, and Unnumbered, indicating other control parameters that are used by the network devices&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Additional Packet Overhead]&nbsp;<br>&nbsp;<br>The Packet header contains additional information after the HDLC&#46; Here are the next three pieces of data&#58;&nbsp;<br>&nbsp;<br>GFI&#58; General Format Identifier&#46; This tells the equipment if the data is end&#45;user data or network equipment data&#46;&nbsp;<br>LGN&#58; Logical channel Group Number&#46; This is half of the information used to identify a particular connection in the X&#46;25 network&#46;&nbsp;<br>LCN&#58; Logical Channel Number&#46; This is the second half, indicating the channel number within the specifcied group&#46;&nbsp;<br>&nbsp;<br>The LGN and LCN specify how the data is routed &#45; PVCs are Permanent Virtual Circuits, that are setup my operators in the Central Office that are &quot;fixed&quot; routes from equipment to equipment&#46; SVCs are Switched Virtual Circuits, and are setup on the fly by a system of signals sent from one piece of equipment to another&#46; This is an automatic process that allows bandwidth to be actively changed depending on the load of the network&#46;&nbsp;<br>&nbsp;<br>The Packet Type is then included in the overhead, which are the various requests and replies that the equipment will signal to each other to complete connections and transfer the data&#46;&nbsp;<br>&nbsp;<br>&#45;&#45; [Cyclical Redundancy Check (CRC)]&nbsp;<br>&nbsp;<br>After the data in the packet comes a CRC field&#46; This allows the receiving system to verify the contents in the packed received match the contents of the packet originally sent&#46; The CRC is not perfect, but depending on how many bits the CRC field is, the closer to 100% guarantee that it will detect a difference in the data it gets&#46; For example, a 16&#45;bit CRC field will detect an error in 99&#46;9999% of the potential cases&#46; This is high enough that the chance that a bad packet would get through undetected is virtually zero&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Frame Relay&nbsp;<br>###&nbsp;<br>&nbsp;<br>Frame Relay == an improvement on the X&#46;25 packet switching concept&#46; As the networks evolved, the needs changed, and the following were the major trends&#58;&nbsp;<br>&nbsp;<br>&#45; Applications were driving a need for increased speed and performance&nbsp;<br>&#45; The expanding base of intelligent data devices on the network&nbsp;<br>&#45; Increased reliability in the core telephone network&nbsp;<br>&#45; Increase of LANs and the need to internetwork across WANs&nbsp;<br>&nbsp;<br>&nbsp;<br>&#45;&#45; [Guarantees]&nbsp;<br>&nbsp;<br>The key to Frame Relay is in the packet header &#45; important fields are as follows&#58;&nbsp;<br>&nbsp;<br>FECN &#58; Forward Explicit Congestion Notification&nbsp;<br>BECN &#58; Backward Explicit Congestion Notification&nbsp;<br>&nbsp;&nbsp;DE &#58; Discard Enable&nbsp;<br>&nbsp;<br>FECN and BECN bits are set by the network equipment as it processes the data and routes it along through the network&#46; This allows the network equipment to automatically propagate messages that the network is getting congested in either direction of the data flow, and the systems can then accomodate the changes appropriately and effectively adjust their own transmission speeds to level the &quot;burstiness&quot; of the network overall&#46; This means that the overall uage level of the network can go up, because the level of traffic is being monitored and adjusted on the fly&#46; This allows the providers to place a price on a &quot;guaranteed&quot; level of data rate, and use more of the bandwidth of the network all the time&#46;&nbsp;<br>The guarantees are not perfect, though in the case of bursts of data, there is still a certain response time that the network has to deal with congestion, and this response time may mean that data during a heavy burst can still be lost&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;ATM Cell Switching&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall the fundamental difference in Cell swtching VS Packet switching is that cell is fixed size, whereas packets are variable size&#46;&nbsp;<br>&nbsp;<br>ATM (Asynchronous Transfer Mode) cells are 53 bytes (whereby 5 bytes = header information, and 48 bytes = data)&#46;&nbsp;<br>53 may seem small, compared to upto 4000+ bytes for frame relay packets, and even 1500 bytes for Ethernet frame&#46; The advantage comes from the way the data can be handled by the equipment&#46; Within the header of the ATM cell, there is error correction, but at the cell level, there is little intelligence&#46; The ATM cell by itself simply tells the receiver what &quot;circuit&quot; the data is in&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&#45;&#45; [SAR (Segmentation and Reassembly)]&nbsp;<br>&nbsp;<br>SAR is an important piece to ATM protocol, as it is responsible for managing the process of conversion from protocol/service specific data into transmission ready cells&#46; It is here that the advantages for bandwidth guarantees come in the form of Constant Bit Rate (CBR) and Variable Bit Rate (VBR) services&#46; These services allow data streams to be monitored to provide a guarantee of a specific level of bandwidth to be allocated to a specific stream&#46;&nbsp;<br>&nbsp;<br>These guarantees are why many network equipment manufacturers use ATM internally to their equipment to manage the data, even if the product is not an ATM switch&#46; Sometimes you will see in a specification that a particular device uses an ATM backplane to accomplish the particular equipment&#039;s purpose&#45; it is often the case because ATM has the guarantees and scales well to handle the higher speed transmissions&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>tagged vLAN&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>####################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;IP (internet protocol) &nbsp;&nbsp;&nbsp;### &nbsp;&nbsp;L3 / network layer&nbsp;<br>####################################&nbsp;<br>&nbsp;<br>IP facilitates packet(data) routing(delivery)&#46;&nbsp;<br>IP is &quot;best effort&quot; protocol&#46; no guarantee&#46; some packets may be dropped if network is congested&#46; error checking/correction is usually done in its upper layer (e&#46;g&#46; TCP/UDP) &#45; it really depends on the application&#46; for example, video streaming, UDP, but other more secure transaction where every bit counts, then TCP, etc&#46;&nbsp;<br>&nbsp;<br>e&#46;g&#46; IP doesn&#039;t offer msg &#039;receipt&#039; ack method&#46; TCP does&#46;&nbsp;<br>&nbsp;<br>IP encapuslates higher layer packets/data&#46; IP packet is independent&#46; i&#46;e&#46; no packet order is maintained&#46; higher layer protocl needs to facilitate that&#46;&nbsp;<br>&nbsp;<br>other L3 layer protocols include&nbsp;<br>&#45; ICMP (internet control msg protocol) &#45; used in ping/traceroute&#46; supports unicast&#46;&nbsp;<br>&#45; IGMP (internet group mgmt protocol) &#45; supports multicast (one&#45;to&#45;many), suitable for online video streaming, gaming&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>https&#58;//en&#46;wikipedia&#46;org/wiki/Internet_Control_Message_Protocol&nbsp;<br>https&#58;//en&#46;wikipedia&#46;org/wiki/Internet_Group_Management_Protocol&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IP header &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# we assume IPv4 for now&nbsp;<br>###&nbsp;<br>&nbsp;<br>see this &#45; https&#58;//en&#46;wikipedia&#46;org/wiki/IPv4#Packet_structure&nbsp;<br>&nbsp;<br>one word = 32 bit (i&#46;e&#46; 4 bytes)&nbsp;<br>&nbsp;<br>IP header is expressed by how many words&#46; i&#46;e&#46; a multiple of 32 bits (i&#46;e&#46; 4 bytes)&nbsp;<br>as below, IHL defines the length of each header&#46; min = 5 words (i&#46;e&#46; 20 bytes), max = 15 words (60 bytes)&nbsp;<br>note not every field is used in every packet&#46;&nbsp;<br>&nbsp;<br>&nbsp;4 bits &#58; version (like v4, v6)&nbsp;<br>&nbsp;4 bits &#58; IHL (internet header length) where min = 5 words (i&#46;e&#46; 20 bytes), max = 15 words (60 bytes)&nbsp;<br>&nbsp;6 bits &#58; DSCP (differentiated services code point) &#45; aka &quot;ToS&quot; (types of service) is specified e&#46;g&#46; &quot;VoIP&quot; voice over IP is a &quot;real&#45;time&quot; type of service&#46;&nbsp;<br>&nbsp;2 bits &#58; ECN (explicit congestion notification) &#45; used to facilitate end&#45;to&#45;end notification of network congestion&#46; an optional feature&#46;&nbsp;<br>16 bits &#58; total length &#45; indicates the total packet size (= header + data)&#46; max is 65535 bytes (64KB) &#45; but further fragmentation may be necessary (e&#46;g&#46; ethernet MTU is 1500 bytes) in which case, router or host fragments packets&#46;&nbsp;<br>&nbsp;<br>e&#46;g&#46; max TCP packet size is 65535 bytes (64KB), but in practice, packet size is smaller because lower layers (e&#46;g&#46; ethernet) impose lower packet size limit&#46; recall MTU (max transmission unit) for ieee 802&#46;3 (ethernet) is 1500 bytes&#46;&nbsp;<br>&nbsp;<br>&nbsp;3 bits &#58; flags where bit 0 = reserved, bit 1 = DF(dont fragment), bit 2 = more gragments&#46; &nbsp;so router discards packet if it needs to fragment but bit 1 = True&nbsp;<br>13 bits &#58; fragment offset&nbsp;<br>&nbsp;8 bits &#58; TTL (time to live) &#58; supposed to be in seconds, but in practice uased as max hop count&#46; each router decrements TTL, if hits 0, then discard packet&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(prevents infinite loop of a packet)&nbsp;<br>&nbsp;8 bits &#58; protocol number (&#46;e&#46;g 6=TCP, 17=UDP) &nbsp;https&#58;//en&#46;wikipedia&#46;org/wiki/List_of_IP_protocol_numbers&nbsp;<br>16 bits &#58; header checksum &#45; each router computes the checksum of the header of every packet, and if mismatch, then discard the packet&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;note the checksum/integrity of the payload/data must be handled by upper layer&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let me quote wikipedia &#45; &quot;An IP packet has no data checksum or any other footer after the data section&#46; Typically the link layer encapsulates IP packets in frames with a CRC footer that detects most errors, and typically the end&#45;to&#45;end TCP layer checksum detects most other errors&#46;&quot;&nbsp;<br>&nbsp;<br>32 bits &#58; src IP addr&nbsp;<br>32 bits &#58; dst IP addr&nbsp;<br>&nbsp;X bits &#58; options (theoretically cannot exceep 40 bytes)&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IP routing table&nbsp;<br>###&nbsp;<br>&nbsp;<br>contains&nbsp;<br>&#45; dest IP addr (can be network or host addr)&nbsp;<br>&#45; next hop IP addr (where to send next)&nbsp;<br>&#45; flags (specific instructions/config, etc)&nbsp;<br>&#45; available NICs (in the router/computer), gateway router may have multiple NICs, each with a distinct IP addr&#46;&nbsp;<br>&nbsp;<br>routing table configuration/mgmt can be &quot;static&quot; or &quot;dynamic&quot;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;IP routing protocols&nbsp;<br>###&nbsp;<br>&nbsp;<br>in essence, every node in LAN needs to know &quot;default router&quot; aka &quot;gateway&quot; that can interface with external networks&#46;&nbsp;<br>&nbsp;<br>every router&#58;&nbsp;<br>1&#46; &#45; if dest IP addr found in its routing table, then directly send to it&nbsp;<br>2&#46; &#45; else if at least network addr found for desk IP addr (like IP addr in this range, send to this IP addr router), then send to it&nbsp;<br>3&#46; &#45; else send to the default router (if available)&nbsp;<br>4&#46; &#45; else discard the packet&nbsp;<br>&nbsp;<br>&nbsp;<br>there are quite a few routing protocls&#46; e&#46;g&#46; RIP, OSPF&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;classful networks, subnet & subnet mask&nbsp;<br>###&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nnn&#46;nnn&#46;nnn&#46;nnn &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# common octet form, nnn = [0,255]&nbsp;<br>&nbsp;<br>********&#46;********&#46;********&#46;******** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# binary form, * = {0,1}&nbsp;<br>&nbsp;<br>&nbsp;<br>==&gt; they break down the 32 bits into&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first X bits = &quot;network&quot; ID&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next Y bits = &quot;subnet&quot; ID &nbsp;&nbsp;&nbsp;&nbsp;# can be Y=0&nbsp;<br>&nbsp;remaining Z bits = &quot;host&quot; ID&nbsp;<br>&nbsp;<br>&nbsp;<br>==&gt; obviously, if you need to service many users then you need a network with many host ID space&#46; if you only need to host a small number of users, then you only need a network with just enough host ID space&#46;&nbsp;<br>&nbsp;<br>==&gt; we have class A/B/C/D/E network concept&#46; &nbsp;&nbsp;(D, E are for experiments&#46; dont worry too much)&nbsp;<br>&nbsp;<br>(ref) https&#58;//en&#46;wikipedia&#46;org/wiki/Subnetwork&nbsp;<br>(ref) http&#58;//www&#46;tcpipguide&#46;com/free/t_IPAddressClassABandCNetworkandHostCapacities&#46;htm&nbsp;<br>&nbsp;<br>class| &nbsp;&nbsp;&nbsp;addr range &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| network ID &nbsp;| # of hosts&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>&nbsp;&nbsp;A &nbsp;| &nbsp;&nbsp;&nbsp;0&#46;0&#46;0&#46;0 to 127&#46;255&#46;255&#46;255 | &nbsp;&nbsp;8 bits &nbsp;&nbsp;&nbsp;| 2^24 &#45; 2 = 16,777,214 &nbsp;(16&#46;7 mil)&nbsp;<br>&nbsp;&nbsp;B &nbsp;| &nbsp;128&#46;0&#46;0&#46;0 to 191&#46;255&#46;255&#46;255 | &nbsp;16 bits &nbsp;&nbsp;&nbsp;| 2^16 &#45; 2 = 65534&nbsp;<br>&nbsp;&nbsp;C &nbsp;| &nbsp;192&#46;0&#46;0&#46;0 to 223&#46;255&#46;255&#46;255 | &nbsp;24 bits &nbsp;&nbsp;&nbsp;| &nbsp;2^8 &#45; 2 = 254&nbsp;<br>&nbsp;&nbsp;D &nbsp;| &nbsp;224&#46;0&#46;0&#46;0 to 239&#46;255&#46;255&#46;255 | &nbsp;&#45;&#45; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &#45;&#45;&nbsp;<br>&nbsp;&nbsp;E &nbsp;| &nbsp;240&#46;0&#46;0&#46;0 to 247&#46;255&#46;255&#46;255 | &nbsp;&#45;&#45; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &#45;&#45;&nbsp;<br>&nbsp;<br>(quiz) how many class A networks are available ?&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; there can be 2^8 = 256 class A networks in the world&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; because there are only 256 of them, you can google to find who are these 256 owners&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; e&#46;g&#46; AT&T, Apple, MIT, Xerox, IBM, Army, HP, Stanford&nbsp;<br>&nbsp;<br>&nbsp;<br>note&#58; another typical quiz is given an IP addr, it asks &quot;which class is this IP addr?&quot; which you can just look at the first byte, and reference the above&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;why &quot;&#45;2&quot;&nbsp;<br>##&nbsp;<br>&nbsp;<br>it&#039;s because&#58;&nbsp;<br>&#45; the first addr (all host bits = 0) of each subnet is reserved as &quot;network&quot; addr&nbsp;<br>&#45; the last addr (all host bits = 1) of each subnet is reserved as &quot;broadcast&quot; addr&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;what is subnet&nbsp;<br>##&nbsp;<br>&nbsp;<br>suppose you are given a single class C network to manage your company&#039;s network&#46;&nbsp;<br>let&#039;s say the network bits are 192&#46;168&#46;432&#46;xxx&nbsp;<br>so you xxx = 000 is your network addr&nbsp;<br>and xxx = 255 is your broadcast addr&nbsp;<br>and xxx = {1,254} is your host addr space&nbsp;<br>&nbsp;<br>what if you need to service more than 254 users/node ? then NAT is your solution&#46;&nbsp;<br>&nbsp;<br>NOTE&#58;&nbsp;<br>&#45; IPv4 addr is 32 bits &#45; i&#46;e&#46; 4 billion, and running out&#46;&nbsp;<br>&#45; IPv6 (64bit) is a fundamental solution&#46;&nbsp;<br>&#45; in the interium, as a more tactical solution, we had (and still use) NAT (network addr translation) &#58; translates global IP addr to private IP addr&#46;&nbsp;<br>&nbsp;<br>==&gt; now assume your user space is within 254&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;254 is a small number, but still imagine many nodes sending a broadcast packet in the LAN, it can impact the traffic&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;so you may want to further segment (aka subnet) your class C network&#46;&nbsp;<br>&nbsp;<br>e&#46;g&#46;&nbsp;<br>&nbsp;maybe HR has 25 people, IT has 14 people, Sales has 29 people, Marketing has 3 people, so on&#46;&nbsp;<br>&nbsp;so lets subnet your single class C network into subnets based on those departments&#46;&nbsp;<br>&nbsp;what is the biggest department ? (in this case, Sales has 29 people)&nbsp;<br>&nbsp;to host 29, your subnet needs 5 bits (2*5 = 32, but remember the first and last addrs are reserved, so in reality, you only get 32&#45;2 = 30)&nbsp;<br>&nbsp;so, your 8 bit host space can be divided into 3 subnet bits, and 5 host bits&#46;&nbsp;<br>&nbsp;<br>subnet ID bit&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45;&#45;&#45;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11100000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;host ID bit&nbsp;<br>&nbsp;<br>&nbsp;how many subnets do you have ? &nbsp;&nbsp;2^3 = 8&nbsp;<br>&nbsp;how many hosts can you service in each subnet ? &nbsp;2^5 &#45; 2 = 30&nbsp;<br>&nbsp;<br>notice you must allocate your usual network & broadcast addr for EACH subnet you create, so creating many subnets effectively reduce your host addr space slightly&#46;&nbsp;<br>&nbsp;<br>if more than 8 departments, you can maybe consolidate smaller depts into one subnet&#46;&nbsp;<br>also, dont design your subnets based just on current user populatioin&#46; think about potential future change&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;what is subnet mask ?&nbsp;<br>##&nbsp;<br>&nbsp;<br>&quot;subnet mask&quot; is all 1 for network & subnet ID bits, and all 0 for host ID bits&nbsp;<br>&nbsp;<br>e&#46;g&#46; if you have a class C network with no subnet, then your subnet mask is&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11111111&#46;11111111&#46;11111111&#46;00000000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i&#46;e&#46; 255&#46;255&#46;255&#46;0)&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if your subnet ID is 3 bits like the above example, then your subnet mask is&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11111111&#46;11111111&#46;11111111&#46;11100000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i&#46;e&#46; 255&#46;255&#46;255&#46;224) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// notice how binary form is more intuitive than octet to see subnet mask&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==&gt; that&#039;s 27 bits&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==&gt; note sometimes we use CIDR (classless inter domain routing) notation&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&#46;g&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;192&#46;168&#46;432&#46;210/27 &nbsp;&nbsp;# it&#039;s just an IP addr / length_of_subnet_mask&nbsp;<br>&nbsp;<br>&nbsp;<br>subnet mask is useful, because as a router you can extract only the network addr to decide routing&#46;&nbsp;<br>then once reached the right network/subnet, you can extract only the host addr to deliver packet to the end node&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>(ref) http&#58;//www&#46;cse&#46;uconn&#46;edu/~vcb5043/MISC/IP%20Intranet&#46;html&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>loopback (localhost) IP addr &nbsp;= 127&#46;0&#46;0&#46;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// or &nbsp;&#58;&#58;1 in IPv6&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;ARP / RARP &nbsp;&nbsp;&nbsp;&nbsp;&#45; &nbsp;&nbsp;(reverse) addr resolution protocol&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall MAC addr is physical uuid, immutable, unique to the hardware, whereas IP addr is &nbsp;a logical addr, dynamically reassigned&#46;&nbsp;<br>so once a device joins a network, then it gets assigned an IP addr, then as the packet arrives for that IP, we need to know which MAC addr &quot;currently&quot; occupies that IP addr&#46;&nbsp;<br>&nbsp;<br>i&#46;e&#46; this is just L2 &#45; L3 mapping&nbsp;<br>&nbsp;<br>on ethernet&#58;&nbsp;<br>&#45; ARP &#58; converts IP addr to MAC addr (48bit) &nbsp;&nbsp;&nbsp;# used by LAN technologies (e&#46;g&#46; ethernet, token ring, FDDI)&nbsp;<br>&#45; RARP&#58; converts MAC addr to IP addr (assigns IP addr to MAC addr if not one asigned yet) &nbsp;&nbsp;# not used much any more&#46; replaced by BOOTP, DHCP&nbsp;<br>&#45; inARP &#58; inverse ARP&nbsp;<br>&#45; proxy ARP&nbsp;<br>&#45; gratuitous ARP&nbsp;<br>&nbsp;<br>[ARP example]&nbsp;<br>user gives a hostname/URL to an application (http, ftp, telnet, ssh, etc) which uses DNS to discover IP addr&#46;&nbsp;<br>suppose a gateway device/router/switch device receives the packet with a dest IP addr, but doesn&#039;t have MAC&#45;IP mapping table yet&#46;&nbsp;<br>then it sends the &#039;broadcast&#039; ARP&#45;discovery request (frame) to the local network &quot;who has this IP addr?&quot;&nbsp;<br>every node receives the msg but discards the frame if it&#039;s not his IP addr&#46;&nbsp;<br>only the node whose IP is that exact dest IP addr will send &#039;unicast&#039; ARP&#45;reply frame back to the requester&#46;&nbsp;<br>then the requester updates his ARP cache/table, and sends unicast frame to the dest node&#46;&nbsp;<br>&nbsp;<br>[RARP example]&nbsp;<br>usually a client node sends a broadcast RARP msg to the local network&#46;&nbsp;<br>then RARP server device who maintains MAC addr &#45; IP addr table responds &quot;here is your IP addr&quot;&nbsp;<br>&nbsp;<br>NOTE&#58; in ARP, local hosts maintain ARP table, while RARP server maintains RARP table&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;RARP&nbsp;<br>###&nbsp;<br>&nbsp;<br>when a node doesnt know its IP addr, it sends a RARP request, asking for an IP addr based on its MAC addr&#46;&nbsp;<br>central RARP server in each LAN assigns an IP addr to the node&#46;&nbsp;<br>usually each node (like your desktop/laptop) can then store its IP addr, but there may be diskless workstation (very cheap, simplified device) may asks RARP every time&#46;&nbsp;<br>RARP is a simple L2 protocol, it does NOT span across L3 layers, i&#46;e&#46; does not span across routers&#46; i&#46;e&#46; RARP server is needed in each LAN&#46;&nbsp;<br>DHCP can span across routers, thus DHCP replaced RARP&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;ICMP &nbsp;(internet control msg procotol)&nbsp;<br>###&nbsp;<br>&nbsp;<br>a mechanism for TCP/IP to check the various network status of physical connections&#46;&nbsp;<br>an ICP packet is encapsulated in IP datagram&#46;&nbsp;<br>&nbsp;<br>ICMP msg types &#45; there are two kinds &quot;query&quot; and &quot;error&quot;&nbsp;<br>&nbsp;<br>8&#45;bit &quot;type&quot; field indicates info as below&#46;&nbsp;<br>&nbsp;<br>type description&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>&nbsp;0 &nbsp;&nbsp;Echo Reply (Ping Reply, used with Type 8, Ping Request)&nbsp;<br>&nbsp;3 &nbsp;&nbsp;Destination Unreachable (error)&nbsp;<br>&nbsp;4 &nbsp;&nbsp;Source Quench&nbsp;<br>&nbsp;5 &nbsp;&nbsp;Redirect&nbsp;<br>&nbsp;8 &nbsp;&nbsp;Echo Request (Ping Request, used with Type 0, Ping Reply)&nbsp;<br>&nbsp;9 &nbsp;&nbsp;Router Advertisement (Used with Type 9)&nbsp;<br>&nbsp;10 &nbsp;Router Solicitation (Used with Type 10)&nbsp;<br>&nbsp;11 &nbsp;Time Exceeded &nbsp;(error)&nbsp;<br>&nbsp;12 &nbsp;Parameter Problem&nbsp;<br>&nbsp;13 &nbsp;Timestamp Request (Used with Type 14) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// e&#46;g&#46; to sync the time btwn two hosts&nbsp;<br>&nbsp;14 &nbsp;Timestamp Reply (Used with Type 13)&nbsp;<br>&nbsp;15 &nbsp;Information Request (obsolete) (Used with Type 16)&nbsp;<br>&nbsp;16 &nbsp;Information Reply (obsolete) (Used with Type 15)&nbsp;<br>&nbsp;17 &nbsp;Address Mask Request (Used with Type 17)&nbsp;<br>&nbsp;18 &nbsp;Address Mask Reply (Used with Type 18)&nbsp;<br>&nbsp;<br>(ref) http&#58;//www&#46;informit&#46;com/articles/article&#46;aspx?p=26557&seqNum=5&nbsp;<br>&nbsp;<br>===&gt; note&#58; each type has sub types (aka code) that indicates more granular detail&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e&#46;g&#46; type 3 has many sub codes&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code 0 = network unreachable&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code 1 = host unreachable&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code 2 = protocol unreachable&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code 3 = port unreachable&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;many more&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(google for details, or read TCP/IP illustrated)&nbsp;<br>&nbsp;<br>NOTE&#58; depending on the msg type, ICMP pkt is handled at different layers of OS/applications&#46; some ICMP msg is handled at TCP layer, othe rICMP msg is handled at user application layer&#46; so on&#46; &nbsp;usually a layer tries to look at it and doesnt know what to do, then just sends it to upper layer&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;ICMP error msg rules&nbsp;<br>##&nbsp;<br>&nbsp;<br>ICMP error msg shall NOT be generated in response to&nbsp;<br>&#45; another ICMP error msg&nbsp;<br>&#45; IP multicast/broadcast(includinglink layer bcast)/loopback/zero addr &nbsp;(basically any addr that doesnt specify an individual device)&nbsp;<br>&#45; a fragment (other than the first)&nbsp;<br>&nbsp;<br>&#45;&#45;&#45;&gt; the idea is to prevent infinite broadcast storm&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;ICMP example&nbsp;<br>##&nbsp;<br>&nbsp;<br>suppose a host A sends this ICMP msg to a host B, to measure timestamp difference&#46;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;field &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13 (timestamp req)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;code &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 (always 0 in type 13/14 ICMP msg)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;checksum				 &nbsp;&nbsp;checksum of the ICMP msg&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;identifier &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used by application to track requests/responses&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;sequence number &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used by application to track requests/responses&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;32&#45;bit origin timestamp &nbsp;&nbsp;&nbsp;sender sets current time when sending&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;32&#45;bit receive timestamp &nbsp;&nbsp;receiver sets the time when receiving&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;32&#45;bit transmit timestamp &nbsp;receiver sets the time when responding&nbsp;<br>&nbsp;<br>&nbsp;<br>==&gt; host B repsonds with &quot;type 14&quot;, and updates its own checksum, plus &quot;receive/transmit&quot; timestamp (often the same timestamp for both receive/transmit)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;then host A can match the clock time (adjustment considers the roundtrip time of the ICMP packet too)&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;ping&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45; an application to determine if a dest host/network is reachable&#46; ping origin was the name of sonar signal to locate submarines&#46;&nbsp;<br>&#45; since ping is an application, the different implementations depending on the version of the TCP/IP tools, the response given may vary from platform to platform&#46; e&#46;g&#46; HP vs Sun&#46; but the fundamental is the same in various versions of ping implementations&#46;&nbsp;<br>&#45; ping is really just ICMP &quot;echo request&quot; & &quot;echo reply&quot;&nbsp;<br>&nbsp;<br>see here for ICMP packet format &nbsp;&nbsp;https&#58;//en&#46;wikipedia&#46;org/wiki/Ping_(networking_utility)&nbsp;<br>&nbsp;<br>&#45; the identifier field is usually set to PID of the sender application&#46; the sequence numbers are used by the ping program to identify each successive echo request &#45; this allows us to determine if packets are missing/re&#45;ordered/duplicated&#46; recall IP does not guarantee datagram delivery (but TCP tries)&#46; routers may distribute packets across multiple paths (to load balance network traffic, rather than always using the shortest path), which can result in re&#45;ordered packets&#46;&nbsp;<br>&nbsp;<br>&#45; an echo request must have a reply generated (it is not a passive response), systems may be configured to not respond for security reasons&#46; a simple first attack on a system can be done by simply scanning the ports &#45; i&#46;e&#46; sending requests to ports on a list of IP addresses to determine if systems are present, and if particular services are running on those systems&#46; by disabling responses to ping requests (as well as other ICMP types), it will leave the system unexploitable by port scanning&#46; once availables ports are scanned, attacker can try various things like DoS, or access the service, etc&#46;&nbsp;<br>&#45; in addition to individual hosts/systems preventing replies to ping requests, many network administrators enable firewalls to block all ICMP packets from entering an internal network for security purposes&#46; in sych case, individual hosts will never even receive ICMP pkts&#46;&nbsp;<br>&nbsp;<br>[IP Record Route]&nbsp;<br>&#45; ping also allows IP addr at each hop to be recorded to determine the path a datagram takes through the network&#46; there are some significant problems with this feature&#46; the available space to record hops is limited to only 9 IP addr&#46; In the early days of the Internet, 9 hops might have been plenty to get to the destination system, but in todays Internet, the number of hops a datagram can take can be significantly larger&#46;&nbsp;<br>&#45; IP Record Route is a specific method that encodes the hop detail in the packet itself&#45; it is not limited to ping alone, but does require that each device honor the request to record the route and implement it properly&#46; This leads to another significant problem with the IP Record Route option is the consistency of implementation in the networking equipment&#46; Although the RFCs describe the behavior that should be implemented, the actual behavior may be different&#46; We will study next how Traceroute program can be significantly better&#46;&nbsp;<br>&nbsp;<br>NOTE&#58; a popular quiz&#58; what&#039;s the diff btwn &quot;destination host unreachable&quot; VS &quot;ping timeout&quot; ?&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45;&#45; usually, unreachable means the pkt got routed as much as possible but got to a point where a router doesn&#039;t know where to send that pkt any more, probably due to the dest IP non existent or the device shut down&#46; timeout can be a result of ICMP filtering (at firewall layer or individual host layer) or simply pkt dropped due to network congestion / routing error, etc&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;traceroute program&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45; a highly effective (though not perfect) method of determining the path a datagram takes to get to a destination system&#46; the traceroute program mechanism is to send a message that will generate a response from the first &quot;hop&quot; in the path, and after identifying that, send a mesage that will generate a response from the second &quot;hop&quot;, and so on&#46;&nbsp;<br>&nbsp;<br>&#45; as such, traceroute is based on a major assumption &#45; that all of the packets between two systems will travel the same path&#46; this is often true, but when you look at larger networks, (worldwide), and the newer routing methods (dynamically weighting packets for transmission to more evenly distribute traffic across multiple paths), it is becoming increasingly more common that two packets sent from one system to another may actually traverse different paths&#46; to mitigate this, traceroute makes multiple requests to try to determine the path from the sender to the target system&#46;&nbsp;<br>&nbsp;<br>&#45; traceroute uses the ICMP messages as the mechanism to determine the path a datagram takes through the network&#46; the critical component is the TTL (time to live) value in the ICMP structure&#46; TTL is used to force a packet to only travel a known number of hops before being returned as undeliverable&#46;&nbsp;<br>&nbsp;<br>&#45; TTL&#039;s purpose was to remove the chance that a packet could get caught up in a routing loop, where it would continuously traverse the same path, never finding the destination, and creating residual traffic that eventually could exhaust the available network bandwidth&#46; TTL is simply a number that gets decremented by each hop, and when it reaches 0, it will not be forwarded&#46; this allows a packet stuck in a loop to eventually be deleted&#46; Traceroute takes advantage of the response that a device performs when a packet reached the end of its TTL&#46; i&#46;e&#46; TTL forces a packet to only travel as far as the traceroute program wants it to&#46; &nbsp;A critical aspect of the ICMP structure that gives us the functionality of the traceroute program is the fact that an ICMP error is sent back to the originating system in the case of the TTL becoming 0, provided that the system is configured to generate ICMP error messages&#46; In addition, the system that decremented the TTL to 0 will also attach its IP address to the &quot;time exceeded in transit&quot; message&#46;&nbsp;<br>&nbsp;<br>e&#46;g&#46; &nbsp;traceroute starts with TTL=1, then finds the next hop, then tries TTL=2, so on&nbsp;<br>&nbsp;<br>A few key notes about traceroute and the implementations&#58;&nbsp;<br>&nbsp;<br>&#45; An ICMP error message comes from the device generating it &#45; so when a device in the network, like a router, drops a packet because of expired TTL, it sends the ICMP error message from its own address, with the destination the original source of the packet being dropped&#46; This is how the traceroute application can get the IP address of each intermediate hop&#46;&nbsp;<br>&#45; The traceroute application can set the TTL of the packet being sent &#45; in fact, all systems have a default value that is used for the TTL for outgoing packets &#45; but it can be overridden by specific applications&#46; The default for the TTL is usually 32, 64, or 128, depending on the OS&#46; Traceroute sets the TTL to the number of the &quot;hop&quot; that it is tracing to, this forces the TTL to expire at a specific point in the network on the way to the final destination&#46;&nbsp;<br>&#45; Implementations vary slightly between systems &#45; there are two primary differences that you may encounter if you are looking at the packet traces associated with the applications &#45; and that is what the &quot;request&quot; looks like&#46; For most Unix/Linux systems, a request is to a destination port (which identifies the service being requested) as an arbitrarily high, random port number (btwn 33434 &#45; 33534)&#46; For Windows systems, the request is usually a standard &quot;ping&quot; request, to the ICMP port for the target system&#46; This means that in both cases, the ICMP message that is returned by systems other than the final destination will be a &quot;Time exceeded in transit&quot; message &#45; however, when the packet reaches the final target, the response will be an ICMP &quot;echo reply&quot; for traceroute running from a Windows machine, and typically a &quot;port unreachable&quot; from traceroute running on Unix/Linux boxes&#46;&nbsp;<br>While the reponse from the end system may be different &#45; it is irrelevant to the operation of traceroute&#46; Because traceroute is just trying to find the systems that make up the path from the sender to a target system, as long as it gets a response that comes from the target IP address, the type and nature of the response is not important&#46;&nbsp;<br>&#45; Often, routers in the public internet may be configured to not respond to ICMP &#45; in that case, the traceroute application will wait for the requests to time out&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>[traceroute example]&nbsp;<br>&nbsp;<br>&#45; notice it tries 3 times for each TTL&#46; sometimes you get &quot;*&quot; which means the router refused ICMP&nbsp;<br>&nbsp;<br>$ traceroute yahoo&#46;com&nbsp;<br>traceroute to yahoo&#46;com (98&#46;138&#46;219&#46;232), 30 hops max, 60 byte packets&nbsp;<br>&nbsp;1 &nbsp;ve&#45;304&#46;juniper1&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;129) &nbsp;0&#46;499 ms &nbsp;0&#46;500 ms &nbsp;0&#46;494 ms &nbsp;&nbsp;&nbsp;&nbsp;# see results for 3 attempts&nbsp;<br>&nbsp;2 &nbsp;ve100&#46;nexus1&#46;fujisawa&#46;wide&#46;ad&#46;jp (203&#46;178&#46;137&#46;65) &nbsp;1&#46;001 ms &nbsp;1&#46;105 ms &nbsp;1&#46;420 ms&nbsp;<br>&nbsp;3 &nbsp;ve&#45;46&#46;brocade1&#46;nezu&#46;wide&#46;ad&#46;jp (203&#46;178&#46;136&#46;93) &nbsp;10&#46;627 ms &nbsp;10&#46;628 ms &nbsp;10&#46;621 ms&nbsp;<br>&nbsp;4 &nbsp;ve&#45;43&#46;foundry6&#46;otemachi&#46;wide&#46;ad&#46;jp (203&#46;178&#46;136&#46;101) &nbsp;1&#46;926 ms &nbsp;1&#46;926 ms &nbsp;2&#46;008 ms&nbsp;<br>&nbsp;5 &nbsp;ve&#45;51&#46;juniper1&#46;notemachi&#46;wide&#46;ad&#46;jp (203&#46;178&#46;141&#46;142) &nbsp;10&#46;526 ms &nbsp;10&#46;528 ms &nbsp;10&#46;521 ms&nbsp;<br>&nbsp;6 &nbsp;ge&#45;102&#45;0&#45;0&#45;37&#46;r03&#46;tokyjp05&#46;jp&#46;bb&#46;gin&#46;ntt&#46;net (203&#46;105&#46;72&#46;17) &nbsp;4&#46;048 ms &nbsp;2&#46;895 ms &nbsp;2&#46;890 ms&nbsp;<br>&nbsp;7 &nbsp;* * *&nbsp;<br>&nbsp;8 &nbsp;* ae&#45;1&#45;3501&#46;ear2&#46;Denver1&#46;Level3&#46;net (4&#46;69&#46;206&#46;189) &nbsp;148&#46;040 ms &nbsp;148&#46;041 ms&nbsp;<br>&nbsp;9 &nbsp;4&#46;34&#46;62&#46;118 (4&#46;34&#46;62&#46;118) &nbsp;147&#46;977 ms &nbsp;147&#46;983 ms &nbsp;147&#46;980 ms&nbsp;<br>10 &nbsp;ae&#45;5&#46;pat2&#46;nez&#46;yahoo&#46;com (216&#46;115&#46;96&#46;70) &nbsp;164&#46;377 ms &nbsp;164&#46;381 ms &nbsp;164&#46;377 ms&nbsp;<br>11 &nbsp;et&#45;0&#45;0&#45;0&#46;msr1&#46;ne1&#46;yahoo&#46;com (216&#46;115&#46;105&#46;25) &nbsp;144&#46;412 ms et&#45;18&#45;1&#45;0&#46;msr2&#46;ne1&#46;yahoo&#46;com (216&#46;115&#46;105&#46;185) &nbsp;149&#46;314 ms et&#45;19&#45;1&#45;0&#46;msr2&#46;ne1&#46;yahoo&#46;com (216&#46;115&#46;105&#46;181) &nbsp;154&#46;322 ms&nbsp;<br>12 &nbsp;et&#45;0&#45;0&#45;0&#46;clr1&#45;a&#45;gdc&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;97&#46;61) &nbsp;144&#46;367 ms et&#45;1&#45;1&#45;0&#46;clr2&#45;a&#45;gdc&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;97&#46;67) &nbsp;144&#46;870 ms et&#45;1&#45;0&#45;0&#46;clr1&#45;a&#45;gdc&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;97&#46;69) &nbsp;134&#46;788 ms&nbsp;<br>13 &nbsp;po255&#46;bas2&#45;1&#45;flk&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;0&#46;99) &nbsp;146&#46;422 ms po254&#46;bas2&#45;1&#45;flk&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;0&#46;87) &nbsp;135&#46;003 ms po254&#46;bas1&#45;1&#45;flk&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;0&#46;85) &nbsp;146&#46;306 ms&nbsp;<br>14 &nbsp;media&#45;router&#45;fp2&#46;prod1&#46;media&#46;vip&#46;ne1&#46;yahoo&#46;com (98&#46;138&#46;219&#46;232) &nbsp;130&#46;151 ms &nbsp;129&#46;809 ms &nbsp;133&#46;621 ms&nbsp;<br>&nbsp;<br>&nbsp;<br>===&gt; looks like the 7th hop router ignores ICMP but it&#039;s ok we got to know IP addrs for the rest of the route&#46;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onviously, like any other program, traceroute can fail if the destination is unreachable&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>notice traceroute works well only if the route remains consistent&#46; through Strict Source Routing we can specify the path that the packets should follow, and with a little experimentation, you could potentially gather information that would give you an exact path from one address to another&#46; it is important to note, however, that the specific route you determine using Strict Source Routing may not be the only path that the data could take, and unless you are using Strict Source Routing all the time, there is no guarantee that it will follow it&#46; &nbsp;Also, Strict Source Routing will break if devices on the network in that path become unavailable, where most dynamic routing protocols will generate a new path to route around network problems&#46;&nbsp;<br>&nbsp;<br>With smaller networks, especially within corporations, the networks are fairly predictable&#46; The difficulty for this tool shows up with large networks, where the path may be comprised of multiple networks, multiple providers, and large distances with lots of hops&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###########################&nbsp;<br>### &nbsp;&nbsp;&nbsp;&nbsp;IP routing &nbsp;&nbsp;&nbsp;&nbsp;####&nbsp;<br>###########################&nbsp;<br>&nbsp;<br>Today&#039;s IP routing protocols are complex, and offer a number of different methods that data can be routed, even from one device&#46; (One router may support many protocols, and can be configured to use different routing protocols on different interfaces&#46;)&nbsp;<br>&nbsp;<br>Some protocols distribute traffic across multiple paths/routes, in an effort to create evenly distributed traffic, rather than just using the fastest/shortest (or other criteria) path&#46;&nbsp;<br>&nbsp;<br>&#45; a gateway, where data can be directed outside of a local network&#46;&nbsp;<br>&nbsp;<br>&#45; routers, where the data could cross from one network to others&#46; earlier routeres only had a couple of interfaces&#46; Today&#039;s routers can have many interfaces (16+) that allow connectivity to many different networks)&#46;&nbsp;<br>&nbsp;<br>It is important to note that each system with an IP layer will have its own routing table&#46; &nbsp;Typically, when people mention a routing table they are referring to the table maintained by a network router, but the same principles apply for both&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;routing table&nbsp;<br>###&nbsp;<br>&nbsp;<br>lets look at an example&nbsp;<br>&nbsp;<br>$ netstat &#45;rn&nbsp;<br>Kernel IP routing table&nbsp;<br>Destination &nbsp;&nbsp;&nbsp;&nbsp;Gateway &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Genmask &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags &nbsp;&nbsp;MSS Window &nbsp;irtt Iface&nbsp;<br>0&#46;0&#46;0&#46;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;203&#46;178&#46;142&#46;129 0&#46;0&#46;0&#46;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UG &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 em1&nbsp;<br>192&#46;168&#46;1&#46;0 &nbsp;&nbsp;&nbsp;&nbsp;0&#46;0&#46;0&#46;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&#46;255&#46;255&#46;0 &nbsp;&nbsp;U &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 em2&nbsp;<br>203&#46;178&#46;142&#46;128 0&#46;0&#46;0&#46;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&#46;255&#46;255&#46;224 U &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 em1&nbsp;<br>&nbsp;<br>$ ifconfig&nbsp;<br>em1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap&#58;Ethernet &nbsp;HWaddr 00&#58;22&#58;19&#58;6a&#58;3b&#58;70&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr&#58;203&#46;178&#46;142&#46;142 &nbsp;Bcast&#58;203&#46;178&#46;142&#46;159 &nbsp;Mask&#58;255&#46;255&#46;255&#46;224&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr&#58; 2001&#58;200&#58;0&#58;8803&#58;203&#58;178&#58;142&#58;142/64 Scope&#58;Global&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr&#58; fe80&#58;&#58;222&#58;19ff&#58;fe6a&#58;3b70/64 Scope&#58;Link&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST RUNNING MULTICAST &nbsp;MTU&#58;1500 &nbsp;Metric&#58;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets&#58;5965994563 errors&#58;0 dropped&#58;859660 overruns&#58;0 frame&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets&#58;2421129610 errors&#58;0 dropped&#58;0 overruns&#58;0 carrier&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions&#58;0 txqueuelen&#58;1000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes&#58;7811149037513 (7&#46;8 TB) &nbsp;TX bytes&#58;1948379461562 (1&#46;9 TB)&nbsp;<br>&nbsp;<br>em2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap&#58;Ethernet &nbsp;HWaddr 00&#58;22&#58;19&#58;6a&#58;3b&#58;72&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr&#58;192&#46;168&#46;1&#46;2 &nbsp;Bcast&#58;192&#46;168&#46;1&#46;255 &nbsp;Mask&#58;255&#46;255&#46;255&#46;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr&#58; fe80&#58;&#58;222&#58;19ff&#58;fe6a&#58;3b72/64 Scope&#58;Link&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST RUNNING MULTICAST &nbsp;MTU&#58;9000 &nbsp;Metric&#58;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets&#58;15572689576 errors&#58;0 dropped&#58;858226 overruns&#58;0 frame&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets&#58;16922129586 errors&#58;0 dropped&#58;0 overruns&#58;0 carrier&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions&#58;0 txqueuelen&#58;1000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes&#58;4909689294941 (4&#46;9 TB) &nbsp;TX bytes&#58;10509195108068 (10&#46;5 TB)&nbsp;<br>&nbsp;<br>em3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap&#58;Ethernet &nbsp;HWaddr 00&#58;22&#58;19&#58;6a&#58;3b&#58;74&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST MULTICAST &nbsp;MTU&#58;1500 &nbsp;Metric&#58;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets&#58;0 errors&#58;0 dropped&#58;0 overruns&#58;0 frame&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets&#58;0 errors&#58;0 dropped&#58;0 overruns&#58;0 carrier&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions&#58;0 txqueuelen&#58;1000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes&#58;0 (0&#46;0 B) &nbsp;TX bytes&#58;0 (0&#46;0 B)&nbsp;<br>&nbsp;<br>em4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap&#58;Ethernet &nbsp;HWaddr 00&#58;22&#58;19&#58;6a&#58;3b&#58;76&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST MULTICAST &nbsp;MTU&#58;1500 &nbsp;Metric&#58;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets&#58;0 errors&#58;0 dropped&#58;0 overruns&#58;0 frame&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets&#58;0 errors&#58;0 dropped&#58;0 overruns&#58;0 carrier&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions&#58;0 txqueuelen&#58;1000&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes&#58;0 (0&#46;0 B) &nbsp;TX bytes&#58;0 (0&#46;0 B)&nbsp;<br>&nbsp;<br>lo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap&#58;Local Loopback&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr&#58;127&#46;0&#46;0&#46;1 &nbsp;Mask&#58;255&#46;0&#46;0&#46;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr&#58; &#58;&#58;1/128 Scope&#58;Host&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP LOOPBACK RUNNING &nbsp;MTU&#58;65536 &nbsp;Metric&#58;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets&#58;2325907 errors&#58;0 dropped&#58;0 overruns&#58;0 frame&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets&#58;2325907 errors&#58;0 dropped&#58;0 overruns&#58;0 carrier&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions&#58;0 txqueuelen&#58;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes&#58;9837761466 (9&#46;8 GB) &nbsp;TX bytes&#58;9837761466 (9&#46;8 GB)&nbsp;<br>&nbsp;<br>$ arp &#45;a | head&nbsp;<br>? (192&#46;168&#46;1&#46;17) at 00&#58;0c&#58;29&#58;76&#58;16&#58;91 [ether] on em2&nbsp;<br>ve&#45;304&#46;juniper1&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;129) at 00&#58;10&#58;db&#58;ff&#58;10&#58;01 [ether] on em1&nbsp;<br>mail2&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;148) at 00&#58;0c&#58;29&#58;33&#58;1d&#58;72 [ether] on em1&nbsp;<br>dash&#46;sfc&#46;wide&#46;ad&#46;jp&#46;128&#46;142&#46;178&#46;203&#46;in&#45;addr&#46;arpa (203&#46;178&#46;142&#46;138) at 00&#58;0c&#58;29&#58;de&#58;ec&#58;60 [ether] on em1&nbsp;<br>web&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;145) at 00&#58;0c&#58;29&#58;78&#58;0d&#58;e7 [ether] on em1&nbsp;<br>? (203&#46;178&#46;142&#46;154) at &lt;incomplete&gt; on em1&nbsp;<br>? (192&#46;168&#46;1&#46;13) at 00&#58;0c&#58;29&#58;78&#58;0d&#58;f1 [ether] on em2&nbsp;<br>ldap2&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;135) at 00&#58;0c&#58;29&#58;2f&#58;44&#58;33 [ether] on em1&nbsp;<br>ldap1&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;144) at 00&#58;22&#58;19&#58;d4&#58;4a&#58;19 [ether] on em1&nbsp;<br>www&#46;sfc&#46;wide&#46;ad&#46;jp (203&#46;178&#46;142&#46;131) at 00&#58;0c&#58;29&#58;45&#58;14&#58;6a [ether] on em1&nbsp;<br>&#46;&#46;&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>The IP Layer itself maintains the routing table, through a number of ways&#46;&nbsp;<br>&nbsp;<br>First, a routing daemon is typically running on a system&#46; A daemon is a small program that resident in the system, and is usually started up when the system first starts up&#46; These programs run in the background, and provide services to the system and its applications&#46; Other examples are Print daemons and HTTP daemons (used by web servers)&#46; In the case of the routing daemon, it provides updates for the routing table, based on data sent to and from the system&#46; The daemon takes care of the &quot;Routing Policy&quot; &#45; which is what information will go into the routing table&#46; (Rules govern this, and are configured as part of the installation of the routing daemon)&#46;&nbsp;<br>&nbsp;<br>Take a look at the listing in the table&#46; This is the information that the IP layer will use to make the routing decisions&#46; First take a look at the Destination column&#46; This information is the address of either the destination host id (a complete IP address) or a network that is reachable through a specified &quot;hop&quot;&#46; The &quot;hop&quot; is indicated by the Gateway column of the table&#46; The gateway could be a system, or it could be a router&#46; The next field, Flags, gives us a lot of information about the entry&#46; The first &quot;U&quot; indicates that the link is &quot;up&quot;&#46; A &quot;G&quot; indicates that the connection is a router &#45; rather than simply an interface to a local network&#46; The &quot;H&quot; indicates that the address in the destination field is a complete IP address of a destination system&#46; If the &quot;H&quot; is not there, is indicates that the destination address field is a network ID&#46; By default, if you look at the address for a destination that is a network id, any trailing zeros are the bits used to create the subnet mask&#46; (In the example given, 140&#46;252&#46;13&#46;32 has 5 trailing zeros&#46; These 5 bits are the hostid field&#46;)&nbsp;<br>&nbsp;<br>Not shown in the example are the &quot;D&quot; and &quot;M&quot; flags&#46; These are used to indicate that another router had been asked to forward a packet that should not have been sent to it, and subsequently replied with a &quot;Redirect&quot; ICMP message&#46; We will discuss this further, as this was one of the bugs in a major router manufacturer&#039;s software that caused some major routing problems on the internet&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;using a routing table&nbsp;<br>###&nbsp;<br>&nbsp;<br>When there is data to be routed, the first step is to scan the routing table for an exact match for the host id&#46; &nbsp;We saw from the last section that if the &quot;H&quot; flag is set, it is a hostid &#45; therefore this first pass only makes comparisons with the entries with the &quot;H&quot; flag&#46; &nbsp;If it matches, the packet is sent off to the interface corresponding with that entry in the routing table&#46; &nbsp;Although we only looked at a system with one interface, routing tables for systems with multiple interfaces would show more than one interface name in the last column (excluding, of course the localhost interface lo0)&#46;&nbsp;<br>&nbsp;<br>The next step is to look for a match for a network, and appropriately route the packet to the appropriate gateway&#46; If it still cannot find a matching network id, it searches for a default entry&#46;&nbsp;<br>&nbsp;<br>If it cannot find any match, an appropriate ICMP message is generated, and the datagram is discarded&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Forwarding Rules&nbsp;<br>###&nbsp;<br>&nbsp;<br>Forwarding of packets is usually applied to routers, but other systems can also act like routers and forward packets to appropriate destinations based on the routing table&#46; &nbsp;This is only true on systems that are configured to do so&#46; &nbsp;It is important to note that in most circumstances, the gateway of a local are network should be the only system that is configured to forward packets external to the network&#46; &nbsp;As we have seen before, within a local network, routing isn&#039;t really necessary (except for the host sending the data directly to the destination computer on the network&#46;)&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;ICMP Redirect&nbsp;<br>###&nbsp;<br>&nbsp;<br>In some cases, a routing table could have incorrect information&#46; In this case, data could be forwarded to the wrong router on the network&#46; &nbsp;In this case, the router should put back an ICMP redirect error message&#46; &nbsp;The premise of the ICMP redirect is to inform the sender that data headed to the specific destination should be routed through a specific router&#46; (Not the one generating the message)&#46; This is one of the first examples of how the routing of the networks can become very sophisticated, as the routers will &quot;learn&quot; the topology of the network by passing information to each other&#46; This is the premise of the more sophisticated routing protocols used today&#46;&nbsp;<br>&nbsp;<br>Similar in concept to the redirect message, routers can also generate periodic router information messages, that are used to appropriately update and propagate routing information throughout the network&#46; &nbsp;As we see examples of this, we can also see how poorly programmed protocols can bring a whole network down, by passing around invalid routing table information&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Dynamic Routing Protocols&nbsp;<br>###&nbsp;<br>&nbsp;<br>as opposed to statically (manually by human) configured routing table,&nbsp;<br>the routers in a network dynamically communicate with each other to continuously update the routing tables for all the routers&#46; This can be very effective, as it means the network can adapt to equipment going in and out of service without human intervention, and often with little or no impact to the users&#46; Many different routing protocols exist, but let us cover RIP and OSPF&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Routing Information Protocol (RIP)&nbsp;<br>###&nbsp;<br>&nbsp;<br>RIP is one of the original routing protocols, and is still supported in most routers today&#46; &nbsp;The essential concept of RIP is that each router will broadcast its routing table to every connected router every 30 seconds&#46; &nbsp;The information is received by all of the neighboring routers, and they in turn update their own routing tables appropriately&#46; &nbsp;Not only can this system provide updates on routes that are new to the network, as connections are removed, that information is also propagated throughout the network&#46; &nbsp;The update times for adds/deletes to the routing table can take minutes to occur, as the protocol also has some delays put in to make sure that a link is completely down before removing it from the list, and since it takes 30 seconds between updates, in a large network it can take many minutes to propagate route information to all routers in the network&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;Problems with RIP&nbsp;<br>#&nbsp;<br>&nbsp;<br>RIP was an early protocol, and was limited in scope&#46; RIP only works well in smaller networks, and the time that it can take to detect and propagate a down link can be troublesome for heavier traffic networks&#46; Many variations of RIP have come about that have alleviated a lot of these problems&#46;&nbsp;<br>&nbsp;<br>Even looking at simply the notification time of 30 seconds between updates &#45; even having three nodes between systems could mean that a failure of a route could take 30 seconds before the &quot;middle&quot; system detects the problem, and up to 30 seconds more before the next system detects the problem&#46; As a result, this delay can be large, and cause a huge impact in the event a system intermittently becomes available &#45; this allows for gaps to exist and propagate in the routing tables across the network&#46; This problem alone makes the early RIP implementation liable to have intermittent connection issues to end systems that take minutes to clear&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Open Shortest Path First (OSPF)&nbsp;<br>###&nbsp;<br>&nbsp;<br>OSPF is another routing protocol that offers some big advantages over RIP&#46; Primarily, OSPF can recover considerably faster than RIP to equipment failure on the network, and does not have the size limitations for the network&#46; &nbsp;In addition, OSPF actively checks the status of links and uses that information to propagate the routing tables throughout the network&#46;&nbsp;<br>&nbsp;<br>OSPF also manages the network in a more practical way &#45; it is centered around the idea of multiple areas connected by systems that are focused on understanding interconnections of the individual areas&#46; This allows for a hierarchy of routing &#45; there is a relationship between the larger areas, where the core routers understand that relationship, and then each individual logical area may be made up of multiple internal routers to manage to connections to the end systems&#46; The combination of a number of smaller areas, connected by a routing backbone, is called an Autonomous System (AS) within OSPF &#45; the edge of the AS is an AS Border Router &#45; this is a system that can learn about other AS&#039;s on the network through other large scale routing protocols, like Border Gateway Protocol (BGP)&#46;&nbsp;<br>&nbsp;<br>This hierarchy allows for a considerably larger overall scale, and because of the ability to manage multiple routes and monitor health, it can recover much more quickly in the event of failure&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##########################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;User Datagram Protocol (UDP) &nbsp;&nbsp;&nbsp;###&nbsp;<br>##########################################&nbsp;<br>&nbsp;<br>The User&#45;Datagram Protocol (UDP) is a transport protocol available as part of the TCP/IP protocol suite&#46; &nbsp;There are significant differences in the application and the method of transfer between TCP and UDP&#46; &nbsp;Although we will go into a lot of detail, TCP transmissions usually span more than one datagram&#46; &nbsp;Each datagram is sequenced, and reassembled at the destination to complete the transfer of data&#46; &nbsp;With UDP, however, it still uses datagrams, but the information to be sent is placed into one datagram&#46;&nbsp;<br>&nbsp;<br>Another significant difference is the method of communcation and reliability&#46; &nbsp;UDP provides no guarantee that the data ever gets to the destination&#46; &nbsp;Also, TCP establishes a &quot;link&quot; with the destination system before transmitting the data, and uses this link to verify the destination is there, and to provide a mechanism to ensure that the data is reassembled properly&#46; &nbsp;UDP sends the data out blind &#45; no sequencing is defined or guaranteed&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;UDP Structure&nbsp;<br>#&nbsp;<br>&nbsp;<br>The following is a list of the fields in a UDP datagram&#58;&nbsp;<br>&nbsp;<br>&#45; Source Port Number&nbsp;<br>&#45; Destination Port Number&nbsp;<br>&#45; UDP Length&nbsp;<br>&#45; UDP Checksum&nbsp;<br>&#45; Data&nbsp;<br>&nbsp;<br>The fields shown are specific to the UDP data &#45; there is also an associated IP header with the datagram&#46;&nbsp;<br>&nbsp;<br>Port numbers are used to identify the sending and receiving applications that the data needs to be forwarded to&#46;√Ç &nbsp;The UDP√Ç &nbsp;length is the length of the UDP header and the data, but not the additional IP header length&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;IP Fragmentation&nbsp;<br>##&nbsp;<br>&nbsp;<br>We have mentioned that the UDP datagram contains all of the information to be sent&#46; &nbsp;One of the problems with the various networking interfaces and protocols, is that the internet can span many different hardware types, platforms, applications, network interfaces, and so on&#46; &nbsp;This diverse set of hardware and software means that various limitations may be placed on the data that is to be transmitted&#46; &nbsp;For instance &#45; ethernet has a limit to the size of the frame of data that can be sent at any one time&#46; &nbsp;This could be a problem if the UDP datagram exceeds this size&#46; &nbsp;To get around the problem of size limitations on various networks, IP fragmentation is used to break the data up into smaller pieces, and then reassemble them at the destination&#46;&nbsp;<br>&nbsp;<br>The IP layer is responsible for determining the Maximum Transmission Unit size (MTU) that will be used&#46; &nbsp;When this is determined (by querying the network interfaces), if the datagram is larger than the MTU, the IP layer fragments the datagram and sends the smaller pieces&#46; It is also possible that other &quot;hops&quot; can further fragment the data &#45; all of the reassembly information is stored in the IP header, and is used by the final destination to reassemble the data before passing it on to the appropriate UDP and TCP handlers&#46;&nbsp;<br>&nbsp;<br>TCP does not typically fragment &#45; the applications are designed to avoid this to provide better performance and reliability of the data&#46; &nbsp;UDP on the other hand, uses only one datagram for all of the data to be sent (of course the application has control over how it will ultimately break up data to be sent so this can be tuned by the application somewhat), and can easily exceed the network MTU, and will be fragmented&#46;&nbsp;<br>&nbsp;<br>One of the primary differences between TCP and UDP regarding fragmentation is what happens in the event that data is lost&#46; &nbsp;If one fragment in the middle of a transmission is lost, the entire fragmented data must be resent&#46; &nbsp;With TCP, the data is a &quot;stream&quot; of datagrams, and in the event that it gets fragmented, only the one &quot;piece&quot; that was fragmented would need to be resent&#46; &nbsp;TCP can reassemble the rest of the data&#46; &nbsp;UDP uses only one large datagram for the information, and therefore, if any piece is lost, the entire set of data would need to be resent&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Path MTU&nbsp;<br>##&nbsp;<br>&nbsp;<br>One thing to keep in mind with the MTU of a network is that the MTU will vary from path to path, and from system to system&#46; &nbsp;For instance &#45; if the MTU was 1500 bytes in the network that generates a datagram, but a link in the middle of the path had a smaller MTU &#45; say 1000 bytes &#45; the overall MTU for the &quot;path&quot; is 1000 bytes&#46;&nbsp;<br>&nbsp;<br>Like the TTL used in the traceroute program, a similar procedure can be used to determine the MTU of a network between two systems&#46; &nbsp;IP provides a &quot;Don&#039;t Frament&quot; (DF) flag that informs the network components that they are not allowed to fragment the data&#46; &nbsp;In the event that the data is too large for the physical components, and the DF flag is set &#45; the receiving system will generate an ICMP &quot;Can&#039;t Fragment&quot; error&#46; &nbsp;In newer implementations, it also provides the necessary MTU for the &quot;next hop&quot;&#46; &nbsp;Similar to starting out with a TTL of 1, and incrementing it each time to determine each &quot;hop&quot; between two systems, the DF flag, in conjunction with a varying UDP datagram size, can be used to determine the MTU of a network link&#46; &nbsp;A datagram with a large length (~1500 bytes) can be sent with the DF flag set, and then continuously reduced until the data reaches the destination&#46; &nbsp;If the newer systems return the MTU of the &quot;next hop&quot;, multiple iterations are not necessary &#45; it simply can set the UDP length to the appropriate size for the next hop&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Datagram Size Considerations&nbsp;<br>##&nbsp;<br>&nbsp;<br>Theoretically there is a maximum size of 65535 for an IP datagram, but in actuality this is not implemented&#46; &nbsp;There are limitations that come from the application and operating system structure, and also within the TCP/IP kernel itself&#46; &nbsp;Most UDP applications will by default keep the datagram size to less than 512 bytes&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Bootstrap Protocol (BOOTP)&nbsp;<br>###&nbsp;<br>&nbsp;<br>In the case of RARP &#45; a diskless workstation could determine its own IP address through a RARP request and reply&#46; &nbsp;The significant limitation to this however, was the fact that the RARP was broadcast using the network link&#45;layer, and therefore needs to have a RARP sever on the local network&#46; &nbsp;The RARP requests could not traverse their way through &nbsp;routers&#46;&nbsp;<br>&nbsp;<br>BOOTP provides a method for diskless systems to determine their IP address through the use of a UDP datagram&#46; &nbsp;The BOOTP protocol also can transfer a lot of information about the systems involved, where RARP really only transfers the IP address that was requested&#46;&nbsp;<br>&nbsp;<br>#&nbsp;<br># &nbsp;BOOTP Structure&nbsp;<br>#&nbsp;<br>&nbsp;<br>If you take a look at the following table, you get an idea of how much information is actually transferred as part of a BOOTP request/reply&#46;&nbsp;<br>&nbsp;<br>&#45; Opcode (1 = request, 2=reply)&nbsp;<br>&#45; Hardware type (1 = ethernet)&nbsp;<br>&#45; Hardware Address Length&nbsp;<br>&#45; Hop Count&nbsp;<br>&#45; Transaction ID&nbsp;<br>&#45; Number of seconds&nbsp;<br>&#45; Client IP address&nbsp;<br>&#45; your IP address&nbsp;<br>&#45; Server IP Address&nbsp;<br>&#45; gateway IP address&nbsp;<br>&#45; Client Hardware Address&nbsp;<br>&#45; Server hostname&nbsp;<br>&#45; Boot filename&nbsp;<br>&#45; Vendor&#45;specific information&nbsp;<br>&nbsp;<br>Notice the first few fields indicate that BOOTP is available on various network types, with varying hardware addressing schemes&#46; &nbsp;The transaction ID is used to allow a single system to pick out the reply if multiple BOOTP replies were being transmitted at any one time&#46;&nbsp;<br>&nbsp;<br>Notice also that the IP addresses that are collected help a system know a lot more about it&#039;s network than RARP does&#46;&nbsp;<br>&nbsp;<br>All of this information is part of the UDP datagram &#45; this means that the many higher level applications can be written to gather this information and use it, whereas RARP does not pass this information along to the upper layers&#46;&nbsp;<br>&nbsp;<br>DHCP is an extension of the BOOTP protocol, providing a much richer set of options and is now the most commonly used method for administering addresses for systems within IP networks&#46; More than likely, your home network has a DHCP server for your internal machines if you have a cable or DSL router &#45; the DHCP server running on those devices is the one responsible for providing your local network systems with addresses like 192&#46;168&#46;1&#46;x and 10&#46;0&#46;0&#46;x&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Port Numbers&nbsp;<br>##&nbsp;<br>&nbsp;<br>To ensure that the BOOTP protocol is efficient, and does not add more traffic than necessary to accomplish its goal of identifying a system, there are seperate request and reply port numbers that are defined for use&#46; Port number 67 is for the server, and 68 is for the diskless (client) system&#46; This allows the broadcast from the client only to be listened to by servers running the BOOTP application, and vice versa&#46; This limits the number of systems that need to use overhead to respond to network activity not destined for them&#46;&nbsp;<br>&nbsp;<br>Because the DHCP protocol uses the same port as BOOTP, most packet decoding software will identify the DHCP packets as BOOTP &#45; you can see this on tools like Wireshark when looking at DHCP traffic on a local network&#46;&nbsp;<br>&nbsp;<br>NOTE&#58; why does DHCP (and BOOTP) use UDP instead of TCP? &nbsp;&nbsp;&nbsp;# a typical quiz question&nbsp;<br>&nbsp;<br>in short, because DHCP starts by sending a broadcast message called &#039;discover&#039;, it&#039;s a connetionless service model&#46; (client hosts dont know DHCP server&#039;s IP addr), hence UDP&#46; because TCP is a connection oriented protocol where you need to explicitly know the dest addr&#46;&nbsp;<br>&nbsp;<br>(ref) https&#58;//www&#46;quora&#46;com/Why&#45;does&#45;DHCP&#45;use&#45;UDP&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;BOOTP Across Routers&nbsp;<br>##&nbsp;<br>&nbsp;<br>one advantage of BOOTP is the ability to traverse across networks&#46; This is accomplished by allowing the routers to listen for BOOTP datagrams, and appropriately updating the gateway IP address in the datagram, and forwarding the packet along&#46; &nbsp;This allows the BOOTP server on another network to direct the datagram right back through the routers that it used to get there, and direct it to the client more efficiently&#46; &nbsp;This way, the path to the client is acheived through the same IP routing that we have seen in the past&#46;&nbsp;<br>&nbsp;<br>This is something that needs to be enabled, however, on the routing devices in the network for this to work&#46; Many offices that have a single DHCP server will enable this on all the internal routers, to allow the one server to handle all of their systems&#46; Typically this is an option in the settings of routers that is called either &quot;DHCP forwarding&quot; or &quot;BOOTP forwarding&quot;&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>#################################################&nbsp;<br>### &nbsp;&nbsp;&nbsp;TCP &nbsp;(transmission control protocol) &nbsp;&nbsp;###&nbsp;<br>#################################################&nbsp;<br>&nbsp;<br>TCP&#58; a connection&#45;oriented, reliable transport (L4) protocol&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;services &nbsp;&#45; &nbsp;UDP vs TCP&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall UDP that provides a connectionless, unguaranteed datagram delivery service, with the pitfalls discussed in previous lectures&#46;&nbsp;<br>TCP on the other hand, provides a connection&#45;oriented, reliable, byte&#45;stream delivery service&#46;&nbsp;<br>&nbsp;<br>we need to define how we consider TCP &quot;reliable&quot; compared to other protocols like UDP&#46;&nbsp;<br>with UDP, the datagrams are sent out, but there is no guarantee that the destination is reachable or even exists&#46;&nbsp;<br>with TCP, the concept of a &quot;connection&quot; makes a big step forward to ensure reliable data transmission&#46; &quot;connection&quot; means that both the sender and the receiver (which becomes arbitrary as we will see) must establish a link between them, and that they both respond to each other before data is transmitted&#46;&nbsp;<br>&nbsp;<br>keep in mind with these protocols the associated overhead with each&#46; As the checks and balances increase, and error checking is more thorough, this inevitably leads to higher complexity (overhead), and decreased performance (with all other things being equal)&#46; In the case of the comparisons between UDP and TCP, looking at simply the additional time used to establish the connection will decrease the overall throughput, but the balance needs to be struck between performance and reliability&#46; &nbsp;let us study the advantages of TCP, and why it is a good protocol for use with the internet&#46;&nbsp;<br>&nbsp;<br>[ASIDE]&#58; what are the similarity/difference btwn telephone network and IP/TCP ?&nbsp;<br>&#45; telephone is circuit switched network, where two end points reserve the bandwidth (circuit)&nbsp;<br>&#45; internet/TCP is packet switched network, where bandwidth is &quot;shared&quot;&nbsp;<br>&#45;&#45; they are similar because they are both connection oriented&#46; (assume TCP)&nbsp;<br>&nbsp;<br>(ref) https&#58;//www&#46;quora&#46;com/What&#45;are&#45;the&#45;similarities&#45;between&#45;telephony&#45;network&#45;and&#45;internet&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP Header&nbsp;<br>###&nbsp;<br>&nbsp;<br>TCP header and datagram are encapsulated within an IP datagram&#58;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>&nbsp;&nbsp;&nbsp;IP Header&#58; &nbsp;20 Bytes&nbsp;<br>&nbsp;&nbsp;TCP Header&#58; &nbsp;20 Bytes&nbsp;<br>TCP Datagram&#58; &nbsp;Variable&nbsp;<br>&nbsp;<br>&nbsp;<br>TCP header is defined as follows&#58;&nbsp;<br>&nbsp;<br>&nbsp;size &nbsp;&nbsp;description&nbsp;<br>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&nbsp;<br>16&#45;Bit &nbsp;Source Port Number&nbsp;<br>16&#45;Bit &nbsp;Destination Port Number&nbsp;<br>32&#45;Bit &nbsp;Sequence Number&nbsp;<br>32&#45;Bit &nbsp;Acknowledgment Number&nbsp;<br>&nbsp;4&#45;Bit &nbsp;Header Length&nbsp;<br>&nbsp;6&#45;Bit &nbsp;Reserved Field&nbsp;<br>&nbsp;6&#45;Bit &nbsp;Flag Field (URG, ACK, PSH, RST, SYN, FIN)&nbsp;<br>16&#45;Bit &nbsp;Window Size&nbsp;<br>16&#45;Bit &nbsp;TCP Checksum&nbsp;<br>16&#45;Bit &nbsp;Urgent Pointer&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options (if any)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data (if any)&nbsp;<br>&nbsp;<br>&nbsp;<br>the important parts are the two port numbers&#58; &quot;sequence&quot; and &quot;acknowledgment&quot; numbers, and the flags&#46; These are the indicators of the &quot;connection&#45;oriented&quot; nature of the TCP protocol&#46;&nbsp;<br>For a connection to be made, the two ends must be defined by both the IP address and the port number for the application&#46; The IP Header has the IP Addresses, and the TCP Header has the ports&#46; The combination of the flags and the sequence and acknowledgment numbers help TCP to monitor and control the flow of data&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP Connection Establishment and Termination&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall TCP is a &quot;connection&#45;oriented&quot; protocol&#46; To accomplish this, the protocol provides the necessary support to establish a connection (through multiple steps) between two systems, and methods of terminating the connection when finished&#46; This is one of the primary differences between TCP and UDP, where UDP does no checking before sending out data to a destination&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Connections&nbsp;<br>##&nbsp;<br>&nbsp;<br>The connection between two computers is defined by the two endpoints on the network&#46; the endpoints may be from multiple applications running on two systems, or could be individual applications running on many systems&#46; &nbsp;regardless, we can boil a TCP connection endpoint down to the IP address of the system itself, and the port number associated with the application&#46; i&#46;e&#46; for a given pair of systems, multiple connections can be made, (and often are) between one or more applications&#46; &nbsp;TCP provides a good set of tools to create, remove, and maintain multiple connections on a given network&#46; &nbsp;In addition, note the &quot;connection&quot; is not a permanent and continuous flow of traffic between two points&#46; The connections can be established, and maintained with a minimum of &quot;background&quot; traffic &#45; meaning it is relatively efficient in transmitting the data with low overhead, yet maintaining a good level of reliability&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Connection Establishment Protocol&nbsp;<br>##&nbsp;<br>&nbsp;<br>first, we look at some of the flags we showed in the TCP header &#45; specifically SYN and ACK&#46; These flags are used by the originating and destination system to establish the connection&#46; note that the &quot;connection&quot; is much different than the transmission of UDP data, as the TCP connection does not make one system the source and the other the destination&#46; Instead, the connection creates a link that allows data to be sent in both directions, simultaneously&#46; This is referred to as &quot;full&#45;duplex&#46;&quot; When a system wants to connect to another system, a series of messages are passed to establish the connection&#46;&nbsp;<br>&nbsp;<br>The following is the sequence of &quot;three&#45;way handshake&quot;&#58;&nbsp;<br>&nbsp;<br>1&#46; The originating system sends a TCP segment with the SYN (for SYNchronize sequence numbers) flag set&#46; The TCP header includes the port on the destination computer associated with the desired application, the port number of the originating application, and an initial sequence number (ISN)&#46;&nbsp;<br>&nbsp;<br>2&#46; The receiving system reponds with another SYN segment, also setting the ACK ( for ACKnowledge) flag, and incrementing the sequence number by 1&#46;&nbsp;<br>&nbsp;<br>3&#46; When the originating system receives the ACK from the destination, it responds with a segment with the ACK flag set, but not the SYN flag, and increments the sequence number again by 1&#46; &nbsp;This completes the establishment of the connection&#46;&nbsp;<br>&nbsp;<br>==&gt; &nbsp;the originating system tries to contact the destination system, and then each in turn acknowledge the connection on both ends&#46; The sequence number is critical, as TCP not only is reliable with the connection it provides, but also will re&#45;order packets based on this sequence number before passing the data on to the application&#46; This is another significant difference between TCP and UDP, where there is no guarantee of the order of the datagrams sent by UDP&#46;&nbsp;<br>&nbsp;<br>a typical quiz is &quot;how many packets need exchanged for a TCP conn to be established&quot; &#45; 3&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;Timeouts&nbsp;<br>##&nbsp;<br>&nbsp;<br>When a system cannot reach another to establish a connection, timeouts occur and TCP will attempt to retransmit&#46; This is an important feature of TCP, because it will continue to retransmit packets in the event of loss of data, corrupted segments, or in the case of unreliable network connections&#46; The TCP protocol provides reliable data transmission in each of these cases (within limits) which is one of the reasons it is a good choice for internet communication&#46; The network can have glitches, but the TCP layer takes care of correcting for it, and provides the application above with seamless data&#46;&nbsp;<br>&nbsp;<br>Most implementations of TCP provide an upper limit of 75 seconds for a new connection to be established&#46; This means that the ACK from the server needs to be received within 75 seconds of the start of the TCP requests&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Opens and Closes&nbsp;<br>###&nbsp;<br>&nbsp;<br>one system requests something, the next responds, and so on, until the connection is fully open, or fully closed&#46; Because the TCP connections are full&#45;duplex, we can have the case where one side closes, but not the other&#46; (Is the connection half&#45;open or half&#45;closed? (semantically the same thing, as in half&#45;full or half&#45;empty) TCP provides an option called a half&#45;close&#46; This means one system sends the FIN segment, but the other continues to transmit until completed, and then sends the appropriate FIN to close the other direction&#46; This is used in the case where the server application needs to see an EOF marker before it can transmit its data back to the client&#46; The EOF marker is generated in response to the FIN segment from the client&#46; If a TCP connection is half&#45;closed, it means that the segment now becomes a half&#45;open connection&#46;&nbsp;<br>&nbsp;<br>TCP also supports the event where simultaneous opens or closes are transmitted on a given connection&#46; An ACK can be sent to both the SYN and FIN for both open and close&#46; This means that in either the simultaneous open or simultaneous close, it requires 4 segments to establish or terminate the connection&#46; &nbsp;(The only real difference here is with the open &#45; under normal circumstances, it requires only 3 to establish a connection&#46;) This feature was developed because, although unlikely, simultaneous opens and closes can occur, and the protocol needs to gracefully handle it&#46;&nbsp;<br>&nbsp;<br>a typical quiz then is &quot;how many exchanges to close a TCP conn?&quot; &#45; 4 &nbsp;&nbsp;(because as above, since a TCP conn is full&#45;duplex, each side has to do FIN&#45;ACK exchange)&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP Timeout and Retransmission&nbsp;<br>###&nbsp;<br>&nbsp;<br>we have so far looked at the TCP/IP protocols in sunny&#45;day scenarios for the most part, but TCP/IP is designed to adapt to changes in the network, even catastrophic changes like crashes and equipment failure&#46;&nbsp;<br>&nbsp;<br>In its simplest form, TCP waits for a timeout if it is expecting an acknowledgement, and if it doesn&#039;t within a predefined time, it simply retransmits the information&#46; If you remember from the transmission discussions, the sequence number allows the TCP protocol to reassemble the data even if it becomes mis&#45;ordered&#46; This feature of TCP is instrumental in its ability to adapt quickly to changing network conditions, and provide virtually transparent operation for the user&#46;&nbsp;<br>&nbsp;<br>TCP manages 4 types of timers for its operation, as follows&#58;&nbsp;<br>&nbsp;<br>(1) Retransmission Timer &#45; Tells TCP to resend data that an acknowledgement has not been received for&#46;&nbsp;<br>(2) Persist Timer &#45; Keeps advertising window sizes even if the other end is not accepting any more data&#46;&nbsp;<br>(3) Keepalive Timer &#45; Used to detect a crash or reboot on the other end of a connection&#46;&nbsp;<br>(4) 2MSL Timer &#45; Keeps track of the amount of time that a connection is in a wait_state&#46; This is used to ensure that a connection will be closed after twice the Maximum Segment Lifetime&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Round Trip Time (RTT)&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall the retransmission timer is the driver for when packets are resent, with the assumption that the original was discarded somewhere along the way, or the ACK was discarded&#46; The amount of time that TCP waits before retransmitting varies with the network conditions&#46;&nbsp;<br>&nbsp;<br>In the simple example shown in figure 21&#46;1 of the book (TCP/IP illustrated), take a look at the times that the various packets are sent&#46; The first 5 lines show a normal TCP interaction of data and ACKs, but after the network cable was removed from the destination system we see a unique behavior that illustrates the changing value of the retransmission timer&#46; The amount of time starts out at 1&#46;5 seconds, then doubles each time until it reaches 64 seconds&#46; The doubling effect is the exponential backoff that reduces the traffic for a broken connection, and also helps alleviate the traffic level in cases of high congestion&#46; Routers on a network are designed to handle a certain amount of traffic, and are designed to discard packets when overloaded&#46; The pattern to the discards are often random (although newer ones are more careful, applying the discards to the non&#45;paying customers &#58;) and common with the bursty nature of internet traffic&#46; Given this, discards can easily happen If all of the systems tried to continue to send at the same rate, the traffic would compound the problem&#46; The timer that is used for a base guide is RTT which dynamically changes with network conditions&#46; The RTT value is a smoothed estimator, which bases the current value on a combination of the previous value, the last measured RTT, and the variability of the RTT measurements&#46; The formula was developed to optimize the performance, although it has evolved through time to address unexpected behaviors&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Congestion and Congestion Avoidance&nbsp;<br>###&nbsp;<br>&nbsp;<br>When network congestion appears, the result is usually lost or discarded packets&#46; (this is a fact of life with the current routing technology&#46; The bandwidth is limited, and when it is busy routing as many as it can, new packets can be discarded&#46;) A nice illustration of this is in figure 21&#46;6 in the text&#46; This is only only one TCP connection &#45; imagine hundreds (maybe thousands) of connections between systems, and this becomes even more illustrative&#46; Notice that at three different points, the sequence number drops way down, and then recovers back to the normal sequence (over time)&#46; The average path is a constant slope of transmitted packets over time&#46; The dips correlate with retransmission of data&#46; If you imagine all of the other connections superimposed on this one, the dips of the others would be scattered about , and the average would be that the &quot;dips&quot; would be fairly evenly spread out&#46; The TCP algorithms try to smooth out the retransmissions, and minimize them&#46; Effectively, the dips occur when one end gets packets that are out of sequence&#46; In this case, it continues to wait for the missing packet, all the while storing the new data as it comes in&#46;&nbsp;<br>&nbsp;<br>To avoid the congestion problem as much as possible, two algorithms are employed &#45; slow start and congestion avoidance&#46; Slow start is an exponential increase of segments to be sent without ACKs&#46; As the data flows smoothly, (ACKs are received appropriately), the number of segments is increaded exponentially until it reaches the cwnd (congestion window size)&#46; This is a slowly increasing number, starting at half of the advertised window size&#46; This increases until it reaches the advertised window size&#46; The intent of the two algorithms is to adjust the transmission to be the appropriate size based on the network conditions, rather than by sending out the data by brute force&#46; This helps to smooth the overall injection of traffic into the network, in a controlled manner&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Fast Retransmit and Fast Recovery&nbsp;<br>###&nbsp;<br>&nbsp;<br>Effectively, the Fast retransmit algorithm takes into account that a lost packet should be sent as soon as possible, otherwise the receiving system can be overwhelmed with new data before filling in the blank with the missing one&#46; Since the destination system sends a duplicate ACK immediately, the fast retransmit algorithm will wait for enough duplicates to indicate the packet was lost rather than simply delayed, and then retransmits the apparently missing segment, rather than waiting for the retransmit timer to kick in&#46; This is a little more intelligent planning than simply waiting for time to pass, because it used the duplicate acks as an indicator that a specific packet was lost&#46;&nbsp;<br>&nbsp;<br>Fast recovery tries to limit the backoff of the transmission speed when only small amounts of data appear to be lost/delayed&#46; The algorithm waits for 3 duplicate acks, and then reduces the window by a big factor, but not to the point where the slow&#45;start algorithm is operational&#46; This means that the speed is reduced each time, but no so significiantly that there is an abrupt change in the data flow between two systems&#46; This is intended to allow the retransmission of the missing packets to be taken care of, but not allowing the receivers window to become full&#46; From that point on, the congestion avoidance algorithm is in place, and slowly brings the speed back up to the fill advertised window size&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Repacketization&nbsp;<br>###&nbsp;<br>&nbsp;<br>Repacketization allow TCP to combine packets together, and reduce overhead&#46; this is used when it observes congestion&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP Persist Timer&nbsp;<br>###&nbsp;<br>&nbsp;<br>recall the advertised window size could go to zero if the receivers buffer was full&#46; This causes the sender to wait until it receives a window advertisement that says it can now transmit more data&#46; A problem can occur it this new window size doesn&#039;t make it to the sender &#45; the sender continues to wait for the ok to send more data, and the receiver sits there with an empty buffer waiting for more to be sent&#46; This is avoided through the use of the Persist Timer&#46;&nbsp;<br>&nbsp;<br>Effectively, this timer causes the sender to periodically query the receiver for its window size&#46; These requests are called window&#45;probes&#46; The window probes are sent out with increasing delays between, until it reaches 60 seconds&#46; The increases are exponential like the slow start, but in reverse&#46; These window probes are necessary, because the receiver will only send ACKs to packets that come in&#46; The persist timer ensures that packets are sent, avoiding the problem where the new window size ACK was lost&#46;&nbsp;<br>&nbsp;<br>[TCP delayed acknowledgement] &#45; delays ACK by combining multiple ACKs into one pkt, to reduce overhead, thus increasing throughput (but obviously if the sender waits for ACK then delayed ack method may actually end up degrading performance)&nbsp;<br>(ref) &nbsp;https&#58;//en&#46;wikipedia&#46;org/wiki/TCP_delayed_acknowledgment&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Silly Window Syndrome&nbsp;<br>###&nbsp;<br>&nbsp;<br>Silly window syndrome is caused by either the sender sending only small packets, or by the receiver only advertising small window sizes&#46; In effect, the data transmitted across a connection will have a very large overhead, resulting in unnecessary use of network resources&#46; TCP takes care of this possibility on both ends&#46;&nbsp;<br>&nbsp;<br>For the receiver, the changes in window size is well defined&#46; The window size must be increased by either one full sized segment, or by one half of the buffer&#46; This makes sure the size is not an unnecessarily inefficient window size&#46;&nbsp;<br>&nbsp;<br>For the sender, a simliar requirement is imposed&#46; Packets either smaller than a segment, or half of the receivers window cannot be sent&#46; In addition, TCP allows the sender to repacketize to increase the size of packets as congestion occurs&#46;&nbsp;<br>&nbsp;<br>These requirements for the systems reduce the inefficiencies in the transmission&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP &#58; interactive data flow VS batch/bulk transfer&nbsp;<br>###&nbsp;<br>&nbsp;<br>bulk data transfer&#58; e&#46;g&#46; FTP where an entire file is transmitted, and can span many TCP packets&#46;&nbsp;<br>interactive dataflow&#58; e&#46;g&#46; telnet, where the interaction is usually keystrokes from a user, and often requires fast response, TCP packets are sent with very little data (i&#46;e&#46; smaller/more packets)&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Interactive Input and Delayed Acknowledgement&nbsp;<br>###&nbsp;<br>&nbsp;<br>interactive data is usually small packets of information&#46; &nbsp;If we think about the rlogin command, it transmits a packet for virtually every character typed&#46; recall IP & TCP headers add up to 40 bytes &#45; if we transmit only 1 character, the packet is 41 bytes! Even more so, the TCP protocol sends an ACK to the data that is sent (another 40 bytes!)&#46; &nbsp;For a lot of the interactive programs, such as rlogin, the server also echos back what the user types as a TCP packet (41 bytes) and then expects an ACK from the client (40 bytes)&#46; &nbsp;If we add that up, we get 41+40+41+40 = a whopping 162 bytes, just to send one keystroke of the interactive program! For small networks, this really isn&#039;t a big deal, since the level of traffic is usually not high enough to even show a performance drop as a result, but put a whole lot of these on an already congested network, and the performance sould go down considerably&#46; &nbsp;To address this issue, especially in the case of larger networks, TCP implements Delayed Acknowledgment&#46;&nbsp;<br>&nbsp;<br>[Delayed Acknowledgment]&#58; &nbsp;a technique where the receiver of data &quot;waits&quot; for some other data to send along with the acknowledgment&#46; &nbsp;This way, even if there is only one byte to be sent back, instead of using 40+41=81 bytes to transmit the acknowledgment and the next byte of data, they can be combined into one packet, and sent over, using only 41 bytes&#46; &nbsp;&nbsp;This &quot;wait&quot; period is usually 200ms, after which it simply sends the acknowledgment with no data&#46; &nbsp;In the case where data is ready (which is very often the case), the savings in bandwidth is dramatic&#46; &nbsp;(reduced overhead)&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Nagle Algorithm&nbsp;<br>###&nbsp;<br>&nbsp;<br>Nigle algorithm aims for more efficient bandwidth management&#46; the algorithm works as follow&#58; &nbsp;after data has been sent, it will not send another packet until it receives the ACK from the server&#46; &nbsp;In the meantime, however, it is collecting the data to send, creating a larger, more efficient packet&#46; &nbsp;When the ACK is received, the next (bigger) packet is sent, and again TCP will not send the next one until it receives the ACK from the last one, and so on&#46; &nbsp;The nice part of the algorithm is the fact that the longer the delays, the larger the packets, and the more efficient the transmission is&#46; &nbsp;As the delays get smaller, the packets also get smaller, but where the delays get smaller, the bandwidth is less costly&#46;&nbsp;<br>&nbsp;<br>There are cases where Nagle algorithm does not work &#45; in the case of interactive applications where virtually instantaneous response is needed, i&#46;e&#46; the XWindows environment passes all mouse movements, etc&#46; &nbsp;If the Nagle algorithm was in place, the data may &quot;pile up&quot; waiting for an ACK, and the user would notice that the pointer did not respond correctly to the mouse movement&#46; (it would be delayed up to 200 ms)&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP Bulk data transfer&nbsp;<br>###&nbsp;<br>&nbsp;<br>interactive data flow can have a lot of transmission overhead (as expected)&#46; It is preferred that the user get fast response to their actions, especially in the case of GUIs that use TCP to communicate user inputs remotely&#46; &nbsp;In the case of bulk data, however, we are primarily concerned with efficiency in the data transfer&#46; in the case of the interactive data flow, the data in each packet was often only one or two bytes&#46; &nbsp;For bulk data transfer, (such as FTP), we want the data to be an efficient size&#46; (Note that this is not necessarily the largest size&#46;) &nbsp;In order to adequately judge the proper size for packets, we need to examine a number of factors, such as the reliability of the connection, the maximum packet size available to the protocol, the maximum packet size available without fragmentation, NIC limit, etc&#46; &nbsp;Some of these variables change from network to network, and from local to wide&#45;area networks&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;&nbsp;TCP transmission window size control&nbsp;<br>###&nbsp;<br>&nbsp;<br>TCP incorporates a couple of checks and balances to ensure that data gets to the destination properly, and that one system doesn&#039;t send information faster than the destination can handle it&#46; Knowing that the internet and various networks where TCP is implemented do not always work the way we want, and data still will not make it&#46; &nbsp;In this case, TCP does things to correct the transmission&#46; &nbsp;For the purpose of this discussion, we will focus on the flow of data between two systems, but without worrying about data loss just yet&#46;&nbsp;<br>&nbsp;<br>The basic premise of bulk data flow is as follows&#58;&nbsp;<br>&nbsp;<br>1&#46; The two systems establish a connection (recall three&#45;way handshake)&#46; This synchronizes the two systems, and also establishes a maximum segment size that can be sent across the network without fragmentation&#46; &nbsp;In addition, the &quot;window size&quot; is also advertised, so the two systems know how much each can handle at any one given time&#46; &nbsp;This information is then used to control how the data is transferred between the two systems&#46;&nbsp;<br>&nbsp;<br>2&#46; The sender, knowing the maximum segment size, and the window size, generates the first packets of data, where each is the maximum segment size, and the total bytes in all of the packets does not exceed the window size&#46; (recall this is only for the first packets to be sent&#46; we will see as we go along that TCP adjusts for changing conditions on the fly, eventually transmitting all of the data&#46;) For instance, if the total number of bytes that were to be sent (maybe a file that is going to be ftp&#039;d) were 8192&#46; &nbsp;If the maximum segment size was 1024 bytes, and the window size was 4096, that would mean that the TCP protocol would take the first 4096 bytes (the window size) from the total 8192 bytes, and then would split them up into 4 packets, each being the maximum segment size of 1024&#46;&nbsp;<br>&nbsp;<br>3&#46; The sender sends the packets on the network, and then sits back and waits&#46; &nbsp;(depending on the relative speeds of the sender and the receiver, some of the responses will come back before it gets done sending all of them out&#46; &nbsp;This is okay &#45; we will see how TCP takes care of dealing with all of this&#46;) &nbsp;recall TCP provides a level of guarantee that all of the data arrived at the destination&#46; The way it accomplishes this is through ACKnowledgments of the data&#46; &nbsp;The nice thing about TCP is that it doesn&#039;t require an ACK for every packet&#46; &nbsp;In fact, the ACK only needs to say that it had received all of the data up to a certain point, and can skip providing ACKs for none or many of the packets in between&#46; &nbsp;This allows the protocol to adapt well to varying system speeds and network speeds on the fly&#46; No additional configuration is necessary &#45; the protocol is self&#45;policing&#46;&nbsp;<br>&nbsp;<br>4&#46; As the destination receives the packets, it does a couple of things&#46; &nbsp;First, the packets are placed in an incoming buffer, and then processed and supplied to the receiving application as it goes along&#46; &nbsp;In the meantime, depending on a number of factors, it sends out ACKs saying that it has received all of the packets up to a particular point&#46; &nbsp;This may not include the last packets that arrived on the wire, but the last that it has been able to process&#46; &nbsp;In addition, it also sends back with the ACK the current window size&#46; &nbsp;This indicates to the sender how much of the data that has been sent has been processed&#46; &nbsp;In the last step, the sender had sent 4096 bytes, the window size&#46; &nbsp;If the ACK that comes back to the sender says that the window size was now 0, it would mean that the buffer on the destination was still full&#46; &nbsp;This would tell the sender to hold off sending any more data until it hears from the destination that it has room to process more&#46; &nbsp;If on the other hand, the ACK had a window size of 3072, it would mean that the destination had processed 3072 bytes, and still had 1024 bytes in queue to be processed&#46; &nbsp;This would let the sender know that it was okay to send 3072 bytes (or 3 segments) more data&#46; &nbsp;After it sent that, it would wait until it received an ACK indicating that there was room in the buffer to send more&#46; &nbsp;It should be noted, however, that the TCP protocol could receive an ACK from the first couple of packets before it finished sending the first full window of data&#46; &nbsp;If this happens, the system react on the fly, and the net result is the data is continuously sent, with minimal delays, with the data and the ACKs interleaving each other&#46; &nbsp;This is a fairly constant data flow, but will react as network conditions change&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Fast Sender and Slow Receiver&nbsp;<br>###&nbsp;<br>&nbsp;<br>we discussed some of the variation that can be seen in the situation where the two systems are running at about the same speed, and eluded to the fact that in some cases, one system will be running faster than the other&#46; &nbsp;In the case where the sender is the slow one, (ignoring the variation in network delays) we really don&#039;t have much waiting going on&#46; &nbsp;In that case, the sender is sending out packet after packet, but always getting the ACK before the window size is exhausted&#46; &nbsp;A more interesting case is where we have a fast sender and a slow receiver&#46; &nbsp;In this case, it is possible to send a full window of data before the first ACK even gets sent&#46; &nbsp;e&#46;g&#46; after the connection is established, the sender shoots off the full window size of data (4096 bytes) one after the other&#46; &nbsp;Then the receiver sends back an ACK, but advertises a window size of 0&#46; &nbsp;This means that the 4096 bytes were received, filling the buffer, but the slow system had not processed it&#46; &nbsp;This also illustrates how the system can provide ACKs for only some of the packets&#46; &nbsp;This is done usually when a timer elapses (as we will see) or after every other packet (this provides a better level of efficiency, even if the two systems are working at roughly the same rates&#46;) &nbsp;Notice that shortly after the ACK with the window size of 0, another ACK is sent with the window size of 4096&#46; &nbsp;The sender will wait to send the information until it knows the receiver is ready for more data, so after the receiver&#039;s buffer is processed, the receiver sends out a &quot;window update&quot; that is simply to release more data from the sender&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Sliding Windows and Window Size&nbsp;<br>###&nbsp;<br>&nbsp;<br>once a window size is advertised, and then the size that is advertised as the data was passing from system to system changes as the buffers are filled and processed&#46; &nbsp;This is the basic concept of a sliding window&#46; &nbsp;You can imagine the window being like a opening that is looking at a particular section of a long line of numbers that represent the data that is to be sent&#46; &nbsp;The window starts out viewing the first part of the long stream&#46; &nbsp;The data inside the window is the data that is currently in transit between the TCP applications&#46; &nbsp;The window size will not change on the receiver, but the available window size will vary depending on the factors discussed earlier, such as network delays, varying speeds of systems, and segment sizes&#46;&nbsp;<br>&nbsp;<br>The left edge of the window is a measure of how much data has been fully transmitted between the systems&#46; &nbsp;As the ACKS are passed back from the receiver, the left edge of the window slides to the right&#46; &nbsp;This refers to the window &quot;closing&quot;&#46;&nbsp;<br>&nbsp;<br>As the receiver processes the data in the buffer, it &quot;opens&quot; the window by sending a new window advertisment along with an ACK&#46; &nbsp;This causes the right edge of the window to move to the right, making the window larger&#46;&nbsp;<br>&nbsp;<br>There is also the case where the window can &quot;shrink&quot;, where the window actually shrinks, indicating that data that has already been sent is not part of the window anymore&#46; &nbsp;This actually can cause a problem, and is not seen typically in TCP implementations&#46;&nbsp;<br>&nbsp;<br>additive&#45;increase multiplicative&#45;decrease&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Bulk Data Throughput&nbsp;<br>###&nbsp;<br>&nbsp;<br>different situations that can occur with the differing configurations, the question arises about the overall throughput provided by the protocol under different conditions, and how the throughput is optimized (since this is the goal of bulk data transfer)&nbsp;<br>&nbsp;<br>Much like analyzing the speed that material would go through a manufacturing line, the overall average rate will never exceed the slowest process in the line&#46; &nbsp;(Given one path that material can go through&#46;) &nbsp;The same fundamental theory applies to networks &#45; the overall average rate is dependent on the &quot;bottleneck&quot; or the slowest process in the path&#46; &nbsp;The bottleneck on LANs is usually the slower computer, as the network delays are usually insignificant&#46; &nbsp;In the cases of either slow connections, like SLIP, or through WANs where the RTT and the types and performances of routers will vary, the bottleneck often is a particular link within the path&#46; &nbsp;This is actually the determinant of the overall performance of the connection&#46; (Given averaged performance across the link, averaged delays, etc&#46;) &nbsp;There is no exact measurement of the throughput, given the nature of the networking hardware, protocols, and random timing events&#46; &nbsp;The real problems can occur, however, when the data is sent at a rate that is greater than the intermediate routers can buffer&#46; &nbsp;This is a definite possibility, especially in cases of very high traffic&#46; &nbsp;The most common response for the overflowing routers is an algorithm to discard a number of the packets&#46; &nbsp;This is not a good thing for throughput, as the TCP protocol then needs to retransmit the missing packets, and reconstruct the sequence&#46; The advantage of TCP is it will continue to adapt to ensure complete delivery of the data&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Urgent Mode&nbsp;<br>###&nbsp;<br>&nbsp;<br>TCP&#039;s urgent mode is a method that allows data to be sent with a higher priority than standard data&#46; &nbsp;The real issues is the implementation of the urgent mode versus the RFCs, and also the fact that the most common implementations do not follow the specifications&#46; &nbsp;This means that while some applications use the urgent mode, it does not offer a clear implementation and therefore can result in inconsistent results and the lack of communication&#46;&nbsp;<br>&nbsp;<br>The telnet and rlogin applications use the urgent mode to alert the destination that the data needs to be sent when the destination has set the window size to 0&#46; &nbsp;This is the method used to try to force the interactive data to be processed if the buffers get filled up&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP keep alive timer&nbsp;<br>###&nbsp;<br>&nbsp;<br>In most packet networking scenarios, there are link layer protocols that manage connection status &#45; sending &quot;heartbeats&quot; or other messages that let the two ends know that the connection is still there&#46; Other systems fill the bandwidth in the physical connection with &quot;idle&quot; traffic patterns, where even if the connection was broken or one of the systems crashed, the two end stations would know immediately&#46;&nbsp;<br>&nbsp;<br>In the case of TCP, however, although it is a &quot;connection&#45;oriented&quot; protocol, a TCP connection (as defined by two ip addresses and port numbers, one for each end of the connection) only has dataflow between the endpoints when data needs to be transferred&#46; In the case of a telnet session for instance &#45; you could telnet to a system, and perform a variety of actions, and then let the telnet session sit idle&#46; If you shut off the power to the other computer, you would notice that the Telnet session would not have an error message, or anything to indicate that the other end had crashed&#46; As soon as you attempted to type a command, the Telnet session would then report that &quot;the connection was closed&quot;, or something equivalent&#46; (As a disclaimer &#45; not all Telnets are alike, and for the sake of the example I am saying watch the telnet for around 5&#45;10 seconds as other things may detect that the connection was down and close the telnet for you, so you might see some variation from one implementation to another with regards to its behavior&#46; The key here to see is that the connection is not a physical connection at the TCP layer, and does not indicate a continuous stream of data&#46;)&nbsp;<br>&nbsp;<br>There is a good reason not to have a continuous stream of data &#45; if each connection for TCP did that, the bandwidth of the network would get chewed up very quickly&#46; It is important to note that TCP/IP is a strong protocol for managing many connections to multiple systems, and managing reliable TCP connections versus connectionless UDP data streams, etc&#46; The fact that no data flows on a connection unless there is application data to be sent is important to understanding the inner workings of the protocol&#46; This brings us to the need for some kind of keepalive timer &#45; something that will periodically poll each side to make sure the the connection is still there&#46; There are some disagreements about how this should be done&#45; in most cases, the keepalive is managed by the application itself, to the level needed for that application&#46; For instance&#45; for a connection that was to an electonic mail handler, you might only need to have that checked every ten minutes&#46; For a connection to a stock market alert indicator, you might want to verify that connection every second to make sure nothing was missed&#46; The argument here is that it should be the responsibility of the application to manage that connection, and to verify it as often as necessary based on its own needs&#46;&nbsp;<br>&nbsp;<br>The keepalive timer is not a standard option for TCP/IP, but is implemented by many of the TCP/IP stacks&#46; The issue with the TCP keepalive timer is that the timers are set so long that it is impractical for most of today&#039;s applications, and therefore the application usually keeps track of the connections itself, and consequently reacts much sooner&#46; &nbsp;For TCP, the timer works as follows&#58;&nbsp;<br>&nbsp;<br>(1) Typically, by default, after 2 hours of inactivity on a connection, the server sends out a probe to the end system to verify that it is still responding&#46; If it responds, the server waits another two hours before sending another probe&#46;&nbsp;<br>(2) If the end system doesn&#039;t respond, the server will then retry every 75 seconds for up to 10 times&#46; This is to avoid the case where the endstation is busy, or the network is experiencing a higher than normal burst and doesn&#039;t let the probe or the reply make it all the way&#46; If at any time during this process the end station responds to the probe, the timer is reset to two hours&#46;&nbsp;<br>(3) If it still doesn&#039;t respond, it lets the application know that the connection was lost&#46;&nbsp;<br>&nbsp;<br>Most implementations allow the keepalive time of 2 hours to be changed, but it is a system&#45;wide change that would effect all of the connections from that system&#46; As above, the timer really depends on the application, so typically the applicaitons will detect a connection loss long before the TCP timer does&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;TCP Futures&nbsp;<br>##&nbsp;<br>&nbsp;<br>Ethernet has been the most popular medium for TCP/IP, now extending into the WAN arena as well with the introduction of Gigabit Ethernet over fiber optics&#46; This offers new opportunities to increase the MTU of packets sent out across WANs&#46; Traditionally MTUs on the WANs have been significantly less than the LAN, especially considering Ethernet with a MTU of 1500 bytes&#46;&nbsp;<br>&nbsp;<br>With the dramatic increase in bandwith in the core WAN network for the Internet, TCP now has new issues to deal with to address these changes&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;TCP Performance &nbsp;&#45; &nbsp;optimal packet size (given &quot;store & fwd&quot; nature of IP routers)&nbsp;<br>###&nbsp;<br>&nbsp;<br>With the advances in the networking infrastructure, TCP has to address some limitations that have appeared since the original implementations&#46;&nbsp;<br>&nbsp;<br>One of the most compelling aspects of the changes is the issues of performance surrounding larger and larger bandwidth networks&#46; One of the main issues evolving from these changes is the optimum size for packets on the network&#46; Traditionally, larger packets were always considered more efficient for the network&#46; The reasoning is the following&#58; the larger the packet means the less as a percentage the header and associated overhead is&#46; If you reduce the overhead, so less data is overall being sent, the throughput should be higher, right? Surprisingly, the answer is not necessarily &#45; because of the fundamental nature of the TCP/IP network, and the behavior of IP routers&#46; The general notion here is that routers are &quot;store and forward&quot; devices &#45; meaning that the full packet must be completely captured by the router before it sends it to the next hop&#46; As the packet gets larger, the time that the router &quot;waits&quot; before moving the data along gets longer&#46; In this case, it becomes very possible to create a string of networking equipment that performs better (read faster throughput) using smaller packets than larger ones&#46; Note&#58; using the smaller packets means more overall data, which in turn means more of the bandwidth being used that could be more efficiently be used by other data&#46;&nbsp;<br>&nbsp;<br>What does this all mean for optimizing the packet sizes for today&#039;s networks? It means that there is no absolute answer &#45; but as the devices become smarter, networking equipment will automatically adjust packet sizes based on network usage and path MTU to obtain the most efficient use of the network&#46; This type of intelligence is hard, but we see progress in this direction everyday, especially with the segregation of traffic by QoS mechanisms&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Problems with High Bandwidth&nbsp;<br>###&nbsp;<br>&nbsp;<br>High bandwidth creates some side effects for the sequence numbers&#46; As the bandwidth increases, the sequence number of a retransmitted packet (because of a packet loss and subsequent request) possibly &quot;wraps&quot; around the precision of the sequence number field to be in the same number sequence of currently transmitting data&#46; This means that given the traditional settings for the way TCP handles incoming packets the TCP stack could mistake a retransmitted packet as one that was in the current stream&#46; This would lead to corrupt data being undetected, and sent up to the application layer&#46;&nbsp;<br>&nbsp;<br>we leverage other features of the TCP format to gain the necessary precision to ensure this doesn&#039;t happen&#46; Specifically, using a &quot;timestamp&quot; in conjunction with the sequence number, each packet can be clearly identified to be in the correct sequence&#46;&nbsp;<br>&nbsp;<br>####&nbsp;<br>#### &nbsp;Simple Network Management Protocol (SNMP)&nbsp;<br>####&nbsp;<br>&nbsp;<br>SNMP is a protocol for a networking device to be updated, monitored, setup, changed, and configured all through the network using UDP packets sent to the device through TCP/IP links&#46;&nbsp;<br>&nbsp;<br>The benefit of standardizing the device/equipment mgmt method is primarily for the service providers/admins&#46; These companies (e&#46;g&#46; MCI, Williams) install many different vendor equipment in their networks&#46; They might use a Cisco router, a Jupiter router, and a Lucent switch all in the same network&#46; There are applications called Network Management Systems (NMS) or Element Management Systems (EMS) that allow many different vendors equipment to be managed from one application&#46; (e&#46;g&#46; OpenView by HP)&#46; A service provider can control & monitor all the different pieces of their equipment through this one application&#46;&nbsp;<br>&nbsp;<br>Each vendor equipment may have different features and functionality, so each eendor provides information as part of MIB that can be used by NMS to allow device specific configuration, all the way from setting IP addresses of interfaces to the monitoring of the status of the devices&#46;&nbsp;<br>&nbsp;<br>SNMP uses port 161, and 162 (for trap)&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;SNMP Packets&nbsp;<br>##&nbsp;<br>&nbsp;<br>SNMP is transmitted using UDP&#46; because, imagine SNMP uses TCP and the traffic is congested, then it will timeout/retransmit, further congest the traffic interfering with customer/user traffic&#46; according to (http&#58;//smutz&#46;us/techtips/NetworkLatency&#46;html), 2% pkt loss rate can decrease TCP performance by a factor of 30, and 10% loss rate practically makes TCP timeout all the time, rendering it useless&#46; UDP on the other hand, you just send it anyway, which is what you want&#46; suppose 2 out of 10 pkts get dropped due to congestion, then as long as you keep sending UDP pkts, you get 80% the first time, 96% the second time, 99&#46;2% the third time, so on&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>The SNMP packet has the following parts&#58;&nbsp;<br>&nbsp;<br>&#45; Common SNMP Header&nbsp;<br>&nbsp;&nbsp;&#45; SNMP Version &nbsp;(1=v1, 2=v2, so on)&nbsp;<br>&nbsp;&nbsp;&#45; Community&nbsp;<br>&nbsp;&nbsp;&#45; PDU Type (one of the following&#58;)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; GET&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; GET&#45;NEXT&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; GET response&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; SET&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; TRAP&nbsp;<br>&#45; Get/Set Header&nbsp;<br>&nbsp;&nbsp;&#45; Request ID&nbsp;<br>&nbsp;&nbsp;&#45; Error Status (one of the following&#58;)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; noError&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; tooBig&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; noSuchName&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; badValue&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; readOnly&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#45; genErr&nbsp;<br>&nbsp;&nbsp;&#45; Error Index&nbsp;<br>&#45; Variable Pairs&nbsp;<br>&nbsp;&nbsp;&#45; Name/Value&#46;&#46;&#46;Name/Value&#46;&#46;&#46;&#46;&nbsp;<br>&nbsp;<br>==&gt; All of above info is stored within a UDP packet&#46;&nbsp;<br>&nbsp;<br>The Common Header contains a version&#46; This example is based on the SNMPv1 format &#45; the version field allows future SNMP versions to have more or less information following the common header&#46;&nbsp;<br>&nbsp;<br>The community string is to provide a low level security feature &#45; the equipment can be configured to only allow packets with the proper community string (set by the equipment administrator) to avoid unauthorized NMS systems from changing settings on public equipment&#46;&nbsp;<br>&nbsp;<br>The PDU Type falls into either a Request, a Response, or a Trap&#46; A Request can be a GET &#45; indicating that the NMS wants the value of a parameter in the box, such as its IP address&#46; The equipment would then send a GET response with the value&#46; A GET&#45;NEXT is used to allow an NMS to traverse through a list of information &#45; such as a routing table that may have an unknown number of entries&#46; The equipment responds to each GET&#45;NEXT request with a GET response&#46;&nbsp;<br>&nbsp;<br>A SET request tells the equipment to change the setting of a parameter&#46;&nbsp;<br>&nbsp;<br>TRAP refers to a mechanism to capture errors/alarms and other events&#46; A TRAP is sent out from equipment (i&#46;e&#46; router, aka NMS/SNMP agent, as opposed to manager) and can be used by an NMS to update alarm indications, configuration information, etc&#46; If a connection to a router was suddenly removed, the router could send out a TRAP that indicated this to an NMS &#45; this would in turn alert the operator that something had happened in the network&#46;&nbsp;<br>&nbsp;<br>note&#58; GET/SET commands are sent from NMS/snmp manager entity, but TRAP is sent from device/equipment/router/snmp agent&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Object Identifiers (OID)&nbsp;<br>###&nbsp;<br>&nbsp;<br>The central focus of SNMP is around objects &#45; these refer to the parameters that are modified or monitored in the equipment&#46; These are placed in the SNMP Packets usually in the form of NAME/VALUE pairs&#46; The NAME is an object identifier&#46;&nbsp;<br>&nbsp;<br>OID is a dotted number that maps to the Management Information Base information tree&#46;&nbsp;<br>&nbsp;<br>e&#46;g&#46; &nbsp;&nbsp;1&#46;3&#46;6&#46;1&#46;2&#46;1&#46;4&nbsp;<br>&nbsp;<br>===&gt; this is equivalent to &nbsp;&nbsp;iso&#46;ord&#46;dod&#46;internet&#46;mgmt&#46;mib&#46;ip&nbsp;<br>&nbsp;<br>This notation is used to refer to any object, and you simply go deeper into the tree to refer to more and more specific object definitions&#46; The names are used to make it easier for humans to refer to the specific objects&#46;&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;Management Information Bases (MIB)&nbsp;<br>###&nbsp;<br>&nbsp;<br>MIB is used to define the human readable names that correspond to the object identifiers, and also the type and other properties of the particular objects&#46; Each object has a type associated with it that defines what type of information is stored in the object, much like a variable definition&#46;&nbsp;<br>google for the complete list of the object types such as INTEGER and OCTET STRING&#46;&nbsp;<br>&nbsp;<br>a standard MIB contains many commonly used features that are in most of the networking equipment&#46; This is done to provide a standard method for NMS systems to get some basic information from a device&#46; This standard mib contains things like management IP addresses, and counters for TCP, UDP, etc&#46;&nbsp;<br>&nbsp;<br>In addition to the standard MIB, there is what is called an Enterprise MIB &#45; this is what is provided by the manufacturer of the device, and contains all of the device specific settings and statistics, counters, etc&#46;&nbsp;<br>&nbsp;<br>The prefix of the Enterprise MIB is 1&#46;3&#46;6&#46;1&#46;4&#46;1, which is equivalent to iso&#46;org&#46;dod&#46;internet&#46;private&#46;enterprise&#46; This information is stored in a file, that can be loaded by the NMS system to gain the information about what specific objects that it can control, what information is stored in the objects, and which ones are read only, and which ones are read/write&#46; The objects are set appropriately depending on the information &#45; for instance, the IP address can be read/write so the operator can update the setting when they change the network around, but the MAC address of an ethernet interface would be read only because that is something set at the manufacturer&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;SNMP traps&nbsp;<br>##&nbsp;<br>&nbsp;<br>traps are the mechanism that SNMP uses to indicate events that happen to the equipment to the NMS&#46;&nbsp;<br>(i&#46;e&#46; originates from equipment/snmp agent entity, then gets sent to NMS/snmp manager entity)&nbsp;<br>&nbsp;<br>e&#46;g&#46;&nbsp;<br>if the network device lost its power, the NMS system might receive a &quot;coldStart&quot; trap from the device indicating this&#46; If an ethernet cable was unplugged, the equipment might send a &quot;linkDown&quot; trap to the NMS&#46; Typically, there are many enterprise specific Traps that are defined in the enterprise MIB for the equipment, and these are also sent to the NMS&#46; The NMS uses the MIB file to look up what a particular Trap object refers to, and uses that information to let an operator know what kind of event happened to the equipment&#46; This allows one application to report specific error messages and other events about equipment that is new by using the MIB file&#46;&nbsp;<br>&nbsp;<br>##&nbsp;<br>## &nbsp;SNMP v2&nbsp;<br>##&nbsp;<br>&nbsp;<br>SNMP Version 2 is now being used in industry &#45; it has a couple of extensions that add some new functionality to the SNMP system&#46; Some of these are as follows&#58;&nbsp;<br>&nbsp;&#45; GET BULK &#58; allows a large number of objects to be retrieved all at once&#46;&nbsp;<br>&nbsp;&#45; INFORM &nbsp;&nbsp;&#58; similar to Traps, but is more flexible in where they are sent&#45; they can go from one NMS to another to allow interaction between NMSs to better manage network wide equipment provisioning&#46;&nbsp;<br>&nbsp;&#45; SECURITY &#58; The community string was visible to anyone that wanted to &quot;sniff&quot; the network &#45; this was a security issue for equipment being managed through the public network&#46; SNMPv2 provides several mechanisms to allow for password/username type of functionality, and authorization without this open security hole&#46;&nbsp;<br>&nbsp;<br>SNMPv1 and SNMPv2 are usually supported by new equipment, for compatibility with older equipment and NMS systems&#46;&nbsp;<br>&nbsp;<br>&nbsp;<br>###&nbsp;<br>### &nbsp;SMTP (simple mail transfer protocol)&nbsp;<br>###&nbsp;<br>&nbsp;<br>&#45; It&#039;s the protocol used by modern email service&nbsp;<br></div>
    </section>

<br><hr><section class="footer">&copy; etlq - All Rights Reserved</section>

</main>

  <script>
    const toggle = document.getElementById('themeToggle');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const savedTheme = localStorage.getItem('theme');

    // Initial theme                                                                                                                                              
    if (savedTheme) {
      document.body.classList.toggle('dark', savedTheme === 'dark');
    } else {
      document.body.classList.toggle('dark', prefersDark);
    }

    updateButton();

    toggle.addEventListener('click', () => {
      document.body.classList.toggle('dark');

      const theme = document.body.classList.contains('dark')
        ? 'dark'
        : 'light';

      localStorage.setItem('theme', theme);
      updateButton();
    });

    function updateButton() {
      toggle.textContent = document.body.classList.contains('dark')
        ? '‚òÄÔ∏è Light'
        : 'üåô Dark';
    }
  </script>

</body>
</html>
